"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvg";
exports.ids = ["vendor-chunks/canvg"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvg/lib/index.es.js":
/*!********************************************!*\
  !*** ./node_modules/canvg/lib/index.es.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AElement: () => (/* binding */ AElement),\n/* harmony export */   AnimateColorElement: () => (/* binding */ AnimateColorElement),\n/* harmony export */   AnimateElement: () => (/* binding */ AnimateElement),\n/* harmony export */   AnimateTransformElement: () => (/* binding */ AnimateTransformElement),\n/* harmony export */   BoundingBox: () => (/* binding */ BoundingBox),\n/* harmony export */   CB1: () => (/* binding */ CB1),\n/* harmony export */   CB2: () => (/* binding */ CB2),\n/* harmony export */   CB3: () => (/* binding */ CB3),\n/* harmony export */   CB4: () => (/* binding */ CB4),\n/* harmony export */   Canvg: () => (/* binding */ Canvg),\n/* harmony export */   CircleElement: () => (/* binding */ CircleElement),\n/* harmony export */   ClipPathElement: () => (/* binding */ ClipPathElement),\n/* harmony export */   DefsElement: () => (/* binding */ DefsElement),\n/* harmony export */   DescElement: () => (/* binding */ DescElement),\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   EllipseElement: () => (/* binding */ EllipseElement),\n/* harmony export */   FeColorMatrixElement: () => (/* binding */ FeColorMatrixElement),\n/* harmony export */   FeCompositeElement: () => (/* binding */ FeCompositeElement),\n/* harmony export */   FeDropShadowElement: () => (/* binding */ FeDropShadowElement),\n/* harmony export */   FeGaussianBlurElement: () => (/* binding */ FeGaussianBlurElement),\n/* harmony export */   FeMorphologyElement: () => (/* binding */ FeMorphologyElement),\n/* harmony export */   FilterElement: () => (/* binding */ FilterElement),\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   FontElement: () => (/* binding */ FontElement),\n/* harmony export */   FontFaceElement: () => (/* binding */ FontFaceElement),\n/* harmony export */   GElement: () => (/* binding */ GElement),\n/* harmony export */   GlyphElement: () => (/* binding */ GlyphElement),\n/* harmony export */   GradientElement: () => (/* binding */ GradientElement),\n/* harmony export */   ImageElement: () => (/* binding */ ImageElement),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearGradientElement: () => (/* binding */ LinearGradientElement),\n/* harmony export */   MarkerElement: () => (/* binding */ MarkerElement),\n/* harmony export */   MaskElement: () => (/* binding */ MaskElement),\n/* harmony export */   Matrix: () => (/* binding */ Matrix),\n/* harmony export */   MissingGlyphElement: () => (/* binding */ MissingGlyphElement),\n/* harmony export */   Mouse: () => (/* binding */ Mouse),\n/* harmony export */   PSEUDO_ZERO: () => (/* binding */ PSEUDO_ZERO),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   PathElement: () => (/* binding */ PathElement),\n/* harmony export */   PathParser: () => (/* binding */ PathParser),\n/* harmony export */   PatternElement: () => (/* binding */ PatternElement),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PolygonElement: () => (/* binding */ PolygonElement),\n/* harmony export */   PolylineElement: () => (/* binding */ PolylineElement),\n/* harmony export */   Property: () => (/* binding */ Property),\n/* harmony export */   QB1: () => (/* binding */ QB1),\n/* harmony export */   QB2: () => (/* binding */ QB2),\n/* harmony export */   QB3: () => (/* binding */ QB3),\n/* harmony export */   RadialGradientElement: () => (/* binding */ RadialGradientElement),\n/* harmony export */   RectElement: () => (/* binding */ RectElement),\n/* harmony export */   RenderedElement: () => (/* binding */ RenderedElement),\n/* harmony export */   Rotate: () => (/* binding */ Rotate),\n/* harmony export */   SVGElement: () => (/* binding */ SVGElement),\n/* harmony export */   SVGFontLoader: () => (/* binding */ SVGFontLoader),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   Screen: () => (/* binding */ Screen),\n/* harmony export */   Skew: () => (/* binding */ Skew),\n/* harmony export */   SkewX: () => (/* binding */ SkewX),\n/* harmony export */   SkewY: () => (/* binding */ SkewY),\n/* harmony export */   StopElement: () => (/* binding */ StopElement),\n/* harmony export */   StyleElement: () => (/* binding */ StyleElement),\n/* harmony export */   SymbolElement: () => (/* binding */ SymbolElement),\n/* harmony export */   TRefElement: () => (/* binding */ TRefElement),\n/* harmony export */   TSpanElement: () => (/* binding */ TSpanElement),\n/* harmony export */   TextElement: () => (/* binding */ TextElement),\n/* harmony export */   TextPathElement: () => (/* binding */ TextPathElement),\n/* harmony export */   TitleElement: () => (/* binding */ TitleElement),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   Translate: () => (/* binding */ Translate),\n/* harmony export */   UnknownElement: () => (/* binding */ UnknownElement),\n/* harmony export */   UseElement: () => (/* binding */ UseElement),\n/* harmony export */   ViewPort: () => (/* binding */ ViewPort),\n/* harmony export */   compressSpaces: () => (/* binding */ compressSpaces),\n/* harmony export */   \"default\": () => (/* binding */ Canvg),\n/* harmony export */   getSelectorSpecificity: () => (/* binding */ getSelectorSpecificity),\n/* harmony export */   normalizeAttributeName: () => (/* binding */ normalizeAttributeName),\n/* harmony export */   normalizeColor: () => (/* binding */ normalizeColor),\n/* harmony export */   parseExternalUrl: () => (/* binding */ parseExternalUrl),\n/* harmony export */   presets: () => (/* binding */ index),\n/* harmony export */   toNumbers: () => (/* binding */ toNumbers),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   vectorMagnitude: () => (/* binding */ vectorMagnitude),\n/* harmony export */   vectorsAngle: () => (/* binding */ vectorsAngle),\n/* harmony export */   vectorsRatio: () => (/* binding */ vectorsRatio)\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.promise.js */ \"(ssr)/./node_modules/core-js/modules/es.promise.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.string.match.js */ \"(ssr)/./node_modules/core-js/modules/es.string.match.js\");\n/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.string.replace.js */ \"(ssr)/./node_modules/core-js/modules/es.string.replace.js\");\n/* harmony import */ var core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.string.starts-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.starts-with.js\");\n/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.array.iterator.js\");\n/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.array.reduce.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reduce.js\");\n/* harmony import */ var core_js_modules_es_string_ends_with_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.string.ends-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.ends-with.js\");\n/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.string.split.js */ \"(ssr)/./node_modules/core-js/modules/es.string.split.js\");\n/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! raf */ \"(ssr)/./node_modules/raf/index.js\");\n/* harmony import */ var core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/es.string.trim.js */ \"(ssr)/./node_modules/core-js/modules/es.string.trim.js\");\n/* harmony import */ var rgbcolor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rgbcolor */ \"(ssr)/./node_modules/rgbcolor/index.js\");\n/* harmony import */ var core_js_modules_es_array_index_of_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"(ssr)/./node_modules/core-js/modules/es.array.index-of.js\");\n/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! core-js/modules/es.string.includes.js */ \"(ssr)/./node_modules/core-js/modules/es.string.includes.js\");\n/* harmony import */ var core_js_modules_es_array_reverse_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! core-js/modules/es.array.reverse.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reverse.js\");\n/* harmony import */ var svg_pathdata__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! svg-pathdata */ \"(ssr)/./node_modules/svg-pathdata/lib/SVGPathData.module.js\");\n/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"(ssr)/./node_modules/core-js/modules/es.regexp.to-string.js\");\n/* harmony import */ var stackblur_canvas__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! stackblur-canvas */ \"(ssr)/./node_modules/stackblur-canvas/dist/stackblur-es.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Options preset for `OffscreenCanvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @returns Preset object.\r\n */ function offscreen() {\n    var { DOMParser: DOMParserFallback } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var preset = {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParserFallback,\n        createCanvas (width, height) {\n            return new OffscreenCanvas(width, height);\n        },\n        createImage (url) {\n            return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n                var response = yield fetch(url);\n                var blob = yield response.blob();\n                var img = yield createImageBitmap(blob);\n                return img;\n            })();\n        }\n    };\n    if (typeof DOMParser !== \"undefined\" || typeof DOMParserFallback === \"undefined\") {\n        Reflect.deleteProperty(preset, \"DOMParser\");\n    }\n    return preset;\n}\n/**\r\n * Options preset for `node-canvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @param config.canvas - `node-canvas` exports.\r\n * @param config.fetch - WHATWG-compatible `fetch` function.\r\n * @returns Preset object.\r\n */ function node(_ref) {\n    var { DOMParser: DOMParser1, canvas, fetch: fetch1 } = _ref;\n    return {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParser1,\n        fetch: fetch1,\n        createCanvas: canvas.createCanvas,\n        createImage: canvas.loadImage\n    };\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    offscreen: offscreen,\n    node: node\n});\n/**\r\n * HTML-safe compress white-spaces.\r\n * @param str - String to compress.\r\n * @returns String.\r\n */ function compressSpaces(str) {\n    return str.replace(/(?!\\u3000)\\s+/gm, \" \");\n}\n/**\r\n * HTML-safe left trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimLeft(str) {\n    return str.replace(/^[\\n \\t]+/, \"\");\n}\n/**\r\n * HTML-safe right trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimRight(str) {\n    return str.replace(/[\\n \\t]+$/, \"\");\n}\n/**\r\n * String to numbers array.\r\n * @param str - Numbers string.\r\n * @returns Numbers array.\r\n */ function toNumbers(str) {\n    var matches = (str || \"\").match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm) || [];\n    return matches.map(parseFloat);\n} // Microsoft Edge fix\nvar allUppercase = /^[A-Z-]+$/;\n/**\r\n * Normalize attribute name.\r\n * @param name - Attribute name.\r\n * @returns Normalized attribute name.\r\n */ function normalizeAttributeName(name) {\n    if (allUppercase.test(name)) {\n        return name.toLowerCase();\n    }\n    return name;\n}\n/**\r\n * Parse external URL.\r\n * @param url - CSS url string.\r\n * @returns Parsed URL.\r\n */ function parseExternalUrl(url) {\n    //                      single quotes [2]\n    //                      v         double quotes [3]\n    //                      v         v         no quotes [4]\n    //                      v         v         v\n    var urlMatch = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(url) || [];\n    return urlMatch[2] || urlMatch[3] || urlMatch[4];\n}\n/**\r\n * Transform floats to integers in rgb colors.\r\n * @param color - Color to normalize.\r\n * @returns Normalized color.\r\n */ function normalizeColor(color) {\n    if (!color.startsWith(\"rgb\")) {\n        return color;\n    }\n    var rgbParts = 3;\n    var normalizedColor = color.replace(/\\d+(\\.\\d+)?/g, (num, isFloat)=>rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);\n    return normalizedColor;\n}\n// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\nvar attributeRegex = /(\\[[^\\]]+\\])/g;\nvar idRegex = /(#[^\\s+>~.[:]+)/g;\nvar classRegex = /(\\.[^\\s+>~.[:]+)/g;\nvar pseudoElementRegex = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;\nvar pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^)]*\\))/gi;\nvar pseudoClassRegex = /(:[^\\s+>~.[:]+)/g;\nvar elementRegex = /([^\\s+>~.[:]+)/g;\nfunction findSelectorMatch(selector, regex) {\n    var matches = regex.exec(selector);\n    if (!matches) {\n        return [\n            selector,\n            0\n        ];\n    }\n    return [\n        selector.replace(regex, \" \"),\n        matches.length\n    ];\n}\n/**\r\n * Measure selector specificity.\r\n * @param selector - Selector to measure.\r\n * @returns Specificity.\r\n */ function getSelectorSpecificity(selector) {\n    var specificity = [\n        0,\n        0,\n        0\n    ];\n    var currentSelector = selector.replace(/:not\\(([^)]*)\\)/g, \"     $1 \").replace(/{[\\s\\S]*/gm, \" \");\n    var delta = 0;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);\n    specificity[0] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);\n    specificity[2] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);\n    specificity[1] += delta;\n    currentSelector = currentSelector.replace(/[*\\s+>~]/g, \" \").replace(/[#.]/g, \" \");\n    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex); // lgtm [js/useless-assignment-to-local]\n    specificity[2] += delta;\n    return specificity.join(\"\");\n}\nvar PSEUDO_ZERO = .00000001;\n/**\r\n * Vector magnitude.\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorMagnitude(v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n}\n/**\r\n * Ratio between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsRatio(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));\n}\n/**\r\n * Angle between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));\n}\nfunction CB1(t) {\n    return t * t * t;\n}\nfunction CB2(t) {\n    return 3 * t * t * (1 - t);\n}\nfunction CB3(t) {\n    return 3 * t * (1 - t) * (1 - t);\n}\nfunction CB4(t) {\n    return (1 - t) * (1 - t) * (1 - t);\n}\nfunction QB1(t) {\n    return t * t;\n}\nfunction QB2(t) {\n    return 2 * t * (1 - t);\n}\nfunction QB3(t) {\n    return (1 - t) * (1 - t);\n}\nclass Property {\n    constructor(document1, name, value){\n        this.document = document1;\n        this.name = name;\n        this.value = value;\n        this.isNormalizedColor = false;\n    }\n    static empty(document1) {\n        return new Property(document1, \"EMPTY\", \"\");\n    }\n    split() {\n        var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \" \";\n        var { document: document1, name } = this;\n        return compressSpaces(this.getString()).trim().split(separator).map((value)=>new Property(document1, name, value));\n    }\n    hasValue(zeroIsValue) {\n        var { value } = this;\n        return value !== null && value !== \"\" && (zeroIsValue || value !== 0) && typeof value !== \"undefined\";\n    }\n    isString(regexp) {\n        var { value } = this;\n        var result = typeof value === \"string\";\n        if (!result || !regexp) {\n            return result;\n        }\n        return regexp.test(value);\n    }\n    isUrlDefinition() {\n        return this.isString(/^url\\(/);\n    }\n    isPixels() {\n        if (!this.hasValue()) {\n            return false;\n        }\n        var asString = this.getString();\n        switch(true){\n            case asString.endsWith(\"px\"):\n            case /^[0-9]+$/.test(asString):\n                return true;\n            default:\n                return false;\n        }\n    }\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n    getValue(def) {\n        if (typeof def === \"undefined\" || this.hasValue()) {\n            return this.value;\n        }\n        return def;\n    }\n    getNumber(def) {\n        if (!this.hasValue()) {\n            if (typeof def === \"undefined\") {\n                return 0;\n            }\n            return parseFloat(def);\n        }\n        var { value } = this;\n        var n = parseFloat(value);\n        if (this.isString(/%$/)) {\n            n /= 100.0;\n        }\n        return n;\n    }\n    getString(def) {\n        if (typeof def === \"undefined\" || this.hasValue()) {\n            return typeof this.value === \"undefined\" ? \"\" : String(this.value);\n        }\n        return String(def);\n    }\n    getColor(def) {\n        var color = this.getString(def);\n        if (this.isNormalizedColor) {\n            return color;\n        }\n        this.isNormalizedColor = true;\n        color = normalizeColor(color);\n        this.value = color;\n        return color;\n    }\n    getDpi() {\n        return 96.0; // TODO: compute?\n    }\n    getRem() {\n        return this.document.rootEmSize;\n    }\n    getEm() {\n        return this.document.emSize;\n    }\n    getUnits() {\n        return this.getString().replace(/[0-9.-]/g, \"\");\n    }\n    getPixels(axisOrIsFontSize) {\n        var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this.hasValue()) {\n            return 0;\n        }\n        var [axis, isFontSize] = typeof axisOrIsFontSize === \"boolean\" ? [\n            undefined,\n            axisOrIsFontSize\n        ] : [\n            axisOrIsFontSize\n        ];\n        var { viewPort } = this.document.screen;\n        switch(true){\n            case this.isString(/vmin$/):\n                return this.getNumber() / 100.0 * Math.min(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n            case this.isString(/vmax$/):\n                return this.getNumber() / 100.0 * Math.max(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n            case this.isString(/vw$/):\n                return this.getNumber() / 100.0 * viewPort.computeSize(\"x\");\n            case this.isString(/vh$/):\n                return this.getNumber() / 100.0 * viewPort.computeSize(\"y\");\n            case this.isString(/rem$/):\n                return this.getNumber() * this.getRem();\n            case this.isString(/em$/):\n                return this.getNumber() * this.getEm();\n            case this.isString(/ex$/):\n                return this.getNumber() * this.getEm() / 2.0;\n            case this.isString(/px$/):\n                return this.getNumber();\n            case this.isString(/pt$/):\n                return this.getNumber() * this.getDpi() * (1.0 / 72.0);\n            case this.isString(/pc$/):\n                return this.getNumber() * 15;\n            case this.isString(/cm$/):\n                return this.getNumber() * this.getDpi() / 2.54;\n            case this.isString(/mm$/):\n                return this.getNumber() * this.getDpi() / 25.4;\n            case this.isString(/in$/):\n                return this.getNumber() * this.getDpi();\n            case this.isString(/%$/) && isFontSize:\n                return this.getNumber() * this.getEm();\n            case this.isString(/%$/):\n                return this.getNumber() * viewPort.computeSize(axis);\n            default:\n                {\n                    var n = this.getNumber();\n                    if (processPercent && n < 1.0) {\n                        return n * viewPort.computeSize(axis);\n                    }\n                    return n;\n                }\n        }\n    }\n    getMilliseconds() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        if (this.isString(/ms$/)) {\n            return this.getNumber();\n        }\n        return this.getNumber() * 1000;\n    }\n    getRadians() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        switch(true){\n            case this.isString(/deg$/):\n                return this.getNumber() * (Math.PI / 180.0);\n            case this.isString(/grad$/):\n                return this.getNumber() * (Math.PI / 200.0);\n            case this.isString(/rad$/):\n                return this.getNumber();\n            default:\n                return this.getNumber() * (Math.PI / 180.0);\n        }\n    }\n    getDefinition() {\n        var asString = this.getString();\n        var name = /#([^)'\"]+)/.exec(asString);\n        if (name) {\n            name = name[1];\n        }\n        if (!name) {\n            name = asString;\n        }\n        return this.document.definitions[name];\n    }\n    getFillStyleDefinition(element, opacity) {\n        var def = this.getDefinition();\n        if (!def) {\n            return null;\n        } // gradient\n        if (typeof def.createGradient === \"function\") {\n            return def.createGradient(this.document.ctx, element, opacity);\n        } // pattern\n        if (typeof def.createPattern === \"function\") {\n            if (def.getHrefAttribute().hasValue()) {\n                var patternTransform = def.getAttribute(\"patternTransform\");\n                def = def.getHrefAttribute().getDefinition();\n                if (patternTransform.hasValue()) {\n                    def.getAttribute(\"patternTransform\", true).setValue(patternTransform.value);\n                }\n            }\n            return def.createPattern(this.document.ctx, element, opacity);\n        }\n        return null;\n    }\n    getTextBaseline() {\n        if (!this.hasValue()) {\n            return null;\n        }\n        return Property.textBaselineMapping[this.getString()];\n    }\n    addOpacity(opacity) {\n        var value = this.getColor();\n        var len = value.length;\n        var commas = 0; // Simulate old RGBColor version, which can't parse rgba.\n        for(var i = 0; i < len; i++){\n            if (value[i] === \",\") {\n                commas++;\n            }\n            if (commas === 3) {\n                break;\n            }\n        }\n        if (opacity.hasValue() && this.isString() && commas !== 3) {\n            var color = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(value);\n            if (color.ok) {\n                color.alpha = opacity.getNumber();\n                value = color.toRGBA();\n            }\n        }\n        return new Property(this.document, this.name, value);\n    }\n}\nProperty.textBaselineMapping = {\n    \"baseline\": \"alphabetic\",\n    \"before-edge\": \"top\",\n    \"text-before-edge\": \"top\",\n    \"middle\": \"middle\",\n    \"central\": \"middle\",\n    \"after-edge\": \"bottom\",\n    \"text-after-edge\": \"bottom\",\n    \"ideographic\": \"ideographic\",\n    \"alphabetic\": \"alphabetic\",\n    \"hanging\": \"hanging\",\n    \"mathematical\": \"alphabetic\"\n};\nclass ViewPort {\n    constructor(){\n        this.viewPorts = [];\n    }\n    clear() {\n        this.viewPorts = [];\n    }\n    setCurrent(width, height) {\n        this.viewPorts.push({\n            width,\n            height\n        });\n    }\n    removeCurrent() {\n        this.viewPorts.pop();\n    }\n    getCurrent() {\n        var { viewPorts } = this;\n        return viewPorts[viewPorts.length - 1];\n    }\n    get width() {\n        return this.getCurrent().width;\n    }\n    get height() {\n        return this.getCurrent().height;\n    }\n    computeSize(d) {\n        if (typeof d === \"number\") {\n            return d;\n        }\n        if (d === \"x\") {\n            return this.width;\n        }\n        if (d === \"y\") {\n            return this.height;\n        }\n        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n    }\n}\nclass Point {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    static parse(point) {\n        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var [x = defaultValue, y = defaultValue] = toNumbers(point);\n        return new Point(x, y);\n    }\n    static parseScale(scale) {\n        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        var [x = defaultValue, y = x] = toNumbers(scale);\n        return new Point(x, y);\n    }\n    static parsePath(path) {\n        var points = toNumbers(path);\n        var len = points.length;\n        var pathPoints = [];\n        for(var i = 0; i < len; i += 2){\n            pathPoints.push(new Point(points[i], points[i + 1]));\n        }\n        return pathPoints;\n    }\n    angleTo(point) {\n        return Math.atan2(point.y - this.y, point.x - this.x);\n    }\n    applyTransform(transform) {\n        var { x, y } = this;\n        var xp = x * transform[0] + y * transform[2] + transform[4];\n        var yp = x * transform[1] + y * transform[3] + transform[5];\n        this.x = xp;\n        this.y = yp;\n    }\n}\nclass Mouse {\n    constructor(screen){\n        this.screen = screen;\n        this.working = false;\n        this.events = [];\n        this.eventElements = []; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onClick = this.onClick.bind(this); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onMouseMove = this.onMouseMove.bind(this);\n    }\n    isWorking() {\n        return this.working;\n    }\n    start() {\n        if (this.working) {\n            return;\n        }\n        var { screen, onClick, onMouseMove } = this;\n        var canvas = screen.ctx.canvas;\n        canvas.onclick = onClick;\n        canvas.onmousemove = onMouseMove;\n        this.working = true;\n    }\n    stop() {\n        if (!this.working) {\n            return;\n        }\n        var canvas = this.screen.ctx.canvas;\n        this.working = false;\n        canvas.onclick = null;\n        canvas.onmousemove = null;\n    }\n    hasEvents() {\n        return this.working && this.events.length > 0;\n    }\n    runEvents() {\n        if (!this.working) {\n            return;\n        }\n        var { screen: document1, events, eventElements } = this;\n        var { style } = document1.ctx.canvas;\n        if (style) {\n            style.cursor = \"\";\n        }\n        events.forEach((_ref, i)=>{\n            var { run } = _ref;\n            var element = eventElements[i];\n            while(element){\n                run(element);\n                element = element.parent;\n            }\n        }); // done running, clear\n        this.events = [];\n        this.eventElements = [];\n    }\n    checkPath(element, ctx) {\n        if (!this.working || !ctx) {\n            return;\n        }\n        var { events, eventElements } = this;\n        events.forEach((_ref2, i)=>{\n            var { x, y } = _ref2;\n            if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    checkBoundingBox(element, boundingBox) {\n        if (!this.working || !boundingBox) {\n            return;\n        }\n        var { events, eventElements } = this;\n        events.forEach((_ref3, i)=>{\n            var { x, y } = _ref3;\n            if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    mapXY(x, y) {\n        var { window: window1, ctx } = this.screen;\n        var point = new Point(x, y);\n        var element = ctx.canvas;\n        while(element){\n            point.x -= element.offsetLeft;\n            point.y -= element.offsetTop;\n            element = element.offsetParent;\n        }\n        if (window1.scrollX) {\n            point.x += window1.scrollX;\n        }\n        if (window1.scrollY) {\n            point.y += window1.scrollY;\n        }\n        return point;\n    }\n    onClick(event) {\n        var { x, y } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: \"onclick\",\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onClick) {\n                    eventTarget.onClick();\n                }\n            }\n        });\n    }\n    onMouseMove(event) {\n        var { x, y } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: \"onmousemove\",\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onMouseMove) {\n                    eventTarget.onMouseMove();\n                }\n            }\n        });\n    }\n}\nvar defaultWindow =  false ? 0 : null;\nvar defaultFetch$1 = typeof fetch !== \"undefined\" ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.\n : null;\nclass Screen {\n    constructor(ctx){\n        var { fetch: fetch1 = defaultFetch$1, window: window1 = defaultWindow } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.ctx = ctx;\n        this.FRAMERATE = 30;\n        this.MAX_VIRTUAL_PIXELS = 30000;\n        this.CLIENT_WIDTH = 800;\n        this.CLIENT_HEIGHT = 600;\n        this.viewPort = new ViewPort();\n        this.mouse = new Mouse(this);\n        this.animations = [];\n        this.waits = [];\n        this.frameDuration = 0;\n        this.isReadyLock = false;\n        this.isFirstRender = true;\n        this.intervalId = null;\n        this.window = window1;\n        this.fetch = fetch1;\n    }\n    wait(checker) {\n        this.waits.push(checker);\n    }\n    ready() {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        if (!this.readyPromise) {\n            return Promise.resolve();\n        }\n        return this.readyPromise;\n    }\n    isReady() {\n        if (this.isReadyLock) {\n            return true;\n        }\n        var isReadyLock = this.waits.every((_)=>_());\n        if (isReadyLock) {\n            this.waits = [];\n            if (this.resolveReady) {\n                this.resolveReady();\n            }\n        }\n        this.isReadyLock = isReadyLock;\n        return isReadyLock;\n    }\n    setDefaults(ctx) {\n        // initial values and defaults\n        ctx.strokeStyle = \"rgba(0,0,0,0)\";\n        ctx.lineCap = \"butt\";\n        ctx.lineJoin = \"miter\";\n        ctx.miterLimit = 4;\n    }\n    setViewBox(_ref) {\n        var { document: document1, ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX = 0, minY = 0, refX, refY, clip = false, clipX = 0, clipY = 0 } = _ref;\n        // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n        var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\\s/, \"\"); // ignore defer\n        var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(\" \");\n        var align = aspectRatioAlign || \"xMidYMid\";\n        var meetOrSlice = aspectRatioMeetOrSlice || \"meet\"; // calculate scale\n        var scaleX = width / desiredWidth;\n        var scaleY = height / desiredHeight;\n        var scaleMin = Math.min(scaleX, scaleY);\n        var scaleMax = Math.max(scaleX, scaleY);\n        var finalDesiredWidth = desiredWidth;\n        var finalDesiredHeight = desiredHeight;\n        if (meetOrSlice === \"meet\") {\n            finalDesiredWidth *= scaleMin;\n            finalDesiredHeight *= scaleMin;\n        }\n        if (meetOrSlice === \"slice\") {\n            finalDesiredWidth *= scaleMax;\n            finalDesiredHeight *= scaleMax;\n        }\n        var refXProp = new Property(document1, \"refX\", refX);\n        var refYProp = new Property(document1, \"refY\", refY);\n        var hasRefs = refXProp.hasValue() && refYProp.hasValue();\n        if (hasRefs) {\n            ctx.translate(-scaleMin * refXProp.getPixels(\"x\"), -scaleMin * refYProp.getPixels(\"y\"));\n        }\n        if (clip) {\n            var scaledClipX = scaleMin * clipX;\n            var scaledClipY = scaleMin * clipY;\n            ctx.beginPath();\n            ctx.moveTo(scaledClipX, scaledClipY);\n            ctx.lineTo(width, scaledClipY);\n            ctx.lineTo(width, height);\n            ctx.lineTo(scaledClipX, height);\n            ctx.closePath();\n            ctx.clip();\n        }\n        if (!hasRefs) {\n            var isMeetMinY = meetOrSlice === \"meet\" && scaleMin === scaleY;\n            var isSliceMaxY = meetOrSlice === \"slice\" && scaleMax === scaleY;\n            var isMeetMinX = meetOrSlice === \"meet\" && scaleMin === scaleX;\n            var isSliceMaxX = meetOrSlice === \"slice\" && scaleMax === scaleX;\n            if (align.startsWith(\"xMid\") && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width / 2.0 - finalDesiredWidth / 2.0, 0);\n            }\n            if (align.endsWith(\"YMid\") && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height / 2.0 - finalDesiredHeight / 2.0);\n            }\n            if (align.startsWith(\"xMax\") && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width - finalDesiredWidth, 0);\n            }\n            if (align.endsWith(\"YMax\") && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height - finalDesiredHeight);\n            }\n        } // scale\n        switch(true){\n            case align === \"none\":\n                ctx.scale(scaleX, scaleY);\n                break;\n            case meetOrSlice === \"meet\":\n                ctx.scale(scaleMin, scaleMin);\n                break;\n            case meetOrSlice === \"slice\":\n                ctx.scale(scaleMax, scaleMax);\n                break;\n        } // translate\n        ctx.translate(-minX, -minY);\n    }\n    start(element) {\n        var { enableRedraw = false, ignoreMouse = false, ignoreAnimation = false, ignoreDimensions = false, ignoreClear = false, forceRedraw, scaleWidth, scaleHeight, offsetX, offsetY } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { FRAMERATE, mouse } = this;\n        var frameDuration = 1000 / FRAMERATE;\n        this.frameDuration = frameDuration;\n        this.readyPromise = new Promise((resolve)=>{\n            this.resolveReady = resolve;\n        });\n        if (this.isReady()) {\n            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n        }\n        if (!enableRedraw) {\n            return;\n        }\n        var now = Date.now();\n        var then = now;\n        var delta = 0;\n        var tick = ()=>{\n            now = Date.now();\n            delta = now - then;\n            if (delta >= frameDuration) {\n                then = now - delta % frameDuration;\n                if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {\n                    this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                    mouse.runEvents();\n                }\n            }\n            this.intervalId = raf__WEBPACK_IMPORTED_MODULE_11__(tick);\n        };\n        if (!ignoreMouse) {\n            mouse.start();\n        }\n        this.intervalId = raf__WEBPACK_IMPORTED_MODULE_11__(tick);\n    }\n    stop() {\n        if (this.intervalId) {\n            raf__WEBPACK_IMPORTED_MODULE_11__.cancel(this.intervalId);\n            this.intervalId = null;\n        }\n        this.mouse.stop();\n    }\n    shouldUpdate(ignoreAnimation, forceRedraw) {\n        // need update from animations?\n        if (!ignoreAnimation) {\n            var { frameDuration } = this;\n            var shouldUpdate = this.animations.reduce((shouldUpdate, animation)=>animation.update(frameDuration) || shouldUpdate, false);\n            if (shouldUpdate) {\n                return true;\n            }\n        } // need update from redraw?\n        if (typeof forceRedraw === \"function\" && forceRedraw()) {\n            return true;\n        }\n        if (!this.isReadyLock && this.isReady()) {\n            return true;\n        } // need update from mouse events?\n        if (this.mouse.hasEvents()) {\n            return true;\n        }\n        return false;\n    }\n    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {\n        var { CLIENT_WIDTH, CLIENT_HEIGHT, viewPort, ctx, isFirstRender } = this;\n        var canvas = ctx.canvas;\n        viewPort.clear();\n        if (canvas.width && canvas.height) {\n            viewPort.setCurrent(canvas.width, canvas.height);\n        } else {\n            viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);\n        }\n        var widthStyle = element.getStyle(\"width\");\n        var heightStyle = element.getStyle(\"height\");\n        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== \"number\" && typeof scaleHeight !== \"number\")) {\n            // set canvas size\n            if (widthStyle.hasValue()) {\n                canvas.width = widthStyle.getPixels(\"x\");\n                if (canvas.style) {\n                    canvas.style.width = \"\".concat(canvas.width, \"px\");\n                }\n            }\n            if (heightStyle.hasValue()) {\n                canvas.height = heightStyle.getPixels(\"y\");\n                if (canvas.style) {\n                    canvas.style.height = \"\".concat(canvas.height, \"px\");\n                }\n            }\n        }\n        var cWidth = canvas.clientWidth || canvas.width;\n        var cHeight = canvas.clientHeight || canvas.height;\n        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {\n            cWidth = widthStyle.getPixels(\"x\");\n            cHeight = heightStyle.getPixels(\"y\");\n        }\n        viewPort.setCurrent(cWidth, cHeight);\n        if (typeof offsetX === \"number\") {\n            element.getAttribute(\"x\", true).setValue(offsetX);\n        }\n        if (typeof offsetY === \"number\") {\n            element.getAttribute(\"y\", true).setValue(offsetY);\n        }\n        if (typeof scaleWidth === \"number\" || typeof scaleHeight === \"number\") {\n            var viewBox = toNumbers(element.getAttribute(\"viewBox\").getString());\n            var xRatio = 0;\n            var yRatio = 0;\n            if (typeof scaleWidth === \"number\") {\n                var _widthStyle = element.getStyle(\"width\");\n                if (_widthStyle.hasValue()) {\n                    xRatio = _widthStyle.getPixels(\"x\") / scaleWidth;\n                } else if (!isNaN(viewBox[2])) {\n                    xRatio = viewBox[2] / scaleWidth;\n                }\n            }\n            if (typeof scaleHeight === \"number\") {\n                var _heightStyle = element.getStyle(\"height\");\n                if (_heightStyle.hasValue()) {\n                    yRatio = _heightStyle.getPixels(\"y\") / scaleHeight;\n                } else if (!isNaN(viewBox[3])) {\n                    yRatio = viewBox[3] / scaleHeight;\n                }\n            }\n            if (!xRatio) {\n                xRatio = yRatio;\n            }\n            if (!yRatio) {\n                yRatio = xRatio;\n            }\n            element.getAttribute(\"width\", true).setValue(scaleWidth);\n            element.getAttribute(\"height\", true).setValue(scaleHeight);\n            var transformStyle = element.getStyle(\"transform\", true, true);\n            transformStyle.setValue(\"\".concat(transformStyle.getString(), \" scale(\").concat(1.0 / xRatio, \", \").concat(1.0 / yRatio, \")\"));\n        } // clear and render\n        if (!ignoreClear) {\n            ctx.clearRect(0, 0, cWidth, cHeight);\n        }\n        element.render(ctx);\n        if (isFirstRender) {\n            this.isFirstRender = false;\n        }\n    }\n}\nScreen.defaultWindow = defaultWindow;\nScreen.defaultFetch = defaultFetch$1;\nvar { defaultFetch } = Screen;\nvar DefaultDOMParser = typeof DOMParser !== \"undefined\" ? DOMParser : null;\nclass Parser {\n    constructor(){\n        var { fetch: fetch1 = defaultFetch, DOMParser: DOMParser1 = DefaultDOMParser } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.fetch = fetch1;\n        this.DOMParser = DOMParser1;\n    }\n    parse(resource) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            if (resource.startsWith(\"<\")) {\n                return _this.parseFromString(resource);\n            }\n            return _this.load(resource);\n        })();\n    }\n    parseFromString(xml) {\n        var parser = new this.DOMParser();\n        try {\n            return this.checkDocument(parser.parseFromString(xml, \"image/svg+xml\"));\n        } catch (err) {\n            return this.checkDocument(parser.parseFromString(xml, \"text/xml\"));\n        }\n    }\n    checkDocument(document1) {\n        var parserError = document1.getElementsByTagName(\"parsererror\")[0];\n        if (parserError) {\n            throw new Error(parserError.textContent);\n        }\n        return document1;\n    }\n    load(url) {\n        var _this2 = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var response = yield _this2.fetch(url);\n            var xml = yield response.text();\n            return _this2.parseFromString(xml);\n        })();\n    }\n}\nclass Translate {\n    constructor(_, point){\n        this.type = \"translate\";\n        this.point = null;\n        this.point = Point.parse(point);\n    }\n    apply(ctx) {\n        var { x, y } = this.point;\n        ctx.translate(x || 0.0, y || 0.0);\n    }\n    unapply(ctx) {\n        var { x, y } = this.point;\n        ctx.translate(-1.0 * x || 0.0, -1.0 * y || 0.0);\n    }\n    applyToPoint(point) {\n        var { x, y } = this.point;\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            x || 0.0,\n            y || 0.0\n        ]);\n    }\n}\nclass Rotate {\n    constructor(document1, rotate, transformOrigin){\n        this.type = \"rotate\";\n        this.angle = null;\n        this.originX = null;\n        this.originY = null;\n        this.cx = 0;\n        this.cy = 0;\n        var numbers = toNumbers(rotate);\n        this.angle = new Property(document1, \"angle\", numbers[0]);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n        this.cx = numbers[1] || 0;\n        this.cy = numbers[2] || 0;\n    }\n    apply(ctx) {\n        var { cx, cy, originX, originY, angle } = this;\n        var tx = cx + originX.getPixels(\"x\");\n        var ty = cy + originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.rotate(angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { cx, cy, originX, originY, angle } = this;\n        var tx = cx + originX.getPixels(\"x\");\n        var ty = cy + originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.rotate(-1.0 * angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        var { cx, cy, angle } = this;\n        var rad = angle.getRadians();\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            cx || 0.0,\n            cy || 0.0 // this.p.y\n        ]);\n        point.applyTransform([\n            Math.cos(rad),\n            Math.sin(rad),\n            -Math.sin(rad),\n            Math.cos(rad),\n            0,\n            0\n        ]);\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            -cx || 0.0,\n            -cy || 0.0 // -this.p.y\n        ]);\n    }\n}\nclass Scale {\n    constructor(_, scale, transformOrigin){\n        this.type = \"scale\";\n        this.scale = null;\n        this.originX = null;\n        this.originY = null;\n        var scaleSize = Point.parseScale(scale); // Workaround for node-canvas\n        if (scaleSize.x === 0 || scaleSize.y === 0) {\n            scaleSize.x = PSEUDO_ZERO;\n            scaleSize.y = PSEUDO_ZERO;\n        }\n        this.scale = scaleSize;\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    apply(ctx) {\n        var { scale: { x, y }, originX, originY } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.scale(x, y || x);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { scale: { x, y }, originX, originY } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.scale(1.0 / x, 1.0 / y || x);\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        var { x, y } = this.scale;\n        point.applyTransform([\n            x || 0.0,\n            0,\n            0,\n            y || 0.0,\n            0,\n            0\n        ]);\n    }\n}\nclass Matrix {\n    constructor(_, matrix, transformOrigin){\n        this.type = \"matrix\";\n        this.matrix = [];\n        this.originX = null;\n        this.originY = null;\n        this.matrix = toNumbers(matrix);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    apply(ctx) {\n        var { originX, originY, matrix } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { originX, originY, matrix } = this;\n        var a = matrix[0];\n        var b = matrix[2];\n        var c = matrix[4];\n        var d = matrix[1];\n        var e = matrix[3];\n        var f = matrix[5];\n        var g = 0.0;\n        var h = 0.0;\n        var i = 1.0;\n        var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        point.applyTransform(this.matrix);\n    }\n}\nclass Skew extends Matrix {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skew\";\n        this.angle = null;\n        this.angle = new Property(document1, \"angle\", skew);\n    }\n}\nclass SkewX extends Skew {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skewX\";\n        this.matrix = [\n            1,\n            0,\n            Math.tan(this.angle.getRadians()),\n            1,\n            0,\n            0\n        ];\n    }\n}\nclass SkewY extends Skew {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skewY\";\n        this.matrix = [\n            1,\n            Math.tan(this.angle.getRadians()),\n            0,\n            1,\n            0,\n            0\n        ];\n    }\n}\nfunction parseTransforms(transform) {\n    return compressSpaces(transform).trim().replace(/\\)([a-zA-Z])/g, \") $1\").replace(/\\)(\\s?,\\s?)/g, \") \").split(/\\s(?=[a-z])/);\n}\nfunction parseTransform(transform) {\n    var [type, value] = transform.split(\"(\");\n    return [\n        type.trim(),\n        value.trim().replace(\")\", \"\")\n    ];\n}\nclass Transform {\n    constructor(document1, transform, transformOrigin){\n        this.document = document1;\n        this.transforms = [];\n        var data = parseTransforms(transform);\n        data.forEach((transform)=>{\n            if (transform === \"none\") {\n                return;\n            }\n            var [type, value] = parseTransform(transform);\n            var TransformType = Transform.transformTypes[type];\n            if (typeof TransformType !== \"undefined\") {\n                this.transforms.push(new TransformType(this.document, value, transformOrigin));\n            }\n        });\n    }\n    static fromElement(document1, element) {\n        var transformStyle = element.getStyle(\"transform\", false, true);\n        var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle(\"transform-origin\", false, true).split();\n        var transformOrigin = [\n            transformOriginXProperty,\n            transformOriginYProperty\n        ];\n        if (transformStyle.hasValue()) {\n            return new Transform(document1, transformStyle.getString(), transformOrigin);\n        }\n        return null;\n    }\n    apply(ctx) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = 0; i < len; i++){\n            transforms[i].apply(ctx);\n        }\n    }\n    unapply(ctx) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = len - 1; i >= 0; i--){\n            transforms[i].unapply(ctx);\n        }\n    }\n    applyToPoint(point) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = 0; i < len; i++){\n            transforms[i].applyToPoint(point);\n        }\n    }\n}\nTransform.transformTypes = {\n    translate: Translate,\n    rotate: Rotate,\n    scale: Scale,\n    matrix: Matrix,\n    skewX: SkewX,\n    skewY: SkewY\n};\nclass Element {\n    constructor(document1, node){\n        var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this.document = document1;\n        this.node = node;\n        this.captureTextNodes = captureTextNodes;\n        this.attributes = {};\n        this.styles = {};\n        this.stylesSpecificity = {};\n        this.animationFrozen = false;\n        this.animationFrozenValue = \"\";\n        this.parent = null;\n        this.children = [];\n        if (!node || node.nodeType !== 1) {\n            // ELEMENT_NODE\n            return;\n        } // add attributes\n        Array.from(node.attributes).forEach((attribute)=>{\n            var nodeName = normalizeAttributeName(attribute.nodeName);\n            this.attributes[nodeName] = new Property(document1, nodeName, attribute.value);\n        });\n        this.addStylesFromStyleDefinition(); // add inline styles\n        if (this.getAttribute(\"style\").hasValue()) {\n            var styles = this.getAttribute(\"style\").getString().split(\";\").map((_)=>_.trim());\n            styles.forEach((style)=>{\n                if (!style) {\n                    return;\n                }\n                var [name, value] = style.split(\":\").map((_)=>_.trim());\n                this.styles[name] = new Property(document1, name, value);\n            });\n        }\n        var { definitions } = document1;\n        var id = this.getAttribute(\"id\"); // add id\n        if (id.hasValue()) {\n            if (!definitions[id.getString()]) {\n                definitions[id.getString()] = this;\n            }\n        }\n        Array.from(node.childNodes).forEach((childNode)=>{\n            if (childNode.nodeType === 1) {\n                this.addChild(childNode); // ELEMENT_NODE\n            } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {\n                var textNode = document1.createTextNode(childNode);\n                if (textNode.getText().length > 0) {\n                    this.addChild(textNode); // TEXT_NODE\n                }\n            }\n        });\n    }\n    getAttribute(name) {\n        var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var attr = this.attributes[name];\n        if (!attr && createIfNotExists) {\n            var _attr = new Property(this.document, name, \"\");\n            this.attributes[name] = _attr;\n            return _attr;\n        }\n        return attr || Property.empty(this.document);\n    }\n    getHrefAttribute() {\n        for(var key in this.attributes){\n            if (key === \"href\" || key.endsWith(\":href\")) {\n                return this.attributes[key];\n            }\n        }\n        return Property.empty(this.document);\n    }\n    getStyle(name) {\n        var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var style = this.styles[name];\n        if (style) {\n            return style;\n        }\n        var attr = this.getAttribute(name);\n        if (attr !== null && attr !== void 0 && attr.hasValue()) {\n            this.styles[name] = attr; // move up to me to cache\n            return attr;\n        }\n        if (!skipAncestors) {\n            var { parent } = this;\n            if (parent) {\n                var parentStyle = parent.getStyle(name);\n                if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {\n                    return parentStyle;\n                }\n            }\n        }\n        if (createIfNotExists) {\n            var _style = new Property(this.document, name, \"\");\n            this.styles[name] = _style;\n            return _style;\n        }\n        return style || Property.empty(this.document);\n    }\n    render(ctx) {\n        // don't render display=none\n        // don't render visibility=hidden\n        if (this.getStyle(\"display\").getString() === \"none\" || this.getStyle(\"visibility\").getString() === \"hidden\") {\n            return;\n        }\n        ctx.save();\n        if (this.getStyle(\"mask\").hasValue()) {\n            // mask\n            var mask = this.getStyle(\"mask\").getDefinition();\n            if (mask) {\n                this.applyEffects(ctx);\n                mask.apply(ctx, this);\n            }\n        } else if (this.getStyle(\"filter\").getValue(\"none\") !== \"none\") {\n            // filter\n            var filter = this.getStyle(\"filter\").getDefinition();\n            if (filter) {\n                this.applyEffects(ctx);\n                filter.apply(ctx, this);\n            }\n        } else {\n            this.setContext(ctx);\n            this.renderChildren(ctx);\n            this.clearContext(ctx);\n        }\n        ctx.restore();\n    }\n    setContext(_) {}\n    applyEffects(ctx) {\n        // transform\n        var transform = Transform.fromElement(this.document, this);\n        if (transform) {\n            transform.apply(ctx);\n        } // clip\n        var clipPathStyleProp = this.getStyle(\"clip-path\", false, true);\n        if (clipPathStyleProp.hasValue()) {\n            var clip = clipPathStyleProp.getDefinition();\n            if (clip) {\n                clip.apply(ctx);\n            }\n        }\n    }\n    clearContext(_) {}\n    renderChildren(ctx) {\n        this.children.forEach((child)=>{\n            child.render(ctx);\n        });\n    }\n    addChild(childNode) {\n        var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);\n        child.parent = this;\n        if (!Element.ignoreChildTypes.includes(child.type)) {\n            this.children.push(child);\n        }\n    }\n    matchesSelector(selector) {\n        var _node$getAttribute;\n        var { node } = this;\n        if (typeof node.matches === \"function\") {\n            return node.matches(selector);\n        }\n        var styleClasses = (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, \"class\");\n        if (!styleClasses || styleClasses === \"\") {\n            return false;\n        }\n        return styleClasses.split(\" \").some((styleClass)=>\".\".concat(styleClass) === selector);\n    }\n    addStylesFromStyleDefinition() {\n        var { styles, stylesSpecificity } = this.document;\n        for(var selector in styles){\n            if (!selector.startsWith(\"@\") && this.matchesSelector(selector)) {\n                var style = styles[selector];\n                var specificity = stylesSpecificity[selector];\n                if (style) {\n                    for(var name in style){\n                        var existingSpecificity = this.stylesSpecificity[name];\n                        if (typeof existingSpecificity === \"undefined\") {\n                            existingSpecificity = \"000\";\n                        }\n                        if (specificity >= existingSpecificity) {\n                            this.styles[name] = style[name];\n                            this.stylesSpecificity[name] = specificity;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    removeStyles(element, ignoreStyles) {\n        var toRestore = ignoreStyles.reduce((toRestore, name)=>{\n            var styleProp = element.getStyle(name);\n            if (!styleProp.hasValue()) {\n                return toRestore;\n            }\n            var value = styleProp.getString();\n            styleProp.setValue(\"\");\n            return [\n                ...toRestore,\n                [\n                    name,\n                    value\n                ]\n            ];\n        }, []);\n        return toRestore;\n    }\n    restoreStyles(element, styles) {\n        styles.forEach((_ref)=>{\n            var [name, value] = _ref;\n            element.getStyle(name, true).setValue(value);\n        });\n    }\n    isFirstChild() {\n        var _this$parent;\n        return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;\n    }\n}\nElement.ignoreChildTypes = [\n    \"title\"\n];\nclass UnknownElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n    }\n}\nfunction wrapFontFamily(fontFamily) {\n    var trimmed = fontFamily.trim();\n    return /^('|\")/.test(trimmed) ? trimmed : '\"'.concat(trimmed, '\"');\n}\nfunction prepareFontFamily(fontFamily) {\n    return typeof process === \"undefined\" ? fontFamily : fontFamily.trim().split(\",\").map(wrapFontFamily).join(\",\");\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style\r\n * @param fontStyle\r\n * @returns CSS font style.\r\n */ function prepareFontStyle(fontStyle) {\n    if (!fontStyle) {\n        return \"\";\n    }\n    var targetFontStyle = fontStyle.trim().toLowerCase();\n    switch(targetFontStyle){\n        case \"normal\":\n        case \"italic\":\n        case \"oblique\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontStyle;\n        default:\n            if (/^oblique\\s+(-|)\\d+deg$/.test(targetFontStyle)) {\n                return targetFontStyle;\n            }\n            return \"\";\n    }\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight\r\n * @param fontWeight\r\n * @returns CSS font weight.\r\n */ function prepareFontWeight(fontWeight) {\n    if (!fontWeight) {\n        return \"\";\n    }\n    var targetFontWeight = fontWeight.trim().toLowerCase();\n    switch(targetFontWeight){\n        case \"normal\":\n        case \"bold\":\n        case \"lighter\":\n        case \"bolder\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontWeight;\n        default:\n            if (/^[\\d.]+$/.test(targetFontWeight)) {\n                return targetFontWeight;\n            }\n            return \"\";\n    }\n}\nclass Font {\n    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit){\n        var inheritFont = inherit ? typeof inherit === \"string\" ? Font.parse(inherit) : inherit : {};\n        this.fontFamily = fontFamily || inheritFont.fontFamily;\n        this.fontSize = fontSize || inheritFont.fontSize;\n        this.fontStyle = fontStyle || inheritFont.fontStyle;\n        this.fontWeight = fontWeight || inheritFont.fontWeight;\n        this.fontVariant = fontVariant || inheritFont.fontVariant;\n    }\n    static parse() {\n        var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n        var inherit = arguments.length > 1 ? arguments[1] : undefined;\n        var fontStyle = \"\";\n        var fontVariant = \"\";\n        var fontWeight = \"\";\n        var fontSize = \"\";\n        var fontFamily = \"\";\n        var parts = compressSpaces(font).trim().split(\" \");\n        var set = {\n            fontSize: false,\n            fontStyle: false,\n            fontWeight: false,\n            fontVariant: false\n        };\n        parts.forEach((part)=>{\n            switch(true){\n                case !set.fontStyle && Font.styles.includes(part):\n                    if (part !== \"inherit\") {\n                        fontStyle = part;\n                    }\n                    set.fontStyle = true;\n                    break;\n                case !set.fontVariant && Font.variants.includes(part):\n                    if (part !== \"inherit\") {\n                        fontVariant = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    break;\n                case !set.fontWeight && Font.weights.includes(part):\n                    if (part !== \"inherit\") {\n                        fontWeight = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    break;\n                case !set.fontSize:\n                    if (part !== \"inherit\") {\n                        [fontSize] = part.split(\"/\");\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    set.fontSize = true;\n                    break;\n                default:\n                    if (part !== \"inherit\") {\n                        fontFamily += part;\n                    }\n            }\n        });\n        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);\n    }\n    toString() {\n        return [\n            prepareFontStyle(this.fontStyle),\n            this.fontVariant,\n            prepareFontWeight(this.fontWeight),\n            this.fontSize,\n            prepareFontFamily(this.fontFamily)\n        ].join(\" \").trim();\n    }\n}\nFont.styles = \"normal|italic|oblique|inherit\";\nFont.variants = \"normal|small-caps|inherit\";\nFont.weights = \"normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit\";\nclass BoundingBox {\n    constructor(){\n        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;\n        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;\n        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;\n        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    get x() {\n        return this.x1;\n    }\n    get y() {\n        return this.y1;\n    }\n    get width() {\n        return this.x2 - this.x1;\n    }\n    get height() {\n        return this.y2 - this.y1;\n    }\n    addPoint(x, y) {\n        if (typeof x !== \"undefined\") {\n            if (isNaN(this.x1) || isNaN(this.x2)) {\n                this.x1 = x;\n                this.x2 = x;\n            }\n            if (x < this.x1) {\n                this.x1 = x;\n            }\n            if (x > this.x2) {\n                this.x2 = x;\n            }\n        }\n        if (typeof y !== \"undefined\") {\n            if (isNaN(this.y1) || isNaN(this.y2)) {\n                this.y1 = y;\n                this.y2 = y;\n            }\n            if (y < this.y1) {\n                this.y1 = y;\n            }\n            if (y > this.y2) {\n                this.y2 = y;\n            }\n        }\n    }\n    addX(x) {\n        this.addPoint(x, null);\n    }\n    addY(y) {\n        this.addPoint(null, y);\n    }\n    addBoundingBox(boundingBox) {\n        if (!boundingBox) {\n            return;\n        }\n        var { x1, y1, x2, y2 } = boundingBox;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    sumCubic(t, p0, p1, p2, p3) {\n        return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n    }\n    bezierCurveAdd(forX, p0, p1, p2, p3) {\n        var b = 6 * p0 - 12 * p1 + 6 * p2;\n        var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n        var c = 3 * p1 - 3 * p0;\n        if (a === 0) {\n            if (b === 0) {\n                return;\n            }\n            var t = -c / b;\n            if (0 < t && t < 1) {\n                if (forX) {\n                    this.addX(this.sumCubic(t, p0, p1, p2, p3));\n                } else {\n                    this.addY(this.sumCubic(t, p0, p1, p2, p3));\n                }\n            }\n            return;\n        }\n        var b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) {\n            return;\n        }\n        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t1, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t1, p0, p1, p2, p3));\n            }\n        }\n        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t2, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t2, p0, p1, p2, p3));\n            }\n        }\n    }\n    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n        this.addPoint(p0x, p0y);\n        this.addPoint(p3x, p3y);\n        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);\n        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);\n    }\n    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {\n        var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)\n        var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)\n        var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)\n        var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)\n        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n    }\n    isPointInBox(x, y) {\n        var { x1, y1, x2, y2 } = this;\n        return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n    }\n}\nclass PathParser extends svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData {\n    constructor(path){\n        super(path // Fix spaces after signs.\n        .replace(/([+\\-.])\\s+/gm, \"$1\") // Remove invalid part.\n        .replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, \"\"));\n        this.control = null;\n        this.start = null;\n        this.current = null;\n        this.command = null;\n        this.commands = this.commands;\n        this.i = -1;\n        this.previousCommand = null;\n        this.points = [];\n        this.angles = [];\n    }\n    reset() {\n        this.i = -1;\n        this.command = null;\n        this.previousCommand = null;\n        this.start = new Point(0, 0);\n        this.control = new Point(0, 0);\n        this.current = new Point(0, 0);\n        this.points = [];\n        this.angles = [];\n    }\n    isEnd() {\n        var { i, commands } = this;\n        return i >= commands.length - 1;\n    }\n    next() {\n        var command = this.commands[++this.i];\n        this.previousCommand = this.command;\n        this.command = command;\n        return command;\n    }\n    getPoint() {\n        var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"x\";\n        var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"y\";\n        var point = new Point(this.command[xProp], this.command[yProp]);\n        return this.makeAbsolute(point);\n    }\n    getAsControlPoint(xProp, yProp) {\n        var point = this.getPoint(xProp, yProp);\n        this.control = point;\n        return point;\n    }\n    getAsCurrentPoint(xProp, yProp) {\n        var point = this.getPoint(xProp, yProp);\n        this.current = point;\n        return point;\n    }\n    getReflectedControlPoint() {\n        var previousCommand = this.previousCommand.type;\n        if (previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.QUAD_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.SMOOTH_QUAD_TO) {\n            return this.current;\n        } // reflect point\n        var { current: { x: cx, y: cy }, control: { x: ox, y: oy } } = this;\n        var point = new Point(2 * cx - ox, 2 * cy - oy);\n        return point;\n    }\n    makeAbsolute(point) {\n        if (this.command.relative) {\n            var { x, y } = this.current;\n            point.x += x;\n            point.y += y;\n        }\n        return point;\n    }\n    addMarker(point, from, priorTo) {\n        var { points, angles } = this; // if the last angle isn't filled in because we didn't have this point yet ...\n        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {\n            angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);\n        }\n        this.addMarkerAngle(point, from ? from.angleTo(point) : null);\n    }\n    addMarkerAngle(point, angle) {\n        this.points.push(point);\n        this.angles.push(angle);\n    }\n    getMarkerPoints() {\n        return this.points;\n    }\n    getMarkerAngles() {\n        var { angles } = this;\n        var len = angles.length;\n        for(var i = 0; i < len; i++){\n            if (!angles[i]) {\n                for(var j = i + 1; j < len; j++){\n                    if (angles[j]) {\n                        angles[i] = angles[j];\n                        break;\n                    }\n                }\n            }\n        }\n        return angles;\n    }\n}\nclass RenderedElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.modifiedEmSizeStack = false;\n    }\n    calculateOpacity() {\n        var opacity = 1.0; // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        var element = this;\n        while(element){\n            var opacityStyle = element.getStyle(\"opacity\", false, true); // no ancestors on style call\n            if (opacityStyle.hasValue(true)) {\n                opacity *= opacityStyle.getNumber();\n            }\n            element = element.parent;\n        }\n        return opacity;\n    }\n    setContext(ctx) {\n        var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!fromMeasure) {\n            // causes stack overflow when measuring text with gradients\n            // fill\n            var fillStyleProp = this.getStyle(\"fill\");\n            var fillOpacityStyleProp = this.getStyle(\"fill-opacity\");\n            var strokeStyleProp = this.getStyle(\"stroke\");\n            var strokeOpacityProp = this.getStyle(\"stroke-opacity\");\n            if (fillStyleProp.isUrlDefinition()) {\n                var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);\n                if (fillStyle) {\n                    ctx.fillStyle = fillStyle;\n                }\n            } else if (fillStyleProp.hasValue()) {\n                if (fillStyleProp.getString() === \"currentColor\") {\n                    fillStyleProp.setValue(this.getStyle(\"color\").getColor());\n                }\n                var _fillStyle = fillStyleProp.getColor();\n                if (_fillStyle !== \"inherit\") {\n                    ctx.fillStyle = _fillStyle === \"none\" ? \"rgba(0,0,0,0)\" : _fillStyle;\n                }\n            }\n            if (fillOpacityStyleProp.hasValue()) {\n                var _fillStyle2 = new Property(this.document, \"fill\", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();\n                ctx.fillStyle = _fillStyle2;\n            } // stroke\n            if (strokeStyleProp.isUrlDefinition()) {\n                var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);\n                if (strokeStyle) {\n                    ctx.strokeStyle = strokeStyle;\n                }\n            } else if (strokeStyleProp.hasValue()) {\n                if (strokeStyleProp.getString() === \"currentColor\") {\n                    strokeStyleProp.setValue(this.getStyle(\"color\").getColor());\n                }\n                var _strokeStyle = strokeStyleProp.getString();\n                if (_strokeStyle !== \"inherit\") {\n                    ctx.strokeStyle = _strokeStyle === \"none\" ? \"rgba(0,0,0,0)\" : _strokeStyle;\n                }\n            }\n            if (strokeOpacityProp.hasValue()) {\n                var _strokeStyle2 = new Property(this.document, \"stroke\", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();\n                ctx.strokeStyle = _strokeStyle2;\n            }\n            var strokeWidthStyleProp = this.getStyle(\"stroke-width\");\n            if (strokeWidthStyleProp.hasValue()) {\n                var newLineWidth = strokeWidthStyleProp.getPixels();\n                ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)\n                 : newLineWidth;\n            }\n            var strokeLinecapStyleProp = this.getStyle(\"stroke-linecap\");\n            var strokeLinejoinStyleProp = this.getStyle(\"stroke-linejoin\");\n            var strokeMiterlimitProp = this.getStyle(\"stroke-miterlimit\"); // NEED TEST\n            // const pointOrderStyleProp = this.getStyle('paint-order');\n            var strokeDasharrayStyleProp = this.getStyle(\"stroke-dasharray\");\n            var strokeDashoffsetProp = this.getStyle(\"stroke-dashoffset\");\n            if (strokeLinecapStyleProp.hasValue()) {\n                ctx.lineCap = strokeLinecapStyleProp.getString();\n            }\n            if (strokeLinejoinStyleProp.hasValue()) {\n                ctx.lineJoin = strokeLinejoinStyleProp.getString();\n            }\n            if (strokeMiterlimitProp.hasValue()) {\n                ctx.miterLimit = strokeMiterlimitProp.getNumber();\n            } // NEED TEST\n            // if (pointOrderStyleProp.hasValue()) {\n            // \t// ?\n            // \tctx.paintOrder = pointOrderStyleProp.getValue();\n            // }\n            if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== \"none\") {\n                var gaps = toNumbers(strokeDasharrayStyleProp.getString());\n                if (typeof ctx.setLineDash !== \"undefined\") {\n                    ctx.setLineDash(gaps);\n                } else if (typeof ctx.webkitLineDash !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDash = gaps;\n                } else if (typeof ctx.mozDash !== \"undefined\" && !(gaps.length === 1 && gaps[0] === 0)) {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDash = gaps;\n                }\n                var offset = strokeDashoffsetProp.getPixels();\n                if (typeof ctx.lineDashOffset !== \"undefined\") {\n                    ctx.lineDashOffset = offset;\n                } else if (typeof ctx.webkitLineDashOffset !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDashOffset = offset;\n                } else if (typeof ctx.mozDashOffset !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDashOffset = offset;\n                }\n            }\n        } // font\n        this.modifiedEmSizeStack = false;\n        if (typeof ctx.font !== \"undefined\") {\n            var fontStyleProp = this.getStyle(\"font\");\n            var fontStyleStyleProp = this.getStyle(\"font-style\");\n            var fontVariantStyleProp = this.getStyle(\"font-variant\");\n            var fontWeightStyleProp = this.getStyle(\"font-weight\");\n            var fontSizeStyleProp = this.getStyle(\"font-size\");\n            var fontFamilyStyleProp = this.getStyle(\"font-family\");\n            var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? \"\".concat(fontSizeStyleProp.getPixels(true), \"px\") : \"\", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));\n            fontStyleStyleProp.setValue(font.fontStyle);\n            fontVariantStyleProp.setValue(font.fontVariant);\n            fontWeightStyleProp.setValue(font.fontWeight);\n            fontSizeStyleProp.setValue(font.fontSize);\n            fontFamilyStyleProp.setValue(font.fontFamily);\n            ctx.font = font.toString();\n            if (fontSizeStyleProp.isPixels()) {\n                this.document.emSize = fontSizeStyleProp.getPixels();\n                this.modifiedEmSizeStack = true;\n            }\n        }\n        if (!fromMeasure) {\n            // effects\n            this.applyEffects(ctx); // opacity\n            ctx.globalAlpha = this.calculateOpacity();\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        if (this.modifiedEmSizeStack) {\n            this.document.popEmSize();\n        }\n    }\n}\nclass PathElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"path\";\n        this.pathParser = null;\n        this.pathParser = new PathParser(this.getAttribute(\"d\").getString());\n    }\n    path(ctx) {\n        var { pathParser } = this;\n        var boundingBox = new BoundingBox();\n        pathParser.reset();\n        if (ctx) {\n            ctx.beginPath();\n        }\n        while(!pathParser.isEnd()){\n            switch(pathParser.next().type){\n                case PathParser.MOVE_TO:\n                    this.pathM(ctx, boundingBox);\n                    break;\n                case PathParser.LINE_TO:\n                    this.pathL(ctx, boundingBox);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    this.pathH(ctx, boundingBox);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    this.pathV(ctx, boundingBox);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    this.pathS(ctx, boundingBox);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    this.pathT(ctx, boundingBox);\n                    break;\n                case PathParser.ARC:\n                    this.pathA(ctx, boundingBox);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    this.pathZ(ctx, boundingBox);\n                    break;\n            }\n        }\n        return boundingBox;\n    }\n    getBoundingBox(_) {\n        return this.path();\n    }\n    getMarkers() {\n        var { pathParser } = this;\n        var points = pathParser.getMarkerPoints();\n        var angles = pathParser.getMarkerAngles();\n        var markers = points.map((point, i)=>[\n                point,\n                angles[i]\n            ]);\n        return markers;\n    }\n    renderChildren(ctx) {\n        this.path(ctx);\n        this.document.screen.mouse.checkPath(this, ctx);\n        var fillRuleStyleProp = this.getStyle(\"fill-rule\");\n        if (ctx.fillStyle !== \"\") {\n            if (fillRuleStyleProp.getString(\"inherit\") !== \"inherit\") {\n                ctx.fill(fillRuleStyleProp.getString());\n            } else {\n                ctx.fill();\n            }\n        }\n        if (ctx.strokeStyle !== \"\") {\n            if (this.getAttribute(\"vector-effect\").getString() === \"non-scaling-stroke\") {\n                ctx.save();\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.stroke();\n                ctx.restore();\n            } else {\n                ctx.stroke();\n            }\n        }\n        var markers = this.getMarkers();\n        if (markers) {\n            var markersLastIndex = markers.length - 1;\n            var markerStartStyleProp = this.getStyle(\"marker-start\");\n            var markerMidStyleProp = this.getStyle(\"marker-mid\");\n            var markerEndStyleProp = this.getStyle(\"marker-end\");\n            if (markerStartStyleProp.isUrlDefinition()) {\n                var marker = markerStartStyleProp.getDefinition();\n                var [point, angle] = markers[0];\n                marker.render(ctx, point, angle);\n            }\n            if (markerMidStyleProp.isUrlDefinition()) {\n                var _marker = markerMidStyleProp.getDefinition();\n                for(var i = 1; i < markersLastIndex; i++){\n                    var [_point, _angle] = markers[i];\n                    _marker.render(ctx, _point, _angle);\n                }\n            }\n            if (markerEndStyleProp.isUrlDefinition()) {\n                var _marker2 = markerEndStyleProp.getDefinition();\n                var [_point2, _angle2] = markers[markersLastIndex];\n                _marker2.render(ctx, _point2, _angle2);\n            }\n        }\n    }\n    static pathM(pathParser) {\n        var point = pathParser.getAsCurrentPoint();\n        pathParser.start = pathParser.current;\n        return {\n            point\n        };\n    }\n    pathM(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { point } = PathElement.pathM(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.moveTo(x, y);\n        }\n    }\n    static pathL(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point\n        };\n    }\n    pathL(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathL(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathH(pathParser) {\n        var { current, command } = pathParser;\n        var point = new Point((command.relative ? current.x : 0) + command.x, current.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathH(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathH(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathV(pathParser) {\n        var { current, command } = pathParser;\n        var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathV(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathV(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathC(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getPoint(\"x1\", \"y1\");\n        var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathC(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point, controlPoint, currentPoint } = PathElement.pathC(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathS(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getReflectedControlPoint();\n        var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathS(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point, controlPoint, currentPoint } = PathElement.pathS(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathQ(pathParser) {\n        var { current } = pathParser;\n        var controlPoint = pathParser.getAsControlPoint(\"x1\", \"y1\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathQ(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, controlPoint, currentPoint } = PathElement.pathQ(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathT(pathParser) {\n        var { current } = pathParser;\n        var controlPoint = pathParser.getReflectedControlPoint();\n        pathParser.control = controlPoint;\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathT(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, controlPoint, currentPoint } = PathElement.pathT(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathA(pathParser) {\n        var { current, command } = pathParser;\n        var { rX, rY, xRot, lArcFlag, sweepFlag } = command;\n        var xAxisRotation = xRot * (Math.PI / 180.0);\n        var currentPoint = pathParser.getAsCurrentPoint(); // Conversion from endpoint to center parameterization\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        // x1', y1'\n        var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2.0, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2.0); // adjust radii\n        var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);\n        if (l > 1) {\n            rX *= Math.sqrt(l);\n            rY *= Math.sqrt(l);\n        } // cx', cy'\n        var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));\n        if (isNaN(s)) {\n            s = 0;\n        }\n        var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX); // cx, cy\n        var centp = new Point((current.x + currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y); // initial angle\n        var a1 = vectorsAngle([\n            1,\n            0\n        ], [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ]); // θ1\n        // angle delta\n        var u = [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ];\n        var v = [\n            (-currp.x - cpp.x) / rX,\n            (-currp.y - cpp.y) / rY\n        ];\n        var ad = vectorsAngle(u, v); // Δθ\n        if (vectorsRatio(u, v) <= -1) {\n            ad = Math.PI;\n        }\n        if (vectorsRatio(u, v) >= 1) {\n            ad = 0;\n        }\n        return {\n            currentPoint,\n            rX,\n            rY,\n            sweepFlag,\n            xAxisRotation,\n            centp,\n            a1,\n            ad\n        };\n    }\n    pathA(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { currentPoint, rX, rY, sweepFlag, xAxisRotation, centp, a1, ad } = PathElement.pathA(pathParser); // for markers\n        var dir = 1 - sweepFlag ? 1.0 : -1.0;\n        var ah = a1 + dir * (ad / 2.0);\n        var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));\n        pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n        pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);\n        boundingBox.addPoint(currentPoint.x, currentPoint.y); // TODO: this is too naive, make it better\n        if (ctx && !isNaN(a1) && !isNaN(ad)) {\n            var r = rX > rY ? rX : rY;\n            var sx = rX > rY ? 1 : rX / rY;\n            var sy = rX > rY ? rY / rX : 1;\n            ctx.translate(centp.x, centp.y);\n            ctx.rotate(xAxisRotation);\n            ctx.scale(sx, sy);\n            ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));\n            ctx.scale(1 / sx, 1 / sy);\n            ctx.rotate(-xAxisRotation);\n            ctx.translate(-centp.x, -centp.y);\n        }\n    }\n    static pathZ(pathParser) {\n        pathParser.current = pathParser.start;\n    }\n    pathZ(ctx, boundingBox) {\n        PathElement.pathZ(this.pathParser);\n        if (ctx) {\n            // only close path if it is not a straight line\n            if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {\n                ctx.closePath();\n            }\n        }\n    }\n}\nclass GlyphElement extends PathElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"glyph\";\n        this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n        this.unicode = this.getAttribute(\"unicode\").getString();\n        this.arabicForm = this.getAttribute(\"arabic-form\").getString();\n    }\n}\nclass TextElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, new.target === TextElement ? true : captureTextNodes);\n        this.type = \"text\";\n        this.x = 0;\n        this.y = 0;\n        this.measureCache = -1;\n    }\n    setContext(ctx) {\n        var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        super.setContext(ctx, fromMeasure);\n        var textBaseline = this.getStyle(\"dominant-baseline\").getTextBaseline() || this.getStyle(\"alignment-baseline\").getTextBaseline();\n        if (textBaseline) {\n            ctx.textBaseline = textBaseline;\n        }\n    }\n    initializeCoordinates() {\n        this.x = 0;\n        this.y = 0;\n        this.leafTexts = [];\n        this.textChunkStart = 0;\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n    }\n    getBoundingBox(ctx) {\n        if (this.type !== \"text\") {\n            return this.getTElementBoundingBox(ctx);\n        } // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx);\n        var boundingBox = null; // then calculate bounding box\n        this.children.forEach((_, i)=>{\n            var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);\n            if (!boundingBox) {\n                boundingBox = childBoundingBox;\n            } else {\n                boundingBox.addBoundingBox(childBoundingBox);\n            }\n        });\n        return boundingBox;\n    }\n    getFontSize() {\n        var { document: document1, parent } = this;\n        var inheritFontSize = Font.parse(document1.ctx.font).fontSize;\n        var fontSize = parent.getStyle(\"font-size\").getNumber(inheritFontSize);\n        return fontSize;\n    }\n    getTElementBoundingBox(ctx) {\n        var fontSize = this.getFontSize();\n        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);\n    }\n    getGlyph(font, text, i) {\n        var char = text[i];\n        var glyph = null;\n        if (font.isArabic) {\n            var len = text.length;\n            var prevChar = text[i - 1];\n            var nextChar = text[i + 1];\n            var arabicForm = \"isolated\";\n            if ((i === 0 || prevChar === \" \") && i < len - 1 && nextChar !== \" \") {\n                arabicForm = \"terminal\";\n            }\n            if (i > 0 && prevChar !== \" \" && i < len - 1 && nextChar !== \" \") {\n                arabicForm = \"medial\";\n            }\n            if (i > 0 && prevChar !== \" \" && (i === len - 1 || nextChar === \" \")) {\n                arabicForm = \"initial\";\n            }\n            if (typeof font.glyphs[char] !== \"undefined\") {\n                // NEED TEST\n                var maybeGlyph = font.glyphs[char];\n                glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];\n            }\n        } else {\n            glyph = font.glyphs[char];\n        }\n        if (!glyph) {\n            glyph = font.missingGlyph;\n        }\n        return glyph;\n    }\n    getText() {\n        return \"\";\n    }\n    getTextFromNode(node) {\n        var textNode = node || this.node;\n        var childNodes = Array.from(textNode.parentNode.childNodes);\n        var index = childNodes.indexOf(textNode);\n        var lastIndex = childNodes.length - 1;\n        var text = compressSpaces(// || textNode.text\n        textNode.textContent || \"\");\n        if (index === 0) {\n            text = trimLeft(text);\n        }\n        if (index === lastIndex) {\n            text = trimRight(text);\n        }\n        return text;\n    }\n    renderChildren(ctx) {\n        if (this.type !== \"text\") {\n            this.renderTElementChildren(ctx);\n            return;\n        } // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx); // then render\n        this.children.forEach((_, i)=>{\n            this.renderChild(ctx, this, this, i);\n        });\n        var { mouse } = this.document.screen; // Do not calc bounding box if mouse is not working.\n        if (mouse.isWorking()) {\n            mouse.checkBoundingBox(this, this.getBoundingBox(ctx));\n        }\n    }\n    renderTElementChildren(ctx) {\n        var { document: document1, parent } = this;\n        var renderText = this.getText();\n        var customFont = parent.getStyle(\"font-family\").getDefinition();\n        if (customFont) {\n            var { unitsPerEm } = customFont.fontFace;\n            var ctxFont = Font.parse(document1.ctx.font);\n            var fontSize = parent.getStyle(\"font-size\").getNumber(ctxFont.fontSize);\n            var fontStyle = parent.getStyle(\"font-style\").getString(ctxFont.fontStyle);\n            var scale = fontSize / unitsPerEm;\n            var text = customFont.isRTL ? renderText.split(\"\").reverse().join(\"\") : renderText;\n            var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n            var len = text.length;\n            for(var i = 0; i < len; i++){\n                var glyph = this.getGlyph(customFont, text, i);\n                ctx.translate(this.x, this.y);\n                ctx.scale(scale, -scale);\n                var lw = ctx.lineWidth;\n                ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;\n                if (fontStyle === \"italic\") {\n                    ctx.transform(1, 0, .4, 1, 0, 0);\n                }\n                glyph.render(ctx);\n                if (fontStyle === \"italic\") {\n                    ctx.transform(1, 0, -.4, 1, 0, 0);\n                }\n                ctx.lineWidth = lw;\n                ctx.scale(1 / scale, -1 / scale);\n                ctx.translate(-this.x, -this.y);\n                this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;\n                if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                    this.x += dx[i];\n                }\n            }\n            return;\n        }\n        var { x, y } = this; // NEED TEST\n        // if (ctx.paintOrder === 'stroke') {\n        // \tif (ctx.strokeStyle) {\n        // \t\tctx.strokeText(renderText, x, y);\n        // \t}\n        // \tif (ctx.fillStyle) {\n        // \t\tctx.fillText(renderText, x, y);\n        // \t}\n        // } else {\n        if (ctx.fillStyle) {\n            ctx.fillText(renderText, x, y);\n        }\n        if (ctx.strokeStyle) {\n            ctx.strokeText(renderText, x, y);\n        } // }\n    }\n    applyAnchoring() {\n        if (this.textChunkStart >= this.leafTexts.length) {\n            return;\n        } // This is basically the \"Apply anchoring\" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.\n        // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.\n        // Vertical text is not supported.\n        var firstElement = this.leafTexts[this.textChunkStart];\n        var textAnchor = firstElement.getStyle(\"text-anchor\").getString(\"start\");\n        var isRTL = false; // we treat RTL like LTR\n        var shift = 0;\n        if (textAnchor === \"start\" && !isRTL || textAnchor === \"end\" && isRTL) {\n            shift = firstElement.x - this.minX;\n        } else if (textAnchor === \"end\" && !isRTL || textAnchor === \"start\" && isRTL) {\n            shift = firstElement.x - this.maxX;\n        } else {\n            shift = firstElement.x - (this.minX + this.maxX) / 2;\n        }\n        for(var i = this.textChunkStart; i < this.leafTexts.length; i++){\n            this.leafTexts[i].x += shift;\n        } // start new chunk\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n        this.textChunkStart = this.leafTexts.length;\n    }\n    adjustChildCoordinatesRecursive(ctx) {\n        this.children.forEach((_, i)=>{\n            this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);\n        });\n        this.applyAnchoring();\n    }\n    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        if (child.children.length > 0) {\n            child.children.forEach((_, i)=>{\n                textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);\n            });\n        } else {\n            // only leafs are relevant\n            this.adjustChildCoordinates(ctx, textParent, parent, i);\n        }\n    }\n    adjustChildCoordinates(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        if (typeof child.measureText !== \"function\") {\n            return child;\n        }\n        ctx.save();\n        child.setContext(ctx, true);\n        var xAttr = child.getAttribute(\"x\");\n        var yAttr = child.getAttribute(\"y\");\n        var dxAttr = child.getAttribute(\"dx\");\n        var dyAttr = child.getAttribute(\"dy\");\n        var customFont = child.getStyle(\"font-family\").getDefinition();\n        var isRTL = Boolean(customFont) && customFont.isRTL;\n        if (i === 0) {\n            // First children inherit attributes from parent(s). Positional attributes\n            // are only inherited from a parent to it's first child.\n            if (!xAttr.hasValue()) {\n                xAttr.setValue(child.getInheritedAttribute(\"x\"));\n            }\n            if (!yAttr.hasValue()) {\n                yAttr.setValue(child.getInheritedAttribute(\"y\"));\n            }\n            if (!dxAttr.hasValue()) {\n                dxAttr.setValue(child.getInheritedAttribute(\"dx\"));\n            }\n            if (!dyAttr.hasValue()) {\n                dyAttr.setValue(child.getInheritedAttribute(\"dy\"));\n            }\n        }\n        var width = child.measureText(ctx);\n        if (isRTL) {\n            textParent.x -= width;\n        }\n        if (xAttr.hasValue()) {\n            // an \"x\" attribute marks the start of a new chunk\n            textParent.applyAnchoring();\n            child.x = xAttr.getPixels(\"x\");\n            if (dxAttr.hasValue()) {\n                child.x += dxAttr.getPixels(\"x\");\n            }\n        } else {\n            if (dxAttr.hasValue()) {\n                textParent.x += dxAttr.getPixels(\"x\");\n            }\n            child.x = textParent.x;\n        }\n        textParent.x = child.x;\n        if (!isRTL) {\n            textParent.x += width;\n        }\n        if (yAttr.hasValue()) {\n            child.y = yAttr.getPixels(\"y\");\n            if (dyAttr.hasValue()) {\n                child.y += dyAttr.getPixels(\"y\");\n            }\n        } else {\n            if (dyAttr.hasValue()) {\n                textParent.y += dyAttr.getPixels(\"y\");\n            }\n            child.y = textParent.y;\n        }\n        textParent.y = child.y; // update the current chunk and it's bounds\n        textParent.leafTexts.push(child);\n        textParent.minX = Math.min(textParent.minX, child.x, child.x + width);\n        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);\n        child.clearContext(ctx);\n        ctx.restore();\n        return child;\n    }\n    getChildBoundingBox(ctx, textParent, parent, i) {\n        var child = parent.children[i]; // not a text node?\n        if (typeof child.getBoundingBox !== \"function\") {\n            return null;\n        }\n        var boundingBox = child.getBoundingBox(ctx);\n        if (!boundingBox) {\n            return null;\n        }\n        child.children.forEach((_, i)=>{\n            var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);\n            boundingBox.addBoundingBox(childBoundingBox);\n        });\n        return boundingBox;\n    }\n    renderChild(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        child.render(ctx);\n        child.children.forEach((_, i)=>{\n            textParent.renderChild(ctx, textParent, child, i);\n        });\n    }\n    measureText(ctx) {\n        var { measureCache } = this;\n        if (~measureCache) {\n            return measureCache;\n        }\n        var renderText = this.getText();\n        var measure = this.measureTargetText(ctx, renderText);\n        this.measureCache = measure;\n        return measure;\n    }\n    measureTargetText(ctx, targetText) {\n        if (!targetText.length) {\n            return 0;\n        }\n        var { parent } = this;\n        var customFont = parent.getStyle(\"font-family\").getDefinition();\n        if (customFont) {\n            var fontSize = this.getFontSize();\n            var text = customFont.isRTL ? targetText.split(\"\").reverse().join(\"\") : targetText;\n            var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n            var len = text.length;\n            var _measure = 0;\n            for(var i = 0; i < len; i++){\n                var glyph = this.getGlyph(customFont, text, i);\n                _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n                if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                    _measure += dx[i];\n                }\n            }\n            return _measure;\n        }\n        if (!ctx.measureText) {\n            return targetText.length * 10;\n        }\n        ctx.save();\n        this.setContext(ctx, true);\n        var { width: measure } = ctx.measureText(targetText);\n        this.clearContext(ctx);\n        ctx.restore();\n        return measure;\n    }\n    /**\r\n   * Inherits positional attributes from {@link TextElement} parent(s). Attributes\r\n   * are only inherited from a parent to its first child.\r\n   * @param name - The attribute name.\r\n   * @returns The attribute value or null.\r\n   */ getInheritedAttribute(name) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n        var current = this;\n        while(current instanceof TextElement && current.isFirstChild()){\n            var parentAttr = current.parent.getAttribute(name);\n            if (parentAttr.hasValue(true)) {\n                return parentAttr.getValue(\"0\");\n            }\n            current = current.parent;\n        }\n        return null;\n    }\n}\nclass TSpanElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, new.target === TSpanElement ? true : captureTextNodes);\n        this.type = \"tspan\"; // if this node has children, then they own the text\n        this.text = this.children.length > 0 ? \"\" : this.getTextFromNode();\n    }\n    getText() {\n        return this.text;\n    }\n}\nclass TextNode extends TSpanElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"textNode\";\n    }\n}\nclass SVGElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"svg\";\n        this.root = false;\n    }\n    setContext(ctx) {\n        var _this$node$parentNode;\n        var { document: document1 } = this;\n        var { screen, window: window1 } = document1;\n        var canvas = ctx.canvas;\n        screen.setDefaults(ctx);\n        if (canvas.style && typeof ctx.font !== \"undefined\" && window1 && typeof window1.getComputedStyle !== \"undefined\") {\n            ctx.font = window1.getComputedStyle(canvas).getPropertyValue(\"font\");\n            var fontSizeProp = new Property(document1, \"fontSize\", Font.parse(ctx.font).fontSize);\n            if (fontSizeProp.hasValue()) {\n                document1.rootEmSize = fontSizeProp.getPixels(\"y\");\n                document1.emSize = document1.rootEmSize;\n            }\n        } // create new view port\n        if (!this.getAttribute(\"x\").hasValue()) {\n            this.getAttribute(\"x\", true).setValue(0);\n        }\n        if (!this.getAttribute(\"y\").hasValue()) {\n            this.getAttribute(\"y\", true).setValue(0);\n        }\n        var { width, height } = screen.viewPort;\n        if (!this.getStyle(\"width\").hasValue()) {\n            this.getStyle(\"width\", true).setValue(\"100%\");\n        }\n        if (!this.getStyle(\"height\").hasValue()) {\n            this.getStyle(\"height\", true).setValue(\"100%\");\n        }\n        if (!this.getStyle(\"color\").hasValue()) {\n            this.getStyle(\"color\", true).setValue(\"black\");\n        }\n        var refXAttr = this.getAttribute(\"refX\");\n        var refYAttr = this.getAttribute(\"refY\");\n        var viewBoxAttr = this.getAttribute(\"viewBox\");\n        var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;\n        var clip = !this.root && this.getStyle(\"overflow\").getValue(\"hidden\") !== \"visible\";\n        var minX = 0;\n        var minY = 0;\n        var clipX = 0;\n        var clipY = 0;\n        if (viewBox) {\n            minX = viewBox[0];\n            minY = viewBox[1];\n        }\n        if (!this.root) {\n            width = this.getStyle(\"width\").getPixels(\"x\");\n            height = this.getStyle(\"height\").getPixels(\"y\");\n            if (this.type === \"marker\") {\n                clipX = minX;\n                clipY = minY;\n                minX = 0;\n                minY = 0;\n            }\n        }\n        screen.viewPort.setCurrent(width, height); // Default value of transform-origin is center only for root SVG elements\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin\n        if (this.node // is not temporary SVGElement\n         && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === \"foreignObject\") && this.getStyle(\"transform\", false, true).hasValue() && !this.getStyle(\"transform-origin\", false, true).hasValue()) {\n            this.getStyle(\"transform-origin\", true, true).setValue(\"50% 50%\");\n        }\n        super.setContext(ctx);\n        ctx.translate(this.getAttribute(\"x\").getPixels(\"x\"), this.getAttribute(\"y\").getPixels(\"y\"));\n        if (viewBox) {\n            width = viewBox[2];\n            height = viewBox[3];\n        }\n        document1.setViewBox({\n            ctx,\n            aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n            width: screen.viewPort.width,\n            desiredWidth: width,\n            height: screen.viewPort.height,\n            desiredHeight: height,\n            minX,\n            minY,\n            refX: refXAttr.getValue(),\n            refY: refYAttr.getValue(),\n            clip,\n            clipX,\n            clipY\n        });\n        if (viewBox) {\n            screen.viewPort.removeCurrent();\n            screen.viewPort.setCurrent(width, height);\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        this.document.screen.viewPort.removeCurrent();\n    }\n    /**\r\n   * Resize SVG to fit in given size.\r\n   * @param width\r\n   * @param height\r\n   * @param preserveAspectRatio\r\n   */ resize(width) {\n        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var widthAttr = this.getAttribute(\"width\", true);\n        var heightAttr = this.getAttribute(\"height\", true);\n        var viewBoxAttr = this.getAttribute(\"viewBox\");\n        var styleAttr = this.getAttribute(\"style\");\n        var originWidth = widthAttr.getNumber(0);\n        var originHeight = heightAttr.getNumber(0);\n        if (preserveAspectRatio) {\n            if (typeof preserveAspectRatio === \"string\") {\n                this.getAttribute(\"preserveAspectRatio\", true).setValue(preserveAspectRatio);\n            } else {\n                var preserveAspectRatioAttr = this.getAttribute(\"preserveAspectRatio\");\n                if (preserveAspectRatioAttr.hasValue()) {\n                    preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, \"$1\"));\n                }\n            }\n        }\n        widthAttr.setValue(width);\n        heightAttr.setValue(height);\n        if (!viewBoxAttr.hasValue()) {\n            viewBoxAttr.setValue(\"0 0 \".concat(originWidth || width, \" \").concat(originHeight || height));\n        }\n        if (styleAttr.hasValue()) {\n            var widthStyle = this.getStyle(\"width\");\n            var heightStyle = this.getStyle(\"height\");\n            if (widthStyle.hasValue()) {\n                widthStyle.setValue(\"\".concat(width, \"px\"));\n            }\n            if (heightStyle.hasValue()) {\n                heightStyle.setValue(\"\".concat(height, \"px\"));\n            }\n        }\n    }\n}\nclass RectElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"rect\";\n    }\n    path(ctx) {\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\", false, true).getPixels(\"x\");\n        var height = this.getStyle(\"height\", false, true).getPixels(\"y\");\n        var rxAttr = this.getAttribute(\"rx\");\n        var ryAttr = this.getAttribute(\"ry\");\n        var rx = rxAttr.getPixels(\"x\");\n        var ry = ryAttr.getPixels(\"y\");\n        if (rxAttr.hasValue() && !ryAttr.hasValue()) {\n            ry = rx;\n        }\n        if (ryAttr.hasValue() && !rxAttr.hasValue()) {\n            rx = ry;\n        }\n        rx = Math.min(rx, width / 2.0);\n        ry = Math.min(ry, height / 2.0);\n        if (ctx) {\n            var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n            ctx.beginPath(); // always start the path so we don't fill prior paths\n            if (height > 0 && width > 0) {\n                ctx.moveTo(x + rx, y);\n                ctx.lineTo(x + width - rx, y);\n                ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);\n                ctx.lineTo(x + width, y + height - ry);\n                ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);\n                ctx.lineTo(x + rx, y + height);\n                ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);\n                ctx.lineTo(x, y + ry);\n                ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);\n                ctx.closePath();\n            }\n        }\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass CircleElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"circle\";\n    }\n    path(ctx) {\n        var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n        var r = this.getAttribute(\"r\").getPixels();\n        if (ctx && r > 0) {\n            ctx.beginPath();\n            ctx.arc(cx, cy, r, 0, Math.PI * 2, false);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - r, cy - r, cx + r, cy + r);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass EllipseElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"ellipse\";\n    }\n    path(ctx) {\n        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n        var rx = this.getAttribute(\"rx\").getPixels(\"x\");\n        var ry = this.getAttribute(\"ry\").getPixels(\"y\");\n        var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n        if (ctx && rx > 0 && ry > 0) {\n            ctx.beginPath();\n            ctx.moveTo(cx + rx, cy);\n            ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n            ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n            ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n            ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass LineElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"line\";\n    }\n    getPoints() {\n        return [\n            new Point(this.getAttribute(\"x1\").getPixels(\"x\"), this.getAttribute(\"y1\").getPixels(\"y\")),\n            new Point(this.getAttribute(\"x2\").getPixels(\"x\"), this.getAttribute(\"y2\").getPixels(\"y\"))\n        ];\n    }\n    path(ctx) {\n        var [{ x: x0, y: y0 }, { x: x1, y: y1 }] = this.getPoints();\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n            ctx.lineTo(x1, y1);\n        }\n        return new BoundingBox(x0, y0, x1, y1);\n    }\n    getMarkers() {\n        var [p0, p1] = this.getPoints();\n        var a = p0.angleTo(p1);\n        return [\n            [\n                p0,\n                a\n            ],\n            [\n                p1,\n                a\n            ]\n        ];\n    }\n}\nclass PolylineElement extends PathElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"polyline\";\n        this.points = [];\n        this.points = Point.parsePath(this.getAttribute(\"points\").getString());\n    }\n    path(ctx) {\n        var { points } = this;\n        var [{ x: x0, y: y0 }] = points;\n        var boundingBox = new BoundingBox(x0, y0);\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n        }\n        points.forEach((_ref)=>{\n            var { x, y } = _ref;\n            boundingBox.addPoint(x, y);\n            if (ctx) {\n                ctx.lineTo(x, y);\n            }\n        });\n        return boundingBox;\n    }\n    getMarkers() {\n        var { points } = this;\n        var lastIndex = points.length - 1;\n        var markers = [];\n        points.forEach((point, i)=>{\n            if (i === lastIndex) {\n                return;\n            }\n            markers.push([\n                point,\n                point.angleTo(points[i + 1])\n            ]);\n        });\n        if (markers.length > 0) {\n            markers.push([\n                points[points.length - 1],\n                markers[markers.length - 1][1]\n            ]);\n        }\n        return markers;\n    }\n}\nclass PolygonElement extends PolylineElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"polygon\";\n    }\n    path(ctx) {\n        var boundingBox = super.path(ctx);\n        var [{ x, y }] = this.points;\n        if (ctx) {\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n        return boundingBox;\n    }\n}\nclass PatternElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"pattern\";\n    }\n    createPattern(ctx, _, parentOpacityProp) {\n        var width = this.getStyle(\"width\").getPixels(\"x\", true);\n        var height = this.getStyle(\"height\").getPixels(\"y\", true); // render me using a temporary svg element\n        var patternSvg = new SVGElement(this.document, null);\n        patternSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n        patternSvg.attributes.width = new Property(this.document, \"width\", \"\".concat(width, \"px\"));\n        patternSvg.attributes.height = new Property(this.document, \"height\", \"\".concat(height, \"px\"));\n        patternSvg.attributes.transform = new Property(this.document, \"transform\", this.getAttribute(\"patternTransform\").getValue());\n        patternSvg.children = this.children;\n        var patternCanvas = this.document.createCanvas(width, height);\n        var patternCtx = patternCanvas.getContext(\"2d\");\n        var xAttr = this.getAttribute(\"x\");\n        var yAttr = this.getAttribute(\"y\");\n        if (xAttr.hasValue() && yAttr.hasValue()) {\n            patternCtx.translate(xAttr.getPixels(\"x\", true), yAttr.getPixels(\"y\", true));\n        }\n        if (parentOpacityProp.hasValue()) {\n            this.styles[\"fill-opacity\"] = parentOpacityProp;\n        } else {\n            Reflect.deleteProperty(this.styles, \"fill-opacity\");\n        } // render 3x3 grid so when we transform there's no white space on edges\n        for(var x = -1; x <= 1; x++){\n            for(var y = -1; y <= 1; y++){\n                patternCtx.save();\n                patternSvg.attributes.x = new Property(this.document, \"x\", x * patternCanvas.width);\n                patternSvg.attributes.y = new Property(this.document, \"y\", y * patternCanvas.height);\n                patternSvg.render(patternCtx);\n                patternCtx.restore();\n            }\n        }\n        var pattern = ctx.createPattern(patternCanvas, \"repeat\");\n        return pattern;\n    }\n}\nclass MarkerElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"marker\";\n    }\n    render(ctx, point, angle) {\n        if (!point) {\n            return;\n        }\n        var { x, y } = point;\n        var orient = this.getAttribute(\"orient\").getString(\"auto\");\n        var markerUnits = this.getAttribute(\"markerUnits\").getString(\"strokeWidth\");\n        ctx.translate(x, y);\n        if (orient === \"auto\") {\n            ctx.rotate(angle);\n        }\n        if (markerUnits === \"strokeWidth\") {\n            ctx.scale(ctx.lineWidth, ctx.lineWidth);\n        }\n        ctx.save(); // render me using a temporary svg element\n        var markerSvg = new SVGElement(this.document, null);\n        markerSvg.type = this.type;\n        markerSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n        markerSvg.attributes.refX = new Property(this.document, \"refX\", this.getAttribute(\"refX\").getValue());\n        markerSvg.attributes.refY = new Property(this.document, \"refY\", this.getAttribute(\"refY\").getValue());\n        markerSvg.attributes.width = new Property(this.document, \"width\", this.getAttribute(\"markerWidth\").getValue());\n        markerSvg.attributes.height = new Property(this.document, \"height\", this.getAttribute(\"markerHeight\").getValue());\n        markerSvg.attributes.overflow = new Property(this.document, \"overflow\", this.getAttribute(\"overflow\").getValue());\n        markerSvg.attributes.fill = new Property(this.document, \"fill\", this.getAttribute(\"fill\").getColor(\"black\"));\n        markerSvg.attributes.stroke = new Property(this.document, \"stroke\", this.getAttribute(\"stroke\").getValue(\"none\"));\n        markerSvg.children = this.children;\n        markerSvg.render(ctx);\n        ctx.restore();\n        if (markerUnits === \"strokeWidth\") {\n            ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n        }\n        if (orient === \"auto\") {\n            ctx.rotate(-angle);\n        }\n        ctx.translate(-x, -y);\n    }\n}\nclass DefsElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"defs\";\n    }\n    render() {}\n}\nclass GElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"g\";\n    }\n    getBoundingBox(ctx) {\n        var boundingBox = new BoundingBox();\n        this.children.forEach((child)=>{\n            boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n        });\n        return boundingBox;\n    }\n}\nclass GradientElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.attributesToInherit = [\n            \"gradientUnits\"\n        ];\n        this.stops = [];\n        var { stops, children } = this;\n        children.forEach((child)=>{\n            if (child.type === \"stop\") {\n                stops.push(child);\n            }\n        });\n    }\n    getGradientUnits() {\n        return this.getAttribute(\"gradientUnits\").getString(\"objectBoundingBox\");\n    }\n    createGradient(ctx, element, parentOpacityProp) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        var stopsContainer = this;\n        if (this.getHrefAttribute().hasValue()) {\n            stopsContainer = this.getHrefAttribute().getDefinition();\n            this.inheritStopContainer(stopsContainer);\n        }\n        var { stops } = stopsContainer;\n        var gradient = this.getGradient(ctx, element);\n        if (!gradient) {\n            return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);\n        }\n        stops.forEach((stop)=>{\n            gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));\n        });\n        if (this.getAttribute(\"gradientTransform\").hasValue()) {\n            // render as transformed pattern on temporary canvas\n            var { document: document1 } = this;\n            var { MAX_VIRTUAL_PIXELS, viewPort } = document1.screen;\n            var [rootView] = viewPort.viewPorts;\n            var rect = new RectElement(document1, null);\n            rect.attributes.x = new Property(document1, \"x\", -MAX_VIRTUAL_PIXELS / 3.0);\n            rect.attributes.y = new Property(document1, \"y\", -MAX_VIRTUAL_PIXELS / 3.0);\n            rect.attributes.width = new Property(document1, \"width\", MAX_VIRTUAL_PIXELS);\n            rect.attributes.height = new Property(document1, \"height\", MAX_VIRTUAL_PIXELS);\n            var group = new GElement(document1, null);\n            group.attributes.transform = new Property(document1, \"transform\", this.getAttribute(\"gradientTransform\").getValue());\n            group.children = [\n                rect\n            ];\n            var patternSvg = new SVGElement(document1, null);\n            patternSvg.attributes.x = new Property(document1, \"x\", 0);\n            patternSvg.attributes.y = new Property(document1, \"y\", 0);\n            patternSvg.attributes.width = new Property(document1, \"width\", rootView.width);\n            patternSvg.attributes.height = new Property(document1, \"height\", rootView.height);\n            patternSvg.children = [\n                group\n            ];\n            var patternCanvas = document1.createCanvas(rootView.width, rootView.height);\n            var patternCtx = patternCanvas.getContext(\"2d\");\n            patternCtx.fillStyle = gradient;\n            patternSvg.render(patternCtx);\n            return patternCtx.createPattern(patternCanvas, \"no-repeat\");\n        }\n        return gradient;\n    }\n    inheritStopContainer(stopsContainer) {\n        this.attributesToInherit.forEach((attributeToInherit)=>{\n            if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {\n                this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());\n            }\n        });\n    }\n    addParentOpacity(parentOpacityProp, color) {\n        if (parentOpacityProp.hasValue()) {\n            var colorProp = new Property(this.document, \"color\", color);\n            return colorProp.addOpacity(parentOpacityProp).getColor();\n        }\n        return color;\n    }\n}\nclass LinearGradientElement extends GradientElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"linearGradient\";\n        this.attributesToInherit.push(\"x1\", \"y1\", \"x2\", \"y2\");\n    }\n    getGradient(ctx, element) {\n        var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n        var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute(\"x1\").hasValue() && !this.getAttribute(\"y1\").hasValue() && !this.getAttribute(\"x2\").hasValue() && !this.getAttribute(\"y2\").hasValue()) {\n            this.getAttribute(\"x1\", true).setValue(0);\n            this.getAttribute(\"y1\", true).setValue(0);\n            this.getAttribute(\"x2\", true).setValue(1);\n            this.getAttribute(\"y2\", true).setValue(0);\n        }\n        var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x1\").getNumber() : this.getAttribute(\"x1\").getPixels(\"x\");\n        var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y1\").getNumber() : this.getAttribute(\"y1\").getPixels(\"y\");\n        var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x2\").getNumber() : this.getAttribute(\"x2\").getPixels(\"x\");\n        var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y2\").getNumber() : this.getAttribute(\"y2\").getPixels(\"y\");\n        if (x1 === x2 && y1 === y2) {\n            return null;\n        }\n        return ctx.createLinearGradient(x1, y1, x2, y2);\n    }\n}\nclass RadialGradientElement extends GradientElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"radialGradient\";\n        this.attributesToInherit.push(\"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\");\n    }\n    getGradient(ctx, element) {\n        var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n        var boundingBox = element.getBoundingBox(ctx);\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute(\"cx\").hasValue()) {\n            this.getAttribute(\"cx\", true).setValue(\"50%\");\n        }\n        if (!this.getAttribute(\"cy\").hasValue()) {\n            this.getAttribute(\"cy\", true).setValue(\"50%\");\n        }\n        if (!this.getAttribute(\"r\").hasValue()) {\n            this.getAttribute(\"r\", true).setValue(\"50%\");\n        }\n        var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"cx\").getNumber() : this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"cy\").getNumber() : this.getAttribute(\"cy\").getPixels(\"y\");\n        var fx = cx;\n        var fy = cy;\n        if (this.getAttribute(\"fx\").hasValue()) {\n            fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"fx\").getNumber() : this.getAttribute(\"fx\").getPixels(\"x\");\n        }\n        if (this.getAttribute(\"fy\").hasValue()) {\n            fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"fy\").getNumber() : this.getAttribute(\"fy\").getPixels(\"y\");\n        }\n        var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2.0 * this.getAttribute(\"r\").getNumber() : this.getAttribute(\"r\").getPixels();\n        var fr = this.getAttribute(\"fr\").getPixels();\n        return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);\n    }\n}\nclass StopElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"stop\";\n        var offset = Math.max(0, Math.min(1, this.getAttribute(\"offset\").getNumber()));\n        var stopOpacity = this.getStyle(\"stop-opacity\");\n        var stopColor = this.getStyle(\"stop-color\", true);\n        if (stopColor.getString() === \"\") {\n            stopColor.setValue(\"#000\");\n        }\n        if (stopOpacity.hasValue()) {\n            stopColor = stopColor.addOpacity(stopOpacity);\n        }\n        this.offset = offset;\n        this.color = stopColor.getColor();\n    }\n}\nclass AnimateElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"animate\";\n        this.duration = 0;\n        this.initialValue = null;\n        this.initialUnits = \"\";\n        this.removed = false;\n        this.frozen = false;\n        document1.screen.animations.push(this);\n        this.begin = this.getAttribute(\"begin\").getMilliseconds();\n        this.maxDuration = this.begin + this.getAttribute(\"dur\").getMilliseconds();\n        this.from = this.getAttribute(\"from\");\n        this.to = this.getAttribute(\"to\");\n        this.values = new Property(document1, \"values\", null);\n        var valuesAttr = this.getAttribute(\"values\");\n        if (valuesAttr.hasValue()) {\n            this.values.setValue(valuesAttr.getString().split(\";\"));\n        }\n    }\n    getProperty() {\n        var attributeType = this.getAttribute(\"attributeType\").getString();\n        var attributeName = this.getAttribute(\"attributeName\").getString();\n        if (attributeType === \"CSS\") {\n            return this.parent.getStyle(attributeName, true);\n        }\n        return this.parent.getAttribute(attributeName, true);\n    }\n    calcValue() {\n        var { initialUnits } = this;\n        var { progress, from, to } = this.getProgress(); // tween value linearly\n        var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;\n        if (initialUnits === \"%\") {\n            newValue *= 100.0; // numValue() returns 0-1 whereas properties are 0-100\n        }\n        return \"\".concat(newValue).concat(initialUnits);\n    }\n    update(delta) {\n        var { parent } = this;\n        var prop = this.getProperty(); // set initial value\n        if (!this.initialValue) {\n            this.initialValue = prop.getString();\n            this.initialUnits = prop.getUnits();\n        } // if we're past the end time\n        if (this.duration > this.maxDuration) {\n            var fill = this.getAttribute(\"fill\").getString(\"remove\"); // loop for indefinitely repeating animations\n            if (this.getAttribute(\"repeatCount\").getString() === \"indefinite\" || this.getAttribute(\"repeatDur\").getString() === \"indefinite\") {\n                this.duration = 0;\n            } else if (fill === \"freeze\" && !this.frozen) {\n                this.frozen = true;\n                parent.animationFrozen = true;\n                parent.animationFrozenValue = prop.getString();\n            } else if (fill === \"remove\" && !this.removed) {\n                this.removed = true;\n                prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);\n                return true;\n            }\n            return false;\n        }\n        this.duration += delta; // if we're past the begin time\n        var updated = false;\n        if (this.begin < this.duration) {\n            var newValue = this.calcValue(); // tween\n            var typeAttr = this.getAttribute(\"type\");\n            if (typeAttr.hasValue()) {\n                // for transform, etc.\n                var type = typeAttr.getString();\n                newValue = \"\".concat(type, \"(\").concat(newValue, \")\");\n            }\n            prop.setValue(newValue);\n            updated = true;\n        }\n        return updated;\n    }\n    getProgress() {\n        var { document: document1, values } = this;\n        var result = {\n            progress: (this.duration - this.begin) / (this.maxDuration - this.begin)\n        };\n        if (values.hasValue()) {\n            var p = result.progress * (values.getValue().length - 1);\n            var lb = Math.floor(p);\n            var ub = Math.ceil(p);\n            result.from = new Property(document1, \"from\", parseFloat(values.getValue()[lb]));\n            result.to = new Property(document1, \"to\", parseFloat(values.getValue()[ub]));\n            result.progress = (p - lb) / (ub - lb);\n        } else {\n            result.from = this.from;\n            result.to = this.to;\n        }\n        return result;\n    }\n}\nclass AnimateColorElement extends AnimateElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"animateColor\";\n    }\n    calcValue() {\n        var { progress, from, to } = this.getProgress();\n        var colorFrom = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(from.getColor());\n        var colorTo = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(to.getColor());\n        if (colorFrom.ok && colorTo.ok) {\n            // tween color linearly\n            var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;\n            var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;\n            var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress; // ? alpha\n            return \"rgb(\".concat(Math.floor(r), \", \").concat(Math.floor(g), \", \").concat(Math.floor(b), \")\");\n        }\n        return this.getAttribute(\"from\").getColor();\n    }\n}\nclass AnimateTransformElement extends AnimateElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"animateTransform\";\n    }\n    calcValue() {\n        var { progress, from, to } = this.getProgress(); // tween value linearly\n        var transformFrom = toNumbers(from.getString());\n        var transformTo = toNumbers(to.getString());\n        var newValue = transformFrom.map((from, i)=>{\n            var to = transformTo[i];\n            return from + (to - from) * progress;\n        }).join(\" \");\n        return newValue;\n    }\n}\nclass FontElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"font\";\n        this.glyphs = {};\n        this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n        var { definitions } = document1;\n        var { children } = this;\n        for (var child of children){\n            switch(child.type){\n                case \"font-face\":\n                    {\n                        this.fontFace = child;\n                        var fontFamilyStyle = child.getStyle(\"font-family\");\n                        if (fontFamilyStyle.hasValue()) {\n                            definitions[fontFamilyStyle.getString()] = this;\n                        }\n                        break;\n                    }\n                case \"missing-glyph\":\n                    this.missingGlyph = child;\n                    break;\n                case \"glyph\":\n                    {\n                        var glyph = child;\n                        if (glyph.arabicForm) {\n                            this.isRTL = true;\n                            this.isArabic = true;\n                            if (typeof this.glyphs[glyph.unicode] === \"undefined\") {\n                                this.glyphs[glyph.unicode] = {};\n                            }\n                            this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;\n                        } else {\n                            this.glyphs[glyph.unicode] = glyph;\n                        }\n                        break;\n                    }\n            }\n        }\n    }\n    render() {}\n}\nclass FontFaceElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"font-face\";\n        this.ascent = this.getAttribute(\"ascent\").getNumber();\n        this.descent = this.getAttribute(\"descent\").getNumber();\n        this.unitsPerEm = this.getAttribute(\"units-per-em\").getNumber();\n    }\n}\nclass MissingGlyphElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"missing-glyph\";\n        this.horizAdvX = 0;\n    }\n}\nclass TRefElement extends TextElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"tref\";\n    }\n    getText() {\n        var element = this.getHrefAttribute().getDefinition();\n        if (element) {\n            var firstChild = element.children[0];\n            if (firstChild) {\n                return firstChild.getText();\n            }\n        }\n        return \"\";\n    }\n}\nclass AElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"a\";\n        var { childNodes } = node;\n        var firstChild = childNodes[0];\n        var hasText = childNodes.length > 0 && Array.from(childNodes).every((node)=>node.nodeType === 3);\n        this.hasText = hasText;\n        this.text = hasText ? this.getTextFromNode(firstChild) : \"\";\n    }\n    getText() {\n        return this.text;\n    }\n    renderChildren(ctx) {\n        if (this.hasText) {\n            // render as text element\n            super.renderChildren(ctx);\n            var { document: document1, x, y } = this;\n            var { mouse } = document1.screen;\n            var fontSize = new Property(document1, \"fontSize\", Font.parse(document1.ctx.font).fontSize); // Do not calc bounding box if mouse is not working.\n            if (mouse.isWorking()) {\n                mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels(\"y\"), x + this.measureText(ctx), y));\n            }\n        } else if (this.children.length > 0) {\n            // render as temporary group\n            var g = new GElement(this.document, null);\n            g.children = this.children;\n            g.parent = this;\n            g.render(ctx);\n        }\n    }\n    onClick() {\n        var { window: window1 } = this.document;\n        if (window1) {\n            window1.open(this.getHrefAttribute().getString());\n        }\n    }\n    onMouseMove() {\n        var ctx = this.document.ctx;\n        ctx.canvas.style.cursor = \"pointer\";\n    }\n}\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nclass TextPathElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"textPath\";\n        this.textWidth = 0;\n        this.textHeight = 0;\n        this.pathLength = -1;\n        this.glyphInfo = null;\n        this.letterSpacingCache = [];\n        this.measuresCache = new Map([\n            [\n                \"\",\n                0\n            ]\n        ]);\n        var pathElement = this.getHrefAttribute().getDefinition();\n        this.text = this.getTextFromNode();\n        this.dataArray = this.parsePathData(pathElement);\n    }\n    getText() {\n        return this.text;\n    }\n    path(ctx) {\n        var { dataArray } = this;\n        if (ctx) {\n            ctx.beginPath();\n        }\n        dataArray.forEach((_ref)=>{\n            var { type, points } = _ref;\n            switch(type){\n                case PathParser.LINE_TO:\n                    if (ctx) {\n                        ctx.lineTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.MOVE_TO:\n                    if (ctx) {\n                        ctx.moveTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.CURVE_TO:\n                    if (ctx) {\n                        ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);\n                    }\n                    break;\n                case PathParser.QUAD_TO:\n                    if (ctx) {\n                        ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);\n                    }\n                    break;\n                case PathParser.ARC:\n                    {\n                        var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;\n                        var r = rx > ry ? rx : ry;\n                        var scaleX = rx > ry ? 1 : rx / ry;\n                        var scaleY = rx > ry ? ry / rx : 1;\n                        if (ctx) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        break;\n                    }\n                case PathParser.CLOSE_PATH:\n                    if (ctx) {\n                        ctx.closePath();\n                    }\n                    break;\n            }\n        });\n    }\n    renderChildren(ctx) {\n        this.setTextData(ctx);\n        ctx.save();\n        var textDecoration = this.parent.getStyle(\"text-decoration\").getString();\n        var fontSize = this.getFontSize();\n        var { glyphInfo } = this;\n        var fill = ctx.fillStyle;\n        if (textDecoration === \"underline\") {\n            ctx.beginPath();\n        }\n        glyphInfo.forEach((glyph, i)=>{\n            var { p0, p1, rotation, text: partialText } = glyph;\n            ctx.save();\n            ctx.translate(p0.x, p0.y);\n            ctx.rotate(rotation);\n            if (ctx.fillStyle) {\n                ctx.fillText(partialText, 0, 0);\n            }\n            if (ctx.strokeStyle) {\n                ctx.strokeText(partialText, 0, 0);\n            }\n            ctx.restore();\n            if (textDecoration === \"underline\") {\n                if (i === 0) {\n                    ctx.moveTo(p0.x, p0.y + fontSize / 8);\n                }\n                ctx.lineTo(p1.x, p1.y + fontSize / 5);\n            } // // To assist with debugging visually, uncomment following\n        //\n        // ctx.beginPath();\n        // if (i % 2)\n        // \tctx.strokeStyle = 'red';\n        // else\n        // \tctx.strokeStyle = 'green';\n        // ctx.moveTo(p0.x, p0.y);\n        // ctx.lineTo(p1.x, p1.y);\n        // ctx.stroke();\n        // ctx.closePath();\n        });\n        if (textDecoration === \"underline\") {\n            ctx.lineWidth = fontSize / 20;\n            ctx.strokeStyle = fill;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n    getLetterSpacingAt() {\n        var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.letterSpacingCache[idx] || 0;\n    }\n    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {\n        var offset = inputOffset;\n        var glyphWidth = this.measureText(ctx, c);\n        if (c === \" \" && anchor === \"justify\" && textFullWidth < fullPathWidth) {\n            glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n        }\n        if (charI > -1) {\n            offset += this.getLetterSpacingAt(charI);\n        }\n        var splineStep = this.textHeight / 20;\n        var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);\n        var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);\n        var segment = {\n            p0,\n            p1\n        };\n        var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;\n        if (dy) {\n            var dyX = Math.cos(Math.PI / 2 + rotation) * dy;\n            var dyY = Math.cos(-rotation) * dy;\n            segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {\n                x: p0.x + dyX,\n                y: p0.y + dyY\n            });\n            segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {\n                x: p1.x + dyX,\n                y: p1.y + dyY\n            });\n        }\n        offset += glyphWidth;\n        return {\n            offset,\n            segment,\n            rotation\n        };\n    }\n    measureText(ctx, text) {\n        var { measuresCache } = this;\n        var targetText = text || this.getText();\n        if (measuresCache.has(targetText)) {\n            return measuresCache.get(targetText);\n        }\n        var measure = this.measureTargetText(ctx, targetText);\n        measuresCache.set(targetText, measure);\n        return measure;\n    }\n    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.\n    // You need to call this method manually to update glyphs cache.\n    setTextData(ctx) {\n        if (this.glyphInfo) {\n            return;\n        }\n        var renderText = this.getText();\n        var chars = renderText.split(\"\");\n        var spacesNumber = renderText.split(\" \").length - 1;\n        var dx = this.parent.getAttribute(\"dx\").split().map((_)=>_.getPixels(\"x\"));\n        var dy = this.parent.getAttribute(\"dy\").getPixels(\"y\");\n        var anchor = this.parent.getStyle(\"text-anchor\").getString(\"start\");\n        var thisSpacing = this.getStyle(\"letter-spacing\");\n        var parentSpacing = this.parent.getStyle(\"letter-spacing\");\n        var letterSpacing = 0;\n        if (!thisSpacing.hasValue() || thisSpacing.getValue() === \"inherit\") {\n            letterSpacing = parentSpacing.getPixels();\n        } else if (thisSpacing.hasValue()) {\n            if (thisSpacing.getValue() !== \"initial\" && thisSpacing.getValue() !== \"unset\") {\n                letterSpacing = thisSpacing.getPixels();\n            }\n        } // fill letter-spacing cache\n        var letterSpacingCache = [];\n        var textLen = renderText.length;\n        this.letterSpacingCache = letterSpacingCache;\n        for(var i = 0; i < textLen; i++){\n            letterSpacingCache.push(typeof dx[i] !== \"undefined\" ? dx[i] : letterSpacing);\n        }\n        var dxSum = letterSpacingCache.reduce((acc, cur, i)=>i === 0 ? 0 : acc + cur || 0, 0);\n        var textWidth = this.measureText(ctx);\n        var textFullWidth = Math.max(textWidth + dxSum, 0);\n        this.textWidth = textWidth;\n        this.textHeight = this.getFontSize();\n        this.glyphInfo = [];\n        var fullPathWidth = this.getPathLength();\n        var startOffset = this.getStyle(\"startOffset\").getNumber(0) * fullPathWidth;\n        var offset = 0;\n        if (anchor === \"middle\" || anchor === \"center\") {\n            offset = -textFullWidth / 2;\n        }\n        if (anchor === \"end\" || anchor === \"right\") {\n            offset = -textFullWidth;\n        }\n        offset += startOffset;\n        chars.forEach((char, i)=>{\n            // Find such segment what distance between p0 and p1 is approx. width of glyph\n            var { offset: nextOffset, segment, rotation } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);\n            offset = nextOffset;\n            if (!segment.p0 || !segment.p1) {\n                return;\n            } // const width = this.getLineLength(\n            // \tsegment.p0.x,\n            // \tsegment.p0.y,\n            // \tsegment.p1.x,\n            // \tsegment.p1.y\n            // );\n            // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.\n            // Can foresee having a rough pair table built in that the developer can override as needed.\n            // Or use \"dx\" attribute of the <text> node as a naive replacement\n            // const kern = 0;\n            // placeholder for future implementation\n            // const midpoint = this.getPointOnLine(\n            // \tkern + width / 2.0,\n            // \tsegment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y\n            // );\n            this.glyphInfo.push({\n                // transposeX: midpoint.x,\n                // transposeY: midpoint.y,\n                text: chars[i],\n                p0: segment.p0,\n                p1: segment.p1,\n                rotation\n            });\n        });\n    }\n    parsePathData(path) {\n        this.pathLength = -1; // reset path length\n        if (!path) {\n            return [];\n        }\n        var pathCommands = [];\n        var { pathParser } = path;\n        pathParser.reset(); // convert l, H, h, V, and v to L\n        while(!pathParser.isEnd()){\n            var { current } = pathParser;\n            var startX = current ? current.x : 0;\n            var startY = current ? current.y : 0;\n            var command = pathParser.next();\n            var nextCommandType = command.type;\n            var points = [];\n            switch(command.type){\n                case PathParser.MOVE_TO:\n                    this.pathM(pathParser, points);\n                    break;\n                case PathParser.LINE_TO:\n                    nextCommandType = this.pathL(pathParser, points);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    nextCommandType = this.pathH(pathParser, points);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    nextCommandType = this.pathV(pathParser, points);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    nextCommandType = this.pathS(pathParser, points);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    nextCommandType = this.pathT(pathParser, points);\n                    break;\n                case PathParser.ARC:\n                    points = this.pathA(pathParser);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    PathElement.pathZ(pathParser);\n                    break;\n            }\n            if (command.type !== PathParser.CLOSE_PATH) {\n                pathCommands.push({\n                    type: nextCommandType,\n                    points,\n                    start: {\n                        x: startX,\n                        y: startY\n                    },\n                    pathLength: this.calcLength(startX, startY, nextCommandType, points)\n                });\n            } else {\n                pathCommands.push({\n                    type: PathParser.CLOSE_PATH,\n                    points: [],\n                    pathLength: 0\n                });\n            }\n        }\n        return pathCommands;\n    }\n    pathM(pathParser, points) {\n        var { x, y } = PathElement.pathM(pathParser).point;\n        points.push(x, y);\n    }\n    pathL(pathParser, points) {\n        var { x, y } = PathElement.pathL(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathH(pathParser, points) {\n        var { x, y } = PathElement.pathH(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathV(pathParser, points) {\n        var { x, y } = PathElement.pathV(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathC(pathParser, points) {\n        var { point, controlPoint, currentPoint } = PathElement.pathC(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathS(pathParser, points) {\n        var { point, controlPoint, currentPoint } = PathElement.pathS(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.CURVE_TO;\n    }\n    pathQ(pathParser, points) {\n        var { controlPoint, currentPoint } = PathElement.pathQ(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathT(pathParser, points) {\n        var { controlPoint, currentPoint } = PathElement.pathT(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.QUAD_TO;\n    }\n    pathA(pathParser) {\n        var { rX, rY, sweepFlag, xAxisRotation, centp, a1, ad } = PathElement.pathA(pathParser);\n        if (sweepFlag === 0 && ad > 0) {\n            ad -= 2 * Math.PI;\n        }\n        if (sweepFlag === 1 && ad < 0) {\n            ad += 2 * Math.PI;\n        }\n        return [\n            centp.x,\n            centp.y,\n            rX,\n            rY,\n            a1,\n            ad,\n            xAxisRotation,\n            sweepFlag\n        ];\n    }\n    calcLength(x, y, commandType, points) {\n        var len = 0;\n        var p1 = null;\n        var p2 = null;\n        var t = 0;\n        switch(commandType){\n            case PathParser.LINE_TO:\n                return this.getLineLength(x, y, points[0], points[1]);\n            case PathParser.CURVE_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0.0;\n                p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.QUAD_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0.0;\n                p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.ARC:\n                {\n                    // Approximates by breaking curve into line segments\n                    len = 0.0;\n                    var start = points[4]; // 4 = theta\n                    var dTheta = points[5]; // 5 = dTheta\n                    var end = points[4] + dTheta;\n                    var inc = Math.PI / 180.0; // 1 degree resolution\n                    if (Math.abs(start - end) < inc) {\n                        inc = Math.abs(start - end);\n                    } // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi\n                    p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\n                    if (dTheta < 0) {\n                        // clockwise\n                        for(t = start - inc; t > end; t -= inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    } else {\n                        // counter-clockwise\n                        for(t = start + inc; t < end; t += inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    }\n                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    return len;\n                }\n        }\n        return 0;\n    }\n    getPointOnLine(dist, p1x, p1y, p2x, p2y) {\n        var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;\n        var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;\n        var m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);\n        var run = Math.sqrt(dist * dist / (1 + m * m));\n        if (p2x < p1x) {\n            run *= -1;\n        }\n        var rise = m * run;\n        var pt = null;\n        if (p2x === p1x) {\n            // vertical line\n            pt = {\n                x: fromX,\n                y: fromY + rise\n            };\n        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {\n            pt = {\n                x: fromX + run,\n                y: fromY + rise\n            };\n        } else {\n            var ix = 0;\n            var iy = 0;\n            var len = this.getLineLength(p1x, p1y, p2x, p2y);\n            if (len < PSEUDO_ZERO) {\n                return null;\n            }\n            var u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);\n            u /= len * len;\n            ix = p1x + u * (p2x - p1x);\n            iy = p1y + u * (p2y - p1y);\n            var pRise = this.getLineLength(fromX, fromY, ix, iy);\n            var pRun = Math.sqrt(dist * dist - pRise * pRise);\n            run = Math.sqrt(pRun * pRun / (1 + m * m));\n            if (p2x < p1x) {\n                run *= -1;\n            }\n            rise = m * run;\n            pt = {\n                x: ix + run,\n                y: iy + rise\n            };\n        }\n        return pt;\n    }\n    getPointOnPath(distance) {\n        var fullLen = this.getPathLength();\n        var cumulativePathLength = 0;\n        var p = null;\n        if (distance < -0.00005 || distance - 0.00005 > fullLen) {\n            return null;\n        }\n        var { dataArray } = this;\n        for (var command of dataArray){\n            if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {\n                cumulativePathLength += command.pathLength;\n                continue;\n            }\n            var delta = distance - cumulativePathLength;\n            var currentT = 0;\n            switch(command.type){\n                case PathParser.LINE_TO:\n                    p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);\n                    break;\n                case PathParser.ARC:\n                    {\n                        var start = command.points[4]; // 4 = theta\n                        var dTheta = command.points[5]; // 5 = dTheta\n                        var end = command.points[4] + dTheta;\n                        currentT = start + delta / command.pathLength * dTheta;\n                        if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                            break;\n                        }\n                        p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);\n                        break;\n                    }\n                case PathParser.CURVE_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);\n                    break;\n                case PathParser.QUAD_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);\n                    break;\n            }\n            if (p) {\n                return p;\n            }\n            break;\n        }\n        return null;\n    }\n    getLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    getPathLength() {\n        if (this.pathLength === -1) {\n            this.pathLength = this.dataArray.reduce((length, command)=>command.pathLength > 0 ? length + command.pathLength : length, 0);\n        }\n        return this.pathLength;\n    }\n    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);\n        var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {\n        var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);\n        var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n        var cosPsi = Math.cos(psi);\n        var sinPsi = Math.sin(psi);\n        var pt = {\n            x: rx * Math.cos(theta),\n            y: ry * Math.sin(theta)\n        };\n        return {\n            x: cx + (pt.x * cosPsi - pt.y * sinPsi),\n            y: cy + (pt.x * sinPsi + pt.y * cosPsi)\n        };\n    }\n    buildEquidistantCache(inputStep, inputPrecision) {\n        var fullLen = this.getPathLength();\n        var precision = inputPrecision || 0.25; // accuracy vs performance\n        var step = inputStep || fullLen / 100;\n        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {\n            // Prepare cache\n            this.equidistantCache = {\n                step,\n                precision,\n                points: []\n            }; // Calculate points\n            var s = 0;\n            for(var l = 0; l <= fullLen; l += precision){\n                var p0 = this.getPointOnPath(l);\n                var p1 = this.getPointOnPath(l + precision);\n                if (!p0 || !p1) {\n                    continue;\n                }\n                s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                if (s >= step) {\n                    this.equidistantCache.points.push({\n                        x: p0.x,\n                        y: p0.y,\n                        distance: l\n                    });\n                    s -= step;\n                }\n            }\n        }\n    }\n    getEquidistantPointOnPath(targetDistance, step, precision) {\n        this.buildEquidistantCache(step, precision);\n        if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {\n            return null;\n        }\n        var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));\n        return this.equidistantCache.points[idx] || null;\n    }\n}\nvar dataUriRegex = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nclass ImageElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"image\";\n        this.loaded = false;\n        var href = this.getHrefAttribute().getString();\n        if (!href) {\n            return;\n        }\n        var isSvg = href.endsWith(\".svg\") || /^\\s*data:image\\/svg\\+xml/i.test(href);\n        document1.images.push(this);\n        if (!isSvg) {\n            void this.loadImage(href);\n        } else {\n            void this.loadSvg(href);\n        }\n        this.isSvg = isSvg;\n    }\n    loadImage(href) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            try {\n                var image = yield _this.document.createImage(href);\n                _this.image = image;\n            } catch (err) {\n                console.error('Error while loading image \"'.concat(href, '\":'), err);\n            }\n            _this.loaded = true;\n        })();\n    }\n    loadSvg(href) {\n        var _this2 = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var match = dataUriRegex.exec(href);\n            if (match) {\n                var data = match[5];\n                if (match[4] === \"base64\") {\n                    _this2.image = atob(data);\n                } else {\n                    _this2.image = decodeURIComponent(data);\n                }\n            } else {\n                try {\n                    var response = yield _this2.document.fetch(href);\n                    var svg = yield response.text();\n                    _this2.image = svg;\n                } catch (err) {\n                    console.error('Error while loading image \"'.concat(href, '\":'), err);\n                }\n            }\n            _this2.loaded = true;\n        })();\n    }\n    renderChildren(ctx) {\n        var { document: document1, image, loaded } = this;\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        if (!loaded || !image || !width || !height) {\n            return;\n        }\n        ctx.save();\n        ctx.translate(x, y);\n        if (this.isSvg) {\n            var subDocument = document1.canvg.forkString(ctx, this.image, {\n                ignoreMouse: true,\n                ignoreAnimation: true,\n                ignoreDimensions: true,\n                ignoreClear: true,\n                offsetX: 0,\n                offsetY: 0,\n                scaleWidth: width,\n                scaleHeight: height\n            });\n            subDocument.document.documentElement.parent = this;\n            void subDocument.render();\n        } else {\n            var _image = this.image;\n            document1.setViewBox({\n                ctx,\n                aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n                width,\n                desiredWidth: _image.width,\n                height,\n                desiredHeight: _image.height\n            });\n            if (this.loaded) {\n                if (typeof _image.complete === \"undefined\" || _image.complete) {\n                    ctx.drawImage(_image, 0, 0);\n                }\n            }\n        }\n        ctx.restore();\n    }\n    getBoundingBox() {\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n}\nclass SymbolElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"symbol\";\n    }\n    render(_) {}\n}\nclass SVGFontLoader {\n    constructor(document1){\n        this.document = document1;\n        this.loaded = false;\n        document1.fonts.push(this);\n    }\n    load(fontFamily, url) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            try {\n                var { document: document1 } = _this;\n                var svgDocument = yield document1.canvg.parser.load(url);\n                var fonts = svgDocument.getElementsByTagName(\"font\");\n                Array.from(fonts).forEach((fontNode)=>{\n                    var font = document1.createElement(fontNode);\n                    document1.definitions[fontFamily] = font;\n                });\n            } catch (err) {\n                console.error('Error while loading font \"'.concat(url, '\":'), err);\n            }\n            _this.loaded = true;\n        })();\n    }\n}\nclass StyleElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"style\";\n        var css = compressSpaces(Array.from(node.childNodes) // NEED TEST\n        .map((_)=>_.textContent).join(\"\").replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, \"\") // remove comments\n        .replace(/@import.*;/g, \"\") // remove imports\n        );\n        var cssDefs = css.split(\"}\");\n        cssDefs.forEach((_)=>{\n            var def = _.trim();\n            if (!def) {\n                return;\n            }\n            var cssParts = def.split(\"{\");\n            var cssClasses = cssParts[0].split(\",\");\n            var cssProps = cssParts[1].split(\";\");\n            cssClasses.forEach((_)=>{\n                var cssClass = _.trim();\n                if (!cssClass) {\n                    return;\n                }\n                var props = document1.styles[cssClass] || {};\n                cssProps.forEach((cssProp)=>{\n                    var prop = cssProp.indexOf(\":\");\n                    var name = cssProp.substr(0, prop).trim();\n                    var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();\n                    if (name && value) {\n                        props[name] = new Property(document1, name, value);\n                    }\n                });\n                document1.styles[cssClass] = props;\n                document1.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\n                if (cssClass === \"@font-face\") {\n                    //  && !nodeEnv\n                    var fontFamily = props[\"font-family\"].getString().replace(/\"|'/g, \"\");\n                    var srcs = props.src.getString().split(\",\");\n                    srcs.forEach((src)=>{\n                        if (src.indexOf('format(\"svg\")') > 0) {\n                            var url = parseExternalUrl(src);\n                            if (url) {\n                                void new SVGFontLoader(document1).load(fontFamily, url);\n                            }\n                        }\n                    });\n                }\n            });\n        });\n    }\n}\nStyleElement.parseExternalUrl = parseExternalUrl;\nclass UseElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"use\";\n    }\n    setContext(ctx) {\n        super.setContext(ctx);\n        var xAttr = this.getAttribute(\"x\");\n        var yAttr = this.getAttribute(\"y\");\n        if (xAttr.hasValue()) {\n            ctx.translate(xAttr.getPixels(\"x\"), 0);\n        }\n        if (yAttr.hasValue()) {\n            ctx.translate(0, yAttr.getPixels(\"y\"));\n        }\n    }\n    path(ctx) {\n        var { element } = this;\n        if (element) {\n            element.path(ctx);\n        }\n    }\n    renderChildren(ctx) {\n        var { document: document1, element } = this;\n        if (element) {\n            var tempSvg = element;\n            if (element.type === \"symbol\") {\n                // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\n                tempSvg = new SVGElement(document1, null);\n                tempSvg.attributes.viewBox = new Property(document1, \"viewBox\", element.getAttribute(\"viewBox\").getString());\n                tempSvg.attributes.preserveAspectRatio = new Property(document1, \"preserveAspectRatio\", element.getAttribute(\"preserveAspectRatio\").getString());\n                tempSvg.attributes.overflow = new Property(document1, \"overflow\", element.getAttribute(\"overflow\").getString());\n                tempSvg.children = element.children; // element is still the parent of the children\n                element.styles.opacity = new Property(document1, \"opacity\", this.calculateOpacity());\n            }\n            if (tempSvg.type === \"svg\") {\n                var widthStyle = this.getStyle(\"width\", false, true);\n                var heightStyle = this.getStyle(\"height\", false, true); // if symbol or svg, inherit width/height from me\n                if (widthStyle.hasValue()) {\n                    tempSvg.attributes.width = new Property(document1, \"width\", widthStyle.getString());\n                }\n                if (heightStyle.hasValue()) {\n                    tempSvg.attributes.height = new Property(document1, \"height\", heightStyle.getString());\n                }\n            }\n            var oldParent = tempSvg.parent;\n            tempSvg.parent = this;\n            tempSvg.render(ctx);\n            tempSvg.parent = oldParent;\n        }\n    }\n    getBoundingBox(ctx) {\n        var { element } = this;\n        if (element) {\n            return element.getBoundingBox(ctx);\n        }\n        return null;\n    }\n    elementTransform() {\n        var { document: document1, element } = this;\n        return Transform.fromElement(document1, element);\n    }\n    get element() {\n        if (!this.cachedElement) {\n            this.cachedElement = this.getHrefAttribute().getDefinition();\n        }\n        return this.cachedElement;\n    }\n}\nfunction imGet(img, x, y, width, _height, rgba) {\n    return img[y * width * 4 + x * 4 + rgba];\n}\nfunction imSet(img, x, y, width, _height, rgba, val) {\n    img[y * width * 4 + x * 4 + rgba] = val;\n}\nfunction m(matrix, i, v) {\n    var mi = matrix[i];\n    return mi * v;\n}\nfunction c(a, m1, m2, m3) {\n    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;\n}\nclass FeColorMatrixElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feColorMatrix\";\n        var matrix = toNumbers(this.getAttribute(\"values\").getString());\n        switch(this.getAttribute(\"type\").getString(\"matrix\")){\n            // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement\n            case \"saturate\":\n                {\n                    var s = matrix[0];\n                    /* eslint-disable array-element-newline */ matrix = [\n                        0.213 + 0.787 * s,\n                        0.715 - 0.715 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 + 0.285 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 - 0.715 * s,\n                        0.072 + 0.928 * s,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"hueRotate\":\n                {\n                    var a = matrix[0] * Math.PI / 180.0;\n                    /* eslint-disable array-element-newline */ matrix = [\n                        c(a, 0.213, 0.787, -0.213),\n                        c(a, 0.715, -0.715, -0.715),\n                        c(a, 0.072, -0.072, 0.928),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, 0.143),\n                        c(a, 0.715, 0.285, 0.140),\n                        c(a, 0.072, -0.072, -0.283),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, -0.787),\n                        c(a, 0.715, -0.715, 0.715),\n                        c(a, 0.072, 0.928, 0.072),\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"luminanceToAlpha\":\n                /* eslint-disable array-element-newline */ matrix = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0.2125,\n                    0.7154,\n                    0.0721,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                break;\n        }\n        this.matrix = matrix;\n        this.includeOpacity = this.getAttribute(\"includeOpacity\").hasValue();\n    }\n    apply(ctx, _x, _y, width, height) {\n        // assuming x==0 && y==0 for now\n        var { includeOpacity, matrix } = this;\n        var srcData = ctx.getImageData(0, 0, width, height);\n        for(var y = 0; y < height; y++){\n            for(var x = 0; x < width; x++){\n                var r = imGet(srcData.data, x, y, width, height, 0);\n                var g = imGet(srcData.data, x, y, width, height, 1);\n                var b = imGet(srcData.data, x, y, width, height, 2);\n                var a = imGet(srcData.data, x, y, width, height, 3);\n                var nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);\n                var ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);\n                var nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);\n                var na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);\n                if (includeOpacity) {\n                    nr = 0;\n                    ng = 0;\n                    nb = 0;\n                    na *= a / 255;\n                }\n                imSet(srcData.data, x, y, width, height, 0, nr);\n                imSet(srcData.data, x, y, width, height, 1, ng);\n                imSet(srcData.data, x, y, width, height, 2, nb);\n                imSet(srcData.data, x, y, width, height, 3, na);\n            }\n        }\n        ctx.clearRect(0, 0, width, height);\n        ctx.putImageData(srcData, 0, 0);\n    }\n}\nclass MaskElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"mask\";\n    }\n    apply(ctx, element) {\n        var { document: document1 } = this; // render as temp svg\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        if (!width && !height) {\n            var boundingBox = new BoundingBox();\n            this.children.forEach((child)=>{\n                boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n            });\n            x = Math.floor(boundingBox.x1);\n            y = Math.floor(boundingBox.y1);\n            width = Math.floor(boundingBox.width);\n            height = Math.floor(boundingBox.height);\n        }\n        var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);\n        var maskCanvas = document1.createCanvas(x + width, y + height);\n        var maskCtx = maskCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(maskCtx);\n        this.renderChildren(maskCtx); // convert mask to alpha with a fake node\n        // TODO: refactor out apply from feColorMatrix\n        new FeColorMatrixElement(document1, {\n            nodeType: 1,\n            childNodes: [],\n            attributes: [\n                {\n                    nodeName: \"type\",\n                    value: \"luminanceToAlpha\"\n                },\n                {\n                    nodeName: \"includeOpacity\",\n                    value: \"true\"\n                }\n            ]\n        }).apply(maskCtx, 0, 0, x + width, y + height);\n        var tmpCanvas = document1.createCanvas(x + width, y + height);\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(tmpCtx);\n        element.render(tmpCtx);\n        tmpCtx.globalCompositeOperation = \"destination-in\";\n        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, \"no-repeat\");\n        tmpCtx.fillRect(0, 0, x + width, y + height);\n        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, \"no-repeat\");\n        ctx.fillRect(0, 0, x + width, y + height); // reassign mask\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {}\n}\nMaskElement.ignoreStyles = [\n    \"mask\",\n    \"transform\",\n    \"clip-path\"\n];\nvar noop = ()=>{};\nclass ClipPathElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"clipPath\";\n    }\n    apply(ctx) {\n        var { document: document1 } = this;\n        var contextProto = Reflect.getPrototypeOf(ctx);\n        var { beginPath, closePath } = ctx;\n        if (contextProto) {\n            contextProto.beginPath = noop;\n            contextProto.closePath = noop;\n        }\n        Reflect.apply(beginPath, ctx, []);\n        this.children.forEach((child)=>{\n            if (typeof child.path === \"undefined\") {\n                return;\n            }\n            var transform = typeof child.elementTransform !== \"undefined\" ? child.elementTransform() : null; // handle <use />\n            if (!transform) {\n                transform = Transform.fromElement(document1, child);\n            }\n            if (transform) {\n                transform.apply(ctx);\n            }\n            child.path(ctx);\n            if (contextProto) {\n                contextProto.closePath = closePath;\n            }\n            if (transform) {\n                transform.unapply(ctx);\n            }\n        });\n        Reflect.apply(closePath, ctx, []);\n        ctx.clip();\n        if (contextProto) {\n            contextProto.beginPath = beginPath;\n            contextProto.closePath = closePath;\n        }\n    }\n    render(_) {}\n}\nclass FilterElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"filter\";\n    }\n    apply(ctx, element) {\n        // render as temp svg\n        var { document: document1, children } = this;\n        var boundingBox = element.getBoundingBox(ctx);\n        if (!boundingBox) {\n            return;\n        }\n        var px = 0;\n        var py = 0;\n        children.forEach((child)=>{\n            var efd = child.extraFilterDistance || 0;\n            px = Math.max(px, efd);\n            py = Math.max(py, efd);\n        });\n        var width = Math.floor(boundingBox.width);\n        var height = Math.floor(boundingBox.height);\n        var tmpCanvasWidth = width + 2 * px;\n        var tmpCanvasHeight = height + 2 * py;\n        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {\n            return;\n        }\n        var x = Math.floor(boundingBox.x);\n        var y = Math.floor(boundingBox.y);\n        var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);\n        var tmpCanvas = document1.createCanvas(tmpCanvasWidth, tmpCanvasHeight);\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(tmpCtx);\n        tmpCtx.translate(-x + px, -y + py);\n        element.render(tmpCtx); // apply filters\n        children.forEach((child)=>{\n            if (typeof child.apply === \"function\") {\n                child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);\n            }\n        }); // render on me\n        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {}\n}\nFilterElement.ignoreStyles = [\n    \"filter\",\n    \"transform\",\n    \"clip-path\"\n];\nclass FeDropShadowElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feDropShadow\";\n        this.addStylesFromStyleDefinition();\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeMorphologyElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"feMorphology\";\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeCompositeElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"feComposite\";\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeGaussianBlurElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feGaussianBlur\";\n        this.blurRadius = Math.floor(this.getAttribute(\"stdDeviation\").getNumber());\n        this.extraFilterDistance = this.blurRadius;\n    }\n    apply(ctx, x, y, width, height) {\n        var { document: document1, blurRadius } = this;\n        var body = document1.window ? document1.window.document.body : null;\n        var canvas = ctx.canvas; // StackBlur requires canvas be on document\n        canvas.id = document1.getUniqueId();\n        if (body) {\n            canvas.style.display = \"none\";\n            body.appendChild(canvas);\n        }\n        (0,stackblur_canvas__WEBPACK_IMPORTED_MODULE_19__.canvasRGBA)(canvas, x, y, width, height, blurRadius);\n        if (body) {\n            body.removeChild(canvas);\n        }\n    }\n}\nclass TitleElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"title\";\n    }\n}\nclass DescElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"desc\";\n    }\n}\nvar elements = {\n    \"svg\": SVGElement,\n    \"rect\": RectElement,\n    \"circle\": CircleElement,\n    \"ellipse\": EllipseElement,\n    \"line\": LineElement,\n    \"polyline\": PolylineElement,\n    \"polygon\": PolygonElement,\n    \"path\": PathElement,\n    \"pattern\": PatternElement,\n    \"marker\": MarkerElement,\n    \"defs\": DefsElement,\n    \"linearGradient\": LinearGradientElement,\n    \"radialGradient\": RadialGradientElement,\n    \"stop\": StopElement,\n    \"animate\": AnimateElement,\n    \"animateColor\": AnimateColorElement,\n    \"animateTransform\": AnimateTransformElement,\n    \"font\": FontElement,\n    \"font-face\": FontFaceElement,\n    \"missing-glyph\": MissingGlyphElement,\n    \"glyph\": GlyphElement,\n    \"text\": TextElement,\n    \"tspan\": TSpanElement,\n    \"tref\": TRefElement,\n    \"a\": AElement,\n    \"textPath\": TextPathElement,\n    \"image\": ImageElement,\n    \"g\": GElement,\n    \"symbol\": SymbolElement,\n    \"style\": StyleElement,\n    \"use\": UseElement,\n    \"mask\": MaskElement,\n    \"clipPath\": ClipPathElement,\n    \"filter\": FilterElement,\n    \"feDropShadow\": FeDropShadowElement,\n    \"feMorphology\": FeMorphologyElement,\n    \"feComposite\": FeCompositeElement,\n    \"feColorMatrix\": FeColorMatrixElement,\n    \"feGaussianBlur\": FeGaussianBlurElement,\n    \"title\": TitleElement,\n    \"desc\": DescElement\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction createCanvas(width, height) {\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nfunction createImage(_x) {\n    return _createImage.apply(this, arguments);\n}\nfunction _createImage() {\n    _createImage = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*(src) {\n        var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var image = document.createElement(\"img\");\n        if (anonymousCrossOrigin) {\n            image.crossOrigin = \"Anonymous\";\n        }\n        return new Promise((resolve, reject)=>{\n            image.onload = ()=>{\n                resolve(image);\n            };\n            image.onerror = (_event, _source, _lineno, _colno, error)=>{\n                reject(error);\n            };\n            image.src = src;\n        });\n    });\n    return _createImage.apply(this, arguments);\n}\nclass Document {\n    constructor(canvg){\n        var { rootEmSize = 12, emSize = 12, createCanvas = Document.createCanvas, createImage = Document.createImage, anonymousCrossOrigin } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.canvg = canvg;\n        this.definitions = {};\n        this.styles = {};\n        this.stylesSpecificity = {};\n        this.images = [];\n        this.fonts = [];\n        this.emSizeStack = [];\n        this.uniqueId = 0;\n        this.screen = canvg.screen;\n        this.rootEmSize = rootEmSize;\n        this.emSize = emSize;\n        this.createCanvas = createCanvas;\n        this.createImage = this.bindCreateImage(createImage, anonymousCrossOrigin);\n        this.screen.wait(this.isImagesLoaded.bind(this));\n        this.screen.wait(this.isFontsLoaded.bind(this));\n    }\n    bindCreateImage(createImage, anonymousCrossOrigin) {\n        if (typeof anonymousCrossOrigin === \"boolean\") {\n            return (source, forceAnonymousCrossOrigin)=>createImage(source, typeof forceAnonymousCrossOrigin === \"boolean\" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);\n        }\n        return createImage;\n    }\n    get window() {\n        return this.screen.window;\n    }\n    get fetch() {\n        return this.screen.fetch;\n    }\n    get ctx() {\n        return this.screen.ctx;\n    }\n    get emSize() {\n        var { emSizeStack } = this;\n        return emSizeStack[emSizeStack.length - 1];\n    }\n    set emSize(value) {\n        var { emSizeStack } = this;\n        emSizeStack.push(value);\n    }\n    popEmSize() {\n        var { emSizeStack } = this;\n        emSizeStack.pop();\n    }\n    getUniqueId() {\n        return \"canvg\".concat(++this.uniqueId);\n    }\n    isImagesLoaded() {\n        return this.images.every((_)=>_.loaded);\n    }\n    isFontsLoaded() {\n        return this.fonts.every((_)=>_.loaded);\n    }\n    createDocumentElement(document1) {\n        var documentElement = this.createElement(document1.documentElement);\n        documentElement.root = true;\n        documentElement.addStylesFromStyleDefinition();\n        this.documentElement = documentElement;\n        return documentElement;\n    }\n    createElement(node) {\n        var elementType = node.nodeName.replace(/^[^:]+:/, \"\");\n        var ElementType = Document.elementTypes[elementType];\n        if (typeof ElementType !== \"undefined\") {\n            return new ElementType(this, node);\n        }\n        return new UnknownElement(this, node);\n    }\n    createTextNode(node) {\n        return new TextNode(this, node);\n    }\n    setViewBox(config) {\n        this.screen.setViewBox(_objectSpread$1({\n            document: this\n        }, config));\n    }\n}\nDocument.createCanvas = createCanvas;\nDocument.createImage = createImage;\nDocument.elementTypes = elements;\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * SVG renderer on canvas.\r\n */ class Canvg {\n    /**\r\n   * Main constructor.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG Document.\r\n   * @param options - Rendering options.\r\n   */ constructor(ctx, svg){\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this.parser = new Parser(options);\n        this.screen = new Screen(ctx, options);\n        this.options = options;\n        var document1 = new Document(this, options);\n        var documentElement = document1.createDocumentElement(svg);\n        this.document = document1;\n        this.documentElement = documentElement;\n    }\n    /**\r\n   * Create Canvg instance from SVG source string or URL.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ static from(ctx, svg) {\n        var _arguments = arguments;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};\n            var parser = new Parser(options);\n            var svgDocument = yield parser.parse(svg);\n            return new Canvg(ctx, svgDocument, options);\n        })();\n    }\n    /**\r\n   * Create Canvg instance from SVG source string.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ static fromString(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var parser = new Parser(options);\n        var svgDocument = parser.parseFromString(svg);\n        return new Canvg(ctx, svgDocument, options);\n    }\n    /**\r\n   * Create new Canvg instance with inherited options.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ fork(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n    }\n    /**\r\n   * Create new Canvg instance with inherited options.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ forkString(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n    }\n    /**\r\n   * Document is ready promise.\r\n   * @returns Ready promise.\r\n   */ ready() {\n        return this.screen.ready();\n    }\n    /**\r\n   * Document is ready value.\r\n   * @returns Is ready or not.\r\n   */ isReady() {\n        return this.screen.isReady();\n    }\n    /**\r\n   * Render only first frame, ignoring animations and mouse.\r\n   * @param options - Rendering options.\r\n   */ render() {\n        var _arguments2 = arguments, _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};\n            _this.start(_objectSpread({\n                enableRedraw: true,\n                ignoreAnimation: true,\n                ignoreMouse: true\n            }, options));\n            yield _this.ready();\n            _this.stop();\n        })();\n    }\n    /**\r\n   * Start rendering.\r\n   * @param options - Render options.\r\n   */ start() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var { documentElement, screen, options: baseOptions } = this;\n        screen.start(documentElement, _objectSpread(_objectSpread({\n            enableRedraw: true\n        }, baseOptions), options));\n    }\n    /**\r\n   * Stop rendering.\r\n   */ stop() {\n        this.screen.stop();\n    }\n    /**\r\n   * Resize SVG to fit in given size.\r\n   * @param width\r\n   * @param height\r\n   * @param preserveAspectRatio\r\n   */ resize(width) {\n        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this.documentElement.resize(width, height, preserveAspectRatio);\n    }\n}\n //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZXMuanMiLCJzb3VyY2VzIjpbXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDaUM7QUFDNUI7QUFDRTtBQUNJO0FBQ0o7QUFDVztBQUNXO0FBQ3hCO0FBQ0k7QUFDSjtBQUNKO0FBQ0c7QUFDWDtBQUNjO0FBQ0M7QUFDRjtBQUNGO0FBQ0s7QUFDRjtBQUU5Qzs7Ozs7Q0FLQyxHQUNELFNBQVNNO0lBQ1AsSUFBSSxFQUNGQyxXQUFXQyxpQkFBaUIsRUFDN0IsR0FBR0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztJQUN6RSxJQUFJRyxTQUFTO1FBQ1hDLFFBQVE7UUFDUkMsaUJBQWlCO1FBQ2pCQyxhQUFhO1FBQ2JSLFdBQVdDO1FBRVhRLGNBQWFDLEtBQUssRUFBRUMsTUFBTTtZQUN4QixPQUFPLElBQUlDLGdCQUFnQkYsT0FBT0M7UUFDcEM7UUFFQUUsYUFBWUMsR0FBRztZQUNiLE9BQU9yQixvRUFBaUJBLENBQUM7Z0JBQ3ZCLElBQUlzQixXQUFXLE1BQU1DLE1BQU1GO2dCQUMzQixJQUFJRyxPQUFPLE1BQU1GLFNBQVNFLElBQUk7Z0JBQzlCLElBQUlDLE1BQU0sTUFBTUMsa0JBQWtCRjtnQkFDbEMsT0FBT0M7WUFDVDtRQUNGO0lBRUY7SUFFQSxJQUFJLE9BQU9sQixjQUFjLGVBQWUsT0FBT0Msc0JBQXNCLGFBQWE7UUFDaEZtQixRQUFRQyxjQUFjLENBQUNoQixRQUFRO0lBQ2pDO0lBRUEsT0FBT0E7QUFDVDtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTaUIsS0FBS0MsSUFBSTtJQUNoQixJQUFJLEVBQ0Z2QixXQUFBQSxVQUFTLEVBQ1R3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LGNBQWM7WUFDeER4dUIsY0FBYztRQUNoQixHQUFHK3VCLGNBQWNMO0lBQ25CO0lBQ0E7O0dBRUMsR0FHRHIwQixPQUFPO1FBQ0wsSUFBSSxDQUFDakUsTUFBTSxDQUFDaUUsSUFBSTtJQUNsQjtJQUNBOzs7OztHQUtDLEdBR0QwZixPQUFPaHJCLEtBQUssRUFBRTtRQUNaLElBQUlDLFNBQVNULFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHUTtRQUNqRixJQUFJaXJCLHNCQUFzQnpyQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM5RixJQUFJLENBQUN5NUIsZUFBZSxDQUFDak8sTUFBTSxDQUFDaHJCLE9BQU9DLFFBQVFnckI7SUFDN0M7QUFFRjtBQUUwb0MsQ0FDMW9DLDR0UkFBNHRSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5uby10b29scy8uL25vZGVfbW9kdWxlcy9jYW52Zy9saWIvaW5kZXguZXMuanM/MGRkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmpzJztcbmltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3InO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zdGFydHMtd2l0aC5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzJztcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UuanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmVuZHMtd2l0aC5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMnO1xuaW1wb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tICdyYWYnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW0uanMnO1xuaW1wb3J0IFJHQkNvbG9yIGZyb20gJ3JnYmNvbG9yJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcy5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZXZlcnNlLmpzJztcbmltcG9ydCB7IFNWR1BhdGhEYXRhIH0gZnJvbSAnc3ZnLXBhdGhkYXRhJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMnO1xuaW1wb3J0IHsgY2FudmFzUkdCQSB9IGZyb20gJ3N0YWNrYmx1ci1jYW52YXMnO1xuXG4vKipcclxuICogT3B0aW9ucyBwcmVzZXQgZm9yIGBPZmZzY3JlZW5DYW52YXNgLlxyXG4gKiBAcGFyYW0gY29uZmlnIC0gUHJlc2V0IHJlcXVpcmVtZW50cy5cclxuICogQHBhcmFtIGNvbmZpZy5ET01QYXJzZXIgLSBYTUwvSFRNTCBwYXJzZXIgZnJvbSBzdHJpbmcgaW50byBET00gRG9jdW1lbnQuXHJcbiAqIEByZXR1cm5zIFByZXNldCBvYmplY3QuXHJcbiAqL1xuZnVuY3Rpb24gb2Zmc2NyZWVuKCkge1xuICB2YXIge1xuICAgIERPTVBhcnNlcjogRE9NUGFyc2VyRmFsbGJhY2tcbiAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBwcmVzZXQgPSB7XG4gICAgd2luZG93OiBudWxsLFxuICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICBpZ25vcmVNb3VzZTogdHJ1ZSxcbiAgICBET01QYXJzZXI6IERPTVBhcnNlckZhbGxiYWNrLFxuXG4gICAgY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVJbWFnZSh1cmwpIHtcbiAgICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaCh1cmwpO1xuICAgICAgICB2YXIgYmxvYiA9IHlpZWxkIHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgdmFyIGltZyA9IHlpZWxkIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IpO1xuICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgfTtcblxuICBpZiAodHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIERPTVBhcnNlckZhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkocHJlc2V0LCAnRE9NUGFyc2VyJyk7XG4gIH1cblxuICByZXR1cm4gcHJlc2V0O1xufVxuXG4vKipcclxuICogT3B0aW9ucyBwcmVzZXQgZm9yIGBub2RlLWNhbnZhc2AuXHJcbiAqIEBwYXJhbSBjb25maWcgLSBQcmVzZXQgcmVxdWlyZW1lbnRzLlxyXG4gKiBAcGFyYW0gY29uZmlnLkRPTVBhcnNlciAtIFhNTC9IVE1MIHBhcnNlciBmcm9tIHN0cmluZyBpbnRvIERPTSBEb2N1bWVudC5cclxuICogQHBhcmFtIGNvbmZpZy5jYW52YXMgLSBgbm9kZS1jYW52YXNgIGV4cG9ydHMuXHJcbiAqIEBwYXJhbSBjb25maWcuZmV0Y2ggLSBXSEFUV0ctY29tcGF0aWJsZSBgZmV0Y2hgIGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJucyBQcmVzZXQgb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIG5vZGUoX3JlZikge1xuICB2YXIge1xuICAgIERPTVBhcnNlcixcbiAgICBjYW52YXMsXG4gICAgZmV0Y2hcbiAgfSA9IF9yZWY7XG4gIHJldHVybiB7XG4gICAgd2luZG93OiBudWxsLFxuICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICBpZ25vcmVNb3VzZTogdHJ1ZSxcbiAgICBET01QYXJzZXIsXG4gICAgZmV0Y2gsXG4gICAgY3JlYXRlQ2FudmFzOiBjYW52YXMuY3JlYXRlQ2FudmFzLFxuICAgIGNyZWF0ZUltYWdlOiBjYW52YXMubG9hZEltYWdlXG4gIH07XG59XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRvZmZzY3JlZW46IG9mZnNjcmVlbixcblx0bm9kZTogbm9kZVxufSk7XG5cbi8qKlxyXG4gKiBIVE1MLXNhZmUgY29tcHJlc3Mgd2hpdGUtc3BhY2VzLlxyXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIGNvbXByZXNzLlxyXG4gKiBAcmV0dXJucyBTdHJpbmcuXHJcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NTcGFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKD8hXFx1MzAwMClcXHMrL2dtLCAnICcpO1xufVxuLyoqXHJcbiAqIEhUTUwtc2FmZSBsZWZ0IHRyaW0uXHJcbiAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gdHJpbS5cclxuICogQHJldHVybnMgU3RyaW5nLlxyXG4gKi9cblxuZnVuY3Rpb24gdHJpbUxlZnQoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXltcXG4gXFx0XSsvLCAnJyk7XG59XG4vKipcclxuICogSFRNTC1zYWZlIHJpZ2h0IHRyaW0uXHJcbiAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gdHJpbS5cclxuICogQHJldHVybnMgU3RyaW5nLlxyXG4gKi9cblxuZnVuY3Rpb24gdHJpbVJpZ2h0KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXG4gXFx0XSskLywgJycpO1xufVxuLyoqXHJcbiAqIFN0cmluZyB0byBudW1iZXJzIGFycmF5LlxyXG4gKiBAcGFyYW0gc3RyIC0gTnVtYmVycyBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIE51bWJlcnMgYXJyYXkuXHJcbiAqL1xuXG5mdW5jdGlvbiB0b051bWJlcnMoc3RyKSB7XG4gIHZhciBtYXRjaGVzID0gKHN0ciB8fCAnJykubWF0Y2goLy0/KFxcZCsoPzpcXC5cXGQqKD86W2VFXVsrLV0/XFxkKyk/KT98XFwuXFxkKykoPz1cXER8JCkvZ20pIHx8IFtdO1xuICByZXR1cm4gbWF0Y2hlcy5tYXAocGFyc2VGbG9hdCk7XG59IC8vIE1pY3Jvc29mdCBFZGdlIGZpeFxuXG52YXIgYWxsVXBwZXJjYXNlID0gL15bQS1aLV0rJC87XG4vKipcclxuICogTm9ybWFsaXplIGF0dHJpYnV0ZSBuYW1lLlxyXG4gKiBAcGFyYW0gbmFtZSAtIEF0dHJpYnV0ZSBuYW1lLlxyXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIGF0dHJpYnV0ZSBuYW1lLlxyXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQXR0cmlidXRlTmFtZShuYW1lKSB7XG4gIGlmIChhbGxVcHBlcmNhc2UudGVzdChuYW1lKSkge1xuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gbmFtZTtcbn1cbi8qKlxyXG4gKiBQYXJzZSBleHRlcm5hbCBVUkwuXHJcbiAqIEBwYXJhbSB1cmwgLSBDU1MgdXJsIHN0cmluZy5cclxuICogQHJldHVybnMgUGFyc2VkIFVSTC5cclxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRXh0ZXJuYWxVcmwodXJsKSB7XG4gIC8vICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZSBxdW90ZXMgWzJdXG4gIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICBkb3VibGUgcXVvdGVzIFszXVxuICAvLyAgICAgICAgICAgICAgICAgICAgICB2ICAgICAgICAgdiAgICAgICAgIG5vIHF1b3RlcyBbNF1cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgIHYgICAgICAgICB2XG4gIHZhciB1cmxNYXRjaCA9IC91cmxcXCgoJyhbXiddKyknfFwiKFteXCJdKylcInwoW14nXCIpXSspKVxcKS8uZXhlYyh1cmwpIHx8IFtdO1xuICByZXR1cm4gdXJsTWF0Y2hbMl0gfHwgdXJsTWF0Y2hbM10gfHwgdXJsTWF0Y2hbNF07XG59XG4vKipcclxuICogVHJhbnNmb3JtIGZsb2F0cyB0byBpbnRlZ2VycyBpbiByZ2IgY29sb3JzLlxyXG4gKiBAcGFyYW0gY29sb3IgLSBDb2xvciB0byBub3JtYWxpemUuXHJcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgY29sb3IuXHJcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICBpZiAoIWNvbG9yLnN0YXJ0c1dpdGgoJ3JnYicpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgdmFyIHJnYlBhcnRzID0gMztcbiAgdmFyIG5vcm1hbGl6ZWRDb2xvciA9IGNvbG9yLnJlcGxhY2UoL1xcZCsoXFwuXFxkKyk/L2csIChudW0sIGlzRmxvYXQpID0+IHJnYlBhcnRzLS0gJiYgaXNGbG9hdCA/IFN0cmluZyhNYXRoLnJvdW5kKHBhcnNlRmxvYXQobnVtKSkpIDogbnVtKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWRDb2xvcjtcbn1cblxuLy8gc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2VlZ2Fuc3RyZWV0L3NwZWNpZmljaXR5L2Jsb2IvbWFzdGVyL3NwZWNpZmljaXR5LmpzXG52YXIgYXR0cmlidXRlUmVnZXggPSAvKFxcW1teXFxdXStcXF0pL2c7XG52YXIgaWRSZWdleCA9IC8oI1teXFxzKz5+Lls6XSspL2c7XG52YXIgY2xhc3NSZWdleCA9IC8oXFwuW15cXHMrPn4uWzpdKykvZztcbnZhciBwc2V1ZG9FbGVtZW50UmVnZXggPSAvKDo6W15cXHMrPn4uWzpdK3w6Zmlyc3QtbGluZXw6Zmlyc3QtbGV0dGVyfDpiZWZvcmV8OmFmdGVyKS9naTtcbnZhciBwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4ID0gLyg6W1xcdy1dK1xcKFteKV0qXFwpKS9naTtcbnZhciBwc2V1ZG9DbGFzc1JlZ2V4ID0gLyg6W15cXHMrPn4uWzpdKykvZztcbnZhciBlbGVtZW50UmVnZXggPSAvKFteXFxzKz5+Lls6XSspL2c7XG5cbmZ1bmN0aW9uIGZpbmRTZWxlY3Rvck1hdGNoKHNlbGVjdG9yLCByZWdleCkge1xuICB2YXIgbWF0Y2hlcyA9IHJlZ2V4LmV4ZWMoc2VsZWN0b3IpO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbc2VsZWN0b3IsIDBdO1xuICB9XG5cbiAgcmV0dXJuIFtzZWxlY3Rvci5yZXBsYWNlKHJlZ2V4LCAnICcpLCBtYXRjaGVzLmxlbmd0aF07XG59XG4vKipcclxuICogTWVhc3VyZSBzZWxlY3RvciBzcGVjaWZpY2l0eS5cclxuICogQHBhcmFtIHNlbGVjdG9yIC0gU2VsZWN0b3IgdG8gbWVhc3VyZS5cclxuICogQHJldHVybnMgU3BlY2lmaWNpdHkuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoc2VsZWN0b3IpIHtcbiAgdmFyIHNwZWNpZmljaXR5ID0gWzAsIDAsIDBdO1xuICB2YXIgY3VycmVudFNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvOm5vdFxcKChbXildKilcXCkvZywgJyAgICAgJDEgJykucmVwbGFjZSgve1tcXHNcXFNdKi9nbSwgJyAnKTtcbiAgdmFyIGRlbHRhID0gMDtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBhdHRyaWJ1dGVSZWdleCk7XG4gIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGlkUmVnZXgpO1xuICBzcGVjaWZpY2l0eVswXSArPSBkZWx0YTtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBjbGFzc1JlZ2V4KTtcbiAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvRWxlbWVudFJlZ2V4KTtcbiAgc3BlY2lmaWNpdHlbMl0gKz0gZGVsdGE7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvQ2xhc3NXaXRoQnJhY2tldHNSZWdleCk7XG4gIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIHBzZXVkb0NsYXNzUmVnZXgpO1xuICBzcGVjaWZpY2l0eVsxXSArPSBkZWx0YTtcbiAgY3VycmVudFNlbGVjdG9yID0gY3VycmVudFNlbGVjdG9yLnJlcGxhY2UoL1sqXFxzKz5+XS9nLCAnICcpLnJlcGxhY2UoL1sjLl0vZywgJyAnKTtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBlbGVtZW50UmVnZXgpOyAvLyBsZ3RtIFtqcy91c2VsZXNzLWFzc2lnbm1lbnQtdG8tbG9jYWxdXG5cbiAgc3BlY2lmaWNpdHlbMl0gKz0gZGVsdGE7XG4gIHJldHVybiBzcGVjaWZpY2l0eS5qb2luKCcnKTtcbn1cblxudmFyIFBTRVVET19aRVJPID0gLjAwMDAwMDAxO1xuLyoqXHJcbiAqIFZlY3RvciBtYWduaXR1ZGUuXHJcbiAqIEBwYXJhbSB2XHJcbiAqIEByZXR1cm5zIE51bWJlciByZXN1bHQuXHJcbiAqL1xuXG5mdW5jdGlvbiB2ZWN0b3JNYWduaXR1ZGUodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHZbMF0sIDIpICsgTWF0aC5wb3codlsxXSwgMikpO1xufVxuLyoqXHJcbiAqIFJhdGlvIGJldHdlZW4gdHdvIHZlY3RvcnMuXHJcbiAqIEBwYXJhbSB1XHJcbiAqIEBwYXJhbSB2XHJcbiAqIEByZXR1cm5zIE51bWJlciByZXN1bHQuXHJcbiAqL1xuXG5mdW5jdGlvbiB2ZWN0b3JzUmF0aW8odSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZlY3Rvck1hZ25pdHVkZSh1KSAqIHZlY3Rvck1hZ25pdHVkZSh2KSk7XG59XG4vKipcclxuICogQW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycy5cclxuICogQHBhcmFtIHVcclxuICogQHBhcmFtIHZcclxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cclxuICovXG5cbmZ1bmN0aW9uIHZlY3RvcnNBbmdsZSh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModmVjdG9yc1JhdGlvKHUsIHYpKTtcbn1cbmZ1bmN0aW9uIENCMSh0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBDQjIodCkge1xuICByZXR1cm4gMyAqIHQgKiB0ICogKDEgLSB0KTtcbn1cbmZ1bmN0aW9uIENCMyh0KSB7XG4gIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gQ0I0KHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KTtcbn1cbmZ1bmN0aW9uIFFCMSh0KSB7XG4gIHJldHVybiB0ICogdDtcbn1cbmZ1bmN0aW9uIFFCMih0KSB7XG4gIHJldHVybiAyICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBRQjModCkge1xuICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCk7XG59XG5cbmNsYXNzIFByb3BlcnR5IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuaXNOb3JtYWxpemVkQ29sb3IgPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBlbXB0eShkb2N1bWVudCkge1xuICAgIHJldHVybiBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdFTVBUWScsICcnKTtcbiAgfVxuXG4gIHNwbGl0KCkge1xuICAgIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcgJztcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBuYW1lXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0U3RyaW5nKCkpLnRyaW0oKS5zcGxpdChzZXBhcmF0b3IpLm1hcCh2YWx1ZSA9PiBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKSk7XG4gIH1cblxuICBoYXNWYWx1ZSh6ZXJvSXNWYWx1ZSkge1xuICAgIHZhciB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycgJiYgKHplcm9Jc1ZhbHVlIHx8IHZhbHVlICE9PSAwKSAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaXNTdHJpbmcocmVnZXhwKSB7XG4gICAgdmFyIHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG5cbiAgICBpZiAoIXJlc3VsdCB8fCAhcmVnZXhwKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiByZWdleHAudGVzdCh2YWx1ZSk7XG4gIH1cblxuICBpc1VybERlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTdHJpbmcoL151cmxcXCgvKTtcbiAgfVxuXG4gIGlzUGl4ZWxzKCkge1xuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFzU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBhc1N0cmluZy5lbmRzV2l0aCgncHgnKTpcbiAgICAgIGNhc2UgL15bMC05XSskLy50ZXN0KGFzU3RyaW5nKTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldFZhbHVlKGRlZikge1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZWY7XG4gIH1cblxuICBnZXROdW1iZXIoZGVmKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZGVmKTtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgaWYgKHRoaXMuaXNTdHJpbmcoLyUkLykpIHtcbiAgICAgIG4gLz0gMTAwLjA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG4gIH1cblxuICBnZXRTdHJpbmcoZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnZhbHVlID09PSAndW5kZWZpbmVkJyA/ICcnIDogU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcoZGVmKTtcbiAgfVxuXG4gIGdldENvbG9yKGRlZikge1xuICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0U3RyaW5nKGRlZik7XG5cbiAgICBpZiAodGhpcy5pc05vcm1hbGl6ZWRDb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cblxuICAgIHRoaXMuaXNOb3JtYWxpemVkQ29sb3IgPSB0cnVlO1xuICAgIGNvbG9yID0gbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICAgIHRoaXMudmFsdWUgPSBjb2xvcjtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBnZXREcGkoKSB7XG4gICAgcmV0dXJuIDk2LjA7IC8vIFRPRE86IGNvbXB1dGU/XG4gIH1cblxuICBnZXRSZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQucm9vdEVtU2l6ZTtcbiAgfVxuXG4gIGdldEVtKCkge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmVtU2l6ZTtcbiAgfVxuXG4gIGdldFVuaXRzKCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0cmluZygpLnJlcGxhY2UoL1swLTkuLV0vZywgJycpO1xuICB9XG5cbiAgZ2V0UGl4ZWxzKGF4aXNPcklzRm9udFNpemUpIHtcbiAgICB2YXIgcHJvY2Vzc1BlcmNlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBbYXhpcywgaXNGb250U2l6ZV0gPSB0eXBlb2YgYXhpc09ySXNGb250U2l6ZSA9PT0gJ2Jvb2xlYW4nID8gW3VuZGVmaW5lZCwgYXhpc09ySXNGb250U2l6ZV0gOiBbYXhpc09ySXNGb250U2l6ZV07XG4gICAgdmFyIHtcbiAgICAgIHZpZXdQb3J0XG4gICAgfSA9IHRoaXMuZG9jdW1lbnQuc2NyZWVuO1xuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZtaW4kLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwLjAgKiBNYXRoLm1pbih2aWV3UG9ydC5jb21wdXRlU2l6ZSgneCcpLCB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneScpKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92bWF4JC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogTWF0aC5tYXgodmlld1BvcnQuY29tcHV0ZVNpemUoJ3gnKSwgdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKSk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdnckLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwLjAgKiB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneCcpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZoJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9yZW0kLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRSZW0oKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9lbSQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldEVtKCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZXgkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRFbSgpIC8gMi4wO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3B4JC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9wdCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpICogKDEuMCAvIDcyLjApO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3BjJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIDE1O1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2NtJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyLjU0O1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL21tJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyNS40O1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2luJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvJSQvKSAmJiBpc0ZvbnRTaXplOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RW0oKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC8lJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKGF4aXMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLmdldE51bWJlcigpO1xuXG4gICAgICAgICAgaWYgKHByb2Nlc3NQZXJjZW50ICYmIG4gPCAxLjApIHtcbiAgICAgICAgICAgIHJldHVybiBuICogdmlld1BvcnQuY29tcHV0ZVNpemUoYXhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRNaWxsaXNlY29uZHMoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU3RyaW5nKC9tcyQvKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAxMDAwO1xuICB9XG5cbiAgZ2V0UmFkaWFucygpIHtcbiAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2RlZyQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDE4MC4wKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9ncmFkJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIChNYXRoLlBJIC8gMjAwLjApO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3JhZCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RGVmaW5pdGlvbigpIHtcbiAgICB2YXIgYXNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuICAgIHZhciBuYW1lID0gLyMoW14pJ1wiXSspLy5leGVjKGFzU3RyaW5nKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBuYW1lID0gbmFtZVsxXTtcbiAgICB9XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIG5hbWUgPSBhc1N0cmluZztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5kZWZpbml0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIGdldEZpbGxTdHlsZURlZmluaXRpb24oZWxlbWVudCwgb3BhY2l0eSkge1xuICAgIHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oKTtcblxuICAgIGlmICghZGVmKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGdyYWRpZW50XG5cblxuICAgIGlmICh0eXBlb2YgZGVmLmNyZWF0ZUdyYWRpZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZGVmLmNyZWF0ZUdyYWRpZW50KHRoaXMuZG9jdW1lbnQuY3R4LCBlbGVtZW50LCBvcGFjaXR5KTtcbiAgICB9IC8vIHBhdHRlcm5cblxuXG4gICAgaWYgKHR5cGVvZiBkZWYuY3JlYXRlUGF0dGVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgcGF0dGVyblRyYW5zZm9ybSA9IGRlZi5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nKTtcbiAgICAgICAgZGVmID0gZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgaWYgKHBhdHRlcm5UcmFuc2Zvcm0uaGFzVmFsdWUoKSkge1xuICAgICAgICAgIGRlZi5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nLCB0cnVlKS5zZXRWYWx1ZShwYXR0ZXJuVHJhbnNmb3JtLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmLmNyZWF0ZVBhdHRlcm4odGhpcy5kb2N1bWVudC5jdHgsIGVsZW1lbnQsIG9wYWNpdHkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0VGV4dEJhc2VsaW5lKCkge1xuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvcGVydHkudGV4dEJhc2VsaW5lTWFwcGluZ1t0aGlzLmdldFN0cmluZygpXTtcbiAgfVxuXG4gIGFkZE9wYWNpdHkob3BhY2l0eSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0Q29sb3IoKTtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgIHZhciBjb21tYXMgPSAwOyAvLyBTaW11bGF0ZSBvbGQgUkdCQ29sb3IgdmVyc2lvbiwgd2hpY2ggY2FuJ3QgcGFyc2UgcmdiYS5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJywnKSB7XG4gICAgICAgIGNvbW1hcysrO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFzID09PSAzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcGFjaXR5Lmhhc1ZhbHVlKCkgJiYgdGhpcy5pc1N0cmluZygpICYmIGNvbW1hcyAhPT0gMykge1xuICAgICAgdmFyIGNvbG9yID0gbmV3IFJHQkNvbG9yKHZhbHVlKTtcblxuICAgICAgaWYgKGNvbG9yLm9rKSB7XG4gICAgICAgIGNvbG9yLmFscGhhID0gb3BhY2l0eS5nZXROdW1iZXIoKTtcbiAgICAgICAgdmFsdWUgPSBjb2xvci50b1JHQkEoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIHRoaXMubmFtZSwgdmFsdWUpO1xuICB9XG5cbn1cblByb3BlcnR5LnRleHRCYXNlbGluZU1hcHBpbmcgPSB7XG4gICdiYXNlbGluZSc6ICdhbHBoYWJldGljJyxcbiAgJ2JlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICd0ZXh0LWJlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICdtaWRkbGUnOiAnbWlkZGxlJyxcbiAgJ2NlbnRyYWwnOiAnbWlkZGxlJyxcbiAgJ2FmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgJ3RleHQtYWZ0ZXItZWRnZSc6ICdib3R0b20nLFxuICAnaWRlb2dyYXBoaWMnOiAnaWRlb2dyYXBoaWMnLFxuICAnYWxwaGFiZXRpYyc6ICdhbHBoYWJldGljJyxcbiAgJ2hhbmdpbmcnOiAnaGFuZ2luZycsXG4gICdtYXRoZW1hdGljYWwnOiAnYWxwaGFiZXRpYydcbn07XG5cbmNsYXNzIFZpZXdQb3J0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52aWV3UG9ydHMgPSBbXTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMudmlld1BvcnRzID0gW107XG4gIH1cblxuICBzZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnZpZXdQb3J0cy5wdXNoKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVDdXJyZW50KCkge1xuICAgIHRoaXMudmlld1BvcnRzLnBvcCgpO1xuICB9XG5cbiAgZ2V0Q3VycmVudCgpIHtcbiAgICB2YXIge1xuICAgICAgdmlld1BvcnRzXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHZpZXdQb3J0c1t2aWV3UG9ydHMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudCgpLndpZHRoO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50KCkuaGVpZ2h0O1xuICB9XG5cbiAgY29tcHV0ZVNpemUoZCkge1xuICAgIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIGlmIChkID09PSAneCcpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChkID09PSAneScpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMud2lkdGgsIDIpICsgTWF0aC5wb3codGhpcy5oZWlnaHQsIDIpKSAvIE1hdGguc3FydCgyKTtcbiAgfVxuXG59XG5cbmNsYXNzIFBvaW50IHtcbiAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZShwb2ludCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIFt4ID0gZGVmYXVsdFZhbHVlLCB5ID0gZGVmYXVsdFZhbHVlXSA9IHRvTnVtYmVycyhwb2ludCk7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZVNjYWxlKHNjYWxlKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICB2YXIgW3ggPSBkZWZhdWx0VmFsdWUsIHkgPSB4XSA9IHRvTnVtYmVycyhzY2FsZSk7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZVBhdGgocGF0aCkge1xuICAgIHZhciBwb2ludHMgPSB0b051bWJlcnMocGF0aCk7XG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIHBhdGhQb2ludHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgIHBhdGhQb2ludHMucHVzaChuZXcgUG9pbnQocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhQb2ludHM7XG4gIH1cblxuICBhbmdsZVRvKHBvaW50KSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIocG9pbnQueSAtIHRoaXMueSwgcG9pbnQueCAtIHRoaXMueCk7XG4gIH1cblxuICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgeHAgPSB4ICogdHJhbnNmb3JtWzBdICsgeSAqIHRyYW5zZm9ybVsyXSArIHRyYW5zZm9ybVs0XTtcbiAgICB2YXIgeXAgPSB4ICogdHJhbnNmb3JtWzFdICsgeSAqIHRyYW5zZm9ybVszXSArIHRyYW5zZm9ybVs1XTtcbiAgICB0aGlzLnggPSB4cDtcbiAgICB0aGlzLnkgPSB5cDtcbiAgfVxuXG59XG5cbmNsYXNzIE1vdXNlIHtcbiAgY29uc3RydWN0b3Ioc2NyZWVuKSB7XG4gICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XG4gICAgdGhpcy53b3JraW5nID0gZmFsc2U7XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuXG4gICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcblxuICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gIH1cblxuICBpc1dvcmtpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMud29ya2luZztcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLndvcmtpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgc2NyZWVuLFxuICAgICAgb25DbGljayxcbiAgICAgIG9uTW91c2VNb3ZlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGNhbnZhcyA9IHNjcmVlbi5jdHguY2FudmFzO1xuICAgIGNhbnZhcy5vbmNsaWNrID0gb25DbGljaztcbiAgICBjYW52YXMub25tb3VzZW1vdmUgPSBvbk1vdXNlTW92ZTtcbiAgICB0aGlzLndvcmtpbmcgPSB0cnVlO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAoIXRoaXMud29ya2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSB0aGlzLnNjcmVlbi5jdHguY2FudmFzO1xuICAgIHRoaXMud29ya2luZyA9IGZhbHNlO1xuICAgIGNhbnZhcy5vbmNsaWNrID0gbnVsbDtcbiAgICBjYW52YXMub25tb3VzZW1vdmUgPSBudWxsO1xuICB9XG5cbiAgaGFzRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLndvcmtpbmcgJiYgdGhpcy5ldmVudHMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIHJ1bkV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMud29ya2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBzY3JlZW46IGRvY3VtZW50LFxuICAgICAgZXZlbnRzLFxuICAgICAgZXZlbnRFbGVtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkb2N1bWVudC5jdHguY2FudmFzO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBzdHlsZS5jdXJzb3IgPSAnJztcbiAgICB9XG5cbiAgICBldmVudHMuZm9yRWFjaCgoX3JlZiwgaSkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgcnVuXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHZhciBlbGVtZW50ID0gZXZlbnRFbGVtZW50c1tpXTtcblxuICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgcnVuKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfSk7IC8vIGRvbmUgcnVubmluZywgY2xlYXJcblxuICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG4gIH1cblxuICBjaGVja1BhdGgoZWxlbWVudCwgY3R4KSB7XG4gICAgaWYgKCF0aGlzLndvcmtpbmcgfHwgIWN0eCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBldmVudHMsXG4gICAgICBldmVudEVsZW1lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgZXZlbnRzLmZvckVhY2goKF9yZWYyLCBpKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gX3JlZjI7XG5cbiAgICAgIGlmICghZXZlbnRFbGVtZW50c1tpXSAmJiBjdHguaXNQb2ludEluUGF0aCAmJiBjdHguaXNQb2ludEluUGF0aCh4LCB5KSkge1xuICAgICAgICBldmVudEVsZW1lbnRzW2ldID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNoZWNrQm91bmRpbmdCb3goZWxlbWVudCwgYm91bmRpbmdCb3gpIHtcbiAgICBpZiAoIXRoaXMud29ya2luZyB8fCAhYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgZXZlbnRzLFxuICAgICAgZXZlbnRFbGVtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIGV2ZW50cy5mb3JFYWNoKChfcmVmMywgaSkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IF9yZWYzO1xuXG4gICAgICBpZiAoIWV2ZW50RWxlbWVudHNbaV0gJiYgYm91bmRpbmdCb3guaXNQb2ludEluQm94KHgsIHkpKSB7XG4gICAgICAgIGV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwWFkoeCwgeSkge1xuICAgIHZhciB7XG4gICAgICB3aW5kb3csXG4gICAgICBjdHhcbiAgICB9ID0gdGhpcy5zY3JlZW47XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgIHZhciBlbGVtZW50ID0gY3R4LmNhbnZhcztcblxuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICBwb2ludC54IC09IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgIHBvaW50LnkgLT0gZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5zY3JvbGxYKSB7XG4gICAgICBwb2ludC54ICs9IHdpbmRvdy5zY3JvbGxYO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuc2Nyb2xsWSkge1xuICAgICAgcG9pbnQueSArPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMubWFwWFkoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICB0eXBlOiAnb25jbGljaycsXG4gICAgICB4LFxuICAgICAgeSxcblxuICAgICAgcnVuKGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGlmIChldmVudFRhcmdldC5vbkNsaWNrKSB7XG4gICAgICAgICAgZXZlbnRUYXJnZXQub25DbGljaygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMubWFwWFkoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICB0eXBlOiAnb25tb3VzZW1vdmUnLFxuICAgICAgeCxcbiAgICAgIHksXG5cbiAgICAgIHJ1bihldmVudFRhcmdldCkge1xuICAgICAgICBpZiAoZXZlbnRUYXJnZXQub25Nb3VzZU1vdmUpIHtcbiAgICAgICAgICBldmVudFRhcmdldC5vbk1vdXNlTW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfVxuXG59XG5cbnZhciBkZWZhdWx0V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsO1xudmFyIGRlZmF1bHRGZXRjaCQxID0gdHlwZW9mIGZldGNoICE9PSAndW5kZWZpbmVkJyA/IGZldGNoLmJpbmQodW5kZWZpbmVkKSAvLyBgZmV0Y2hgIGRlcGVuZHMgb24gY29udGV4dDogYHNvbWVPYmplY3QuZmV0Y2goLi4uKWAgd2lsbCB0aHJvdyBlcnJvci5cbjogbnVsbDtcbmNsYXNzIFNjcmVlbiB7XG4gIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBmZXRjaCA9IGRlZmF1bHRGZXRjaCQxLFxuICAgICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuRlJBTUVSQVRFID0gMzA7XG4gICAgdGhpcy5NQVhfVklSVFVBTF9QSVhFTFMgPSAzMDAwMDtcbiAgICB0aGlzLkNMSUVOVF9XSURUSCA9IDgwMDtcbiAgICB0aGlzLkNMSUVOVF9IRUlHSFQgPSA2MDA7XG4gICAgdGhpcy52aWV3UG9ydCA9IG5ldyBWaWV3UG9ydCgpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcyk7XG4gICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gICAgdGhpcy53YWl0cyA9IFtdO1xuICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5pc1JlYWR5TG9jayA9IGZhbHNlO1xuICAgIHRoaXMuaXNGaXJzdFJlbmRlciA9IHRydWU7XG4gICAgdGhpcy5pbnRlcnZhbElkID0gbnVsbDtcbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gIH1cblxuICB3YWl0KGNoZWNrZXIpIHtcbiAgICB0aGlzLndhaXRzLnB1c2goY2hlY2tlcik7XG4gIH1cblxuICByZWFkeSgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICBpZiAoIXRoaXMucmVhZHlQcm9taXNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVhZHlQcm9taXNlO1xuICB9XG5cbiAgaXNSZWFkeSgpIHtcbiAgICBpZiAodGhpcy5pc1JlYWR5TG9jaykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVhZHlMb2NrID0gdGhpcy53YWl0cy5ldmVyeShfID0+IF8oKSk7XG5cbiAgICBpZiAoaXNSZWFkeUxvY2spIHtcbiAgICAgIHRoaXMud2FpdHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMucmVzb2x2ZVJlYWR5KSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZVJlYWR5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pc1JlYWR5TG9jayA9IGlzUmVhZHlMb2NrO1xuICAgIHJldHVybiBpc1JlYWR5TG9jaztcbiAgfVxuXG4gIHNldERlZmF1bHRzKGN0eCkge1xuICAgIC8vIGluaXRpYWwgdmFsdWVzIGFuZCBkZWZhdWx0c1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICBjdHgubGluZUNhcCA9ICdidXR0JztcbiAgICBjdHgubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgIGN0eC5taXRlckxpbWl0ID0gNDtcbiAgfVxuXG4gIHNldFZpZXdCb3goX3JlZikge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIGN0eCxcbiAgICAgIGFzcGVjdFJhdGlvLFxuICAgICAgd2lkdGgsXG4gICAgICBkZXNpcmVkV2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBkZXNpcmVkSGVpZ2h0LFxuICAgICAgbWluWCA9IDAsXG4gICAgICBtaW5ZID0gMCxcbiAgICAgIHJlZlgsXG4gICAgICByZWZZLFxuICAgICAgY2xpcCA9IGZhbHNlLFxuICAgICAgY2xpcFggPSAwLFxuICAgICAgY2xpcFkgPSAwXG4gICAgfSA9IF9yZWY7XG4gICAgLy8gYXNwZWN0IHJhdGlvIC0gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGVcbiAgICB2YXIgY2xlYW5Bc3BlY3RSYXRpbyA9IGNvbXByZXNzU3BhY2VzKGFzcGVjdFJhdGlvKS5yZXBsYWNlKC9eZGVmZXJcXHMvLCAnJyk7IC8vIGlnbm9yZSBkZWZlclxuXG4gICAgdmFyIFthc3BlY3RSYXRpb0FsaWduLCBhc3BlY3RSYXRpb01lZXRPclNsaWNlXSA9IGNsZWFuQXNwZWN0UmF0aW8uc3BsaXQoJyAnKTtcbiAgICB2YXIgYWxpZ24gPSBhc3BlY3RSYXRpb0FsaWduIHx8ICd4TWlkWU1pZCc7XG4gICAgdmFyIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW9NZWV0T3JTbGljZSB8fCAnbWVldCc7IC8vIGNhbGN1bGF0ZSBzY2FsZVxuXG4gICAgdmFyIHNjYWxlWCA9IHdpZHRoIC8gZGVzaXJlZFdpZHRoO1xuICAgIHZhciBzY2FsZVkgPSBoZWlnaHQgLyBkZXNpcmVkSGVpZ2h0O1xuICAgIHZhciBzY2FsZU1pbiA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcbiAgICB2YXIgc2NhbGVNYXggPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgdmFyIGZpbmFsRGVzaXJlZFdpZHRoID0gZGVzaXJlZFdpZHRoO1xuICAgIHZhciBmaW5hbERlc2lyZWRIZWlnaHQgPSBkZXNpcmVkSGVpZ2h0O1xuXG4gICAgaWYgKG1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgIGZpbmFsRGVzaXJlZFdpZHRoICo9IHNjYWxlTWluO1xuICAgICAgZmluYWxEZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWluO1xuICAgIH1cblxuICAgIGlmIChtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgZmluYWxEZXNpcmVkV2lkdGggKj0gc2NhbGVNYXg7XG4gICAgICBmaW5hbERlc2lyZWRIZWlnaHQgKj0gc2NhbGVNYXg7XG4gICAgfVxuXG4gICAgdmFyIHJlZlhQcm9wID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAncmVmWCcsIHJlZlgpO1xuICAgIHZhciByZWZZUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3JlZlknLCByZWZZKTtcbiAgICB2YXIgaGFzUmVmcyA9IHJlZlhQcm9wLmhhc1ZhbHVlKCkgJiYgcmVmWVByb3AuaGFzVmFsdWUoKTtcblxuICAgIGlmIChoYXNSZWZzKSB7XG4gICAgICBjdHgudHJhbnNsYXRlKC1zY2FsZU1pbiAqIHJlZlhQcm9wLmdldFBpeGVscygneCcpLCAtc2NhbGVNaW4gKiByZWZZUHJvcC5nZXRQaXhlbHMoJ3knKSk7XG4gICAgfVxuXG4gICAgaWYgKGNsaXApIHtcbiAgICAgIHZhciBzY2FsZWRDbGlwWCA9IHNjYWxlTWluICogY2xpcFg7XG4gICAgICB2YXIgc2NhbGVkQ2xpcFkgPSBzY2FsZU1pbiAqIGNsaXBZO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhzY2FsZWRDbGlwWCwgc2NhbGVkQ2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgc2NhbGVkQ2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5saW5lVG8oc2NhbGVkQ2xpcFgsIGhlaWdodCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgIH1cblxuICAgIGlmICghaGFzUmVmcykge1xuICAgICAgdmFyIGlzTWVldE1pblkgPSBtZWV0T3JTbGljZSA9PT0gJ21lZXQnICYmIHNjYWxlTWluID09PSBzY2FsZVk7XG4gICAgICB2YXIgaXNTbGljZU1heFkgPSBtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PT0gc2NhbGVZO1xuICAgICAgdmFyIGlzTWVldE1pblggPSBtZWV0T3JTbGljZSA9PT0gJ21lZXQnICYmIHNjYWxlTWluID09PSBzY2FsZVg7XG4gICAgICB2YXIgaXNTbGljZU1heFggPSBtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PT0gc2NhbGVYO1xuXG4gICAgICBpZiAoYWxpZ24uc3RhcnRzV2l0aCgneE1pZCcpICYmIChpc01lZXRNaW5ZIHx8IGlzU2xpY2VNYXhZKSkge1xuICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC8gMi4wIC0gZmluYWxEZXNpcmVkV2lkdGggLyAyLjAsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxpZ24uZW5kc1dpdGgoJ1lNaWQnKSAmJiAoaXNNZWV0TWluWCB8fCBpc1NsaWNlTWF4WCkpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLyAyLjAgLSBmaW5hbERlc2lyZWRIZWlnaHQgLyAyLjApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxpZ24uc3RhcnRzV2l0aCgneE1heCcpICYmIChpc01lZXRNaW5ZIHx8IGlzU2xpY2VNYXhZKSkge1xuICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC0gZmluYWxEZXNpcmVkV2lkdGgsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxpZ24uZW5kc1dpdGgoJ1lNYXgnKSAmJiAoaXNNZWV0TWluWCB8fCBpc1NsaWNlTWF4WCkpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLSBmaW5hbERlc2lyZWRIZWlnaHQpO1xuICAgICAgfVxuICAgIH0gLy8gc2NhbGVcblxuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIGFsaWduID09PSAnbm9uZSc6XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIG1lZXRPclNsaWNlID09PSAnbWVldCc6XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZU1pbiwgc2NhbGVNaW4pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJzpcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlTWF4LCBzY2FsZU1heCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH0gLy8gdHJhbnNsYXRlXG5cblxuICAgIGN0eC50cmFuc2xhdGUoLW1pblgsIC1taW5ZKTtcbiAgfVxuXG4gIHN0YXJ0KGVsZW1lbnQpIHtcbiAgICB2YXIge1xuICAgICAgZW5hYmxlUmVkcmF3ID0gZmFsc2UsXG4gICAgICBpZ25vcmVNb3VzZSA9IGZhbHNlLFxuICAgICAgaWdub3JlQW5pbWF0aW9uID0gZmFsc2UsXG4gICAgICBpZ25vcmVEaW1lbnNpb25zID0gZmFsc2UsXG4gICAgICBpZ25vcmVDbGVhciA9IGZhbHNlLFxuICAgICAgZm9yY2VSZWRyYXcsXG4gICAgICBzY2FsZVdpZHRoLFxuICAgICAgc2NhbGVIZWlnaHQsXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBGUkFNRVJBVEUsXG4gICAgICBtb3VzZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIEZSQU1FUkFURTtcbiAgICB0aGlzLmZyYW1lRHVyYXRpb24gPSBmcmFtZUR1cmF0aW9uO1xuICAgIHRoaXMucmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmVSZWFkeSA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgIHRoaXMucmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgaWYgKCFlbmFibGVSZWRyYXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgdGhlbiA9IG5vdztcbiAgICB2YXIgZGVsdGEgPSAwO1xuXG4gICAgdmFyIHRpY2sgPSAoKSA9PiB7XG4gICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgZGVsdGEgPSBub3cgLSB0aGVuO1xuXG4gICAgICBpZiAoZGVsdGEgPj0gZnJhbWVEdXJhdGlvbikge1xuICAgICAgICB0aGVuID0gbm93IC0gZGVsdGEgJSBmcmFtZUR1cmF0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZShpZ25vcmVBbmltYXRpb24sIGZvcmNlUmVkcmF3KSkge1xuICAgICAgICAgIHRoaXMucmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgbW91c2UucnVuRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnRlcnZhbElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgIH07XG5cbiAgICBpZiAoIWlnbm9yZU1vdXNlKSB7XG4gICAgICBtb3VzZS5zdGFydCgpO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbmNlbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgdGhpcy5pbnRlcnZhbElkID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm1vdXNlLnN0b3AoKTtcbiAgfVxuXG4gIHNob3VsZFVwZGF0ZShpZ25vcmVBbmltYXRpb24sIGZvcmNlUmVkcmF3KSB7XG4gICAgLy8gbmVlZCB1cGRhdGUgZnJvbSBhbmltYXRpb25zP1xuICAgIGlmICghaWdub3JlQW5pbWF0aW9uKSB7XG4gICAgICB2YXIge1xuICAgICAgICBmcmFtZUR1cmF0aW9uXG4gICAgICB9ID0gdGhpcztcbiAgICAgIHZhciBzaG91bGRVcGRhdGUgPSB0aGlzLmFuaW1hdGlvbnMucmVkdWNlKChzaG91bGRVcGRhdGUsIGFuaW1hdGlvbikgPT4gYW5pbWF0aW9uLnVwZGF0ZShmcmFtZUR1cmF0aW9uKSB8fCBzaG91bGRVcGRhdGUsIGZhbHNlKTtcblxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIG5lZWQgdXBkYXRlIGZyb20gcmVkcmF3P1xuXG5cbiAgICBpZiAodHlwZW9mIGZvcmNlUmVkcmF3ID09PSAnZnVuY3Rpb24nICYmIGZvcmNlUmVkcmF3KCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1JlYWR5TG9jayAmJiB0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBuZWVkIHVwZGF0ZSBmcm9tIG1vdXNlIGV2ZW50cz9cblxuXG4gICAgaWYgKHRoaXMubW91c2UuaGFzRXZlbnRzKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICB2YXIge1xuICAgICAgQ0xJRU5UX1dJRFRILFxuICAgICAgQ0xJRU5UX0hFSUdIVCxcbiAgICAgIHZpZXdQb3J0LFxuICAgICAgY3R4LFxuICAgICAgaXNGaXJzdFJlbmRlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgIHZpZXdQb3J0LmNsZWFyKCk7XG5cbiAgICBpZiAoY2FudmFzLndpZHRoICYmIGNhbnZhcy5oZWlnaHQpIHtcbiAgICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld1BvcnQuc2V0Q3VycmVudChDTElFTlRfV0lEVEgsIENMSUVOVF9IRUlHSFQpO1xuICAgIH1cblxuICAgIHZhciB3aWR0aFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnd2lkdGgnKTtcbiAgICB2YXIgaGVpZ2h0U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdoZWlnaHQnKTtcblxuICAgIGlmICghaWdub3JlRGltZW5zaW9ucyAmJiAoaXNGaXJzdFJlbmRlciB8fCB0eXBlb2Ygc2NhbGVXaWR0aCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHNjYWxlSGVpZ2h0ICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIC8vIHNldCBjYW52YXMgc2l6ZVxuICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aFN0eWxlLmdldFBpeGVscygneCcpO1xuXG4gICAgICAgIGlmIChjYW52YXMuc3R5bGUpIHtcbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChjYW52YXMud2lkdGgsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodFN0eWxlLmdldFBpeGVscygneScpO1xuXG4gICAgICAgIGlmIChjYW52YXMuc3R5bGUpIHtcbiAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoY2FudmFzLmhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjV2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGggfHwgY2FudmFzLndpZHRoO1xuICAgIHZhciBjSGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCB8fCBjYW52YXMuaGVpZ2h0O1xuXG4gICAgaWYgKGlnbm9yZURpbWVuc2lvbnMgJiYgd2lkdGhTdHlsZS5oYXNWYWx1ZSgpICYmIGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGNXaWR0aCA9IHdpZHRoU3R5bGUuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICBjSGVpZ2h0ID0gaGVpZ2h0U3R5bGUuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgfVxuXG4gICAgdmlld1BvcnQuc2V0Q3VycmVudChjV2lkdGgsIGNIZWlnaHQpO1xuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXRYID09PSAnbnVtYmVyJykge1xuICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gnLCB0cnVlKS5zZXRWYWx1ZShvZmZzZXRYKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9mZnNldFkgPT09ICdudW1iZXInKSB7XG4gICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgneScsIHRydWUpLnNldFZhbHVlKG9mZnNldFkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2NhbGVXaWR0aCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNjYWxlSGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHZpZXdCb3ggPSB0b051bWJlcnMoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRTdHJpbmcoKSk7XG4gICAgICB2YXIgeFJhdGlvID0gMDtcbiAgICAgIHZhciB5UmF0aW8gPSAwO1xuXG4gICAgICBpZiAodHlwZW9mIHNjYWxlV2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBfd2lkdGhTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3dpZHRoJyk7XG5cbiAgICAgICAgaWYgKF93aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB4UmF0aW8gPSBfd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKSAvIHNjYWxlV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHZpZXdCb3hbMl0pKSB7XG4gICAgICAgICAgeFJhdGlvID0gdmlld0JveFsyXSAvIHNjYWxlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzY2FsZUhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIF9oZWlnaHRTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ2hlaWdodCcpO1xuXG4gICAgICAgIGlmIChfaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHlSYXRpbyA9IF9oZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKSAvIHNjYWxlSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTih2aWV3Qm94WzNdKSkge1xuICAgICAgICAgIHlSYXRpbyA9IHZpZXdCb3hbM10gLyBzY2FsZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXhSYXRpbykge1xuICAgICAgICB4UmF0aW8gPSB5UmF0aW87XG4gICAgICB9XG5cbiAgICAgIGlmICgheVJhdGlvKSB7XG4gICAgICAgIHlSYXRpbyA9IHhSYXRpbztcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSkuc2V0VmFsdWUoc2NhbGVXaWR0aCk7XG4gICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSkuc2V0VmFsdWUoc2NhbGVIZWlnaHQpO1xuICAgICAgdmFyIHRyYW5zZm9ybVN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgndHJhbnNmb3JtJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB0cmFuc2Zvcm1TdHlsZS5zZXRWYWx1ZShcIlwiLmNvbmNhdCh0cmFuc2Zvcm1TdHlsZS5nZXRTdHJpbmcoKSwgXCIgc2NhbGUoXCIpLmNvbmNhdCgxLjAgLyB4UmF0aW8sIFwiLCBcIikuY29uY2F0KDEuMCAvIHlSYXRpbywgXCIpXCIpKTtcbiAgICB9IC8vIGNsZWFyIGFuZCByZW5kZXJcblxuXG4gICAgaWYgKCFpZ25vcmVDbGVhcikge1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjV2lkdGgsIGNIZWlnaHQpO1xuICAgIH1cblxuICAgIGVsZW1lbnQucmVuZGVyKGN0eCk7XG5cbiAgICBpZiAoaXNGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5pc0ZpcnN0UmVuZGVyID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbn1cblNjcmVlbi5kZWZhdWx0V2luZG93ID0gZGVmYXVsdFdpbmRvdztcblNjcmVlbi5kZWZhdWx0RmV0Y2ggPSBkZWZhdWx0RmV0Y2gkMTtcblxudmFyIHtcbiAgZGVmYXVsdEZldGNoXG59ID0gU2NyZWVuO1xudmFyIERlZmF1bHRET01QYXJzZXIgPSB0eXBlb2YgRE9NUGFyc2VyICE9PSAndW5kZWZpbmVkJyA/IERPTVBhcnNlciA6IG51bGw7XG5jbGFzcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIge1xuICAgICAgZmV0Y2ggPSBkZWZhdWx0RmV0Y2gsXG4gICAgICBET01QYXJzZXIgPSBEZWZhdWx0RE9NUGFyc2VyXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgIHRoaXMuRE9NUGFyc2VyID0gRE9NUGFyc2VyO1xuICB9XG5cbiAgcGFyc2UocmVzb3VyY2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAocmVzb3VyY2Uuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wYXJzZUZyb21TdHJpbmcocmVzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMubG9hZChyZXNvdXJjZSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHBhcnNlRnJvbVN0cmluZyh4bWwpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHRoaXMuRE9NUGFyc2VyKCk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tEb2N1bWVudChwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ2ltYWdlL3N2Zyt4bWwnKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGVja0RvY3VtZW50KHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAndGV4dC94bWwnKSk7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tEb2N1bWVudChkb2N1bWVudCkge1xuICAgIHZhciBwYXJzZXJFcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpWzBdO1xuXG4gICAgaWYgKHBhcnNlckVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VyRXJyb3IudGV4dENvbnRlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBkb2N1bWVudDtcbiAgfVxuXG4gIGxvYWQodXJsKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciByZXNwb25zZSA9IHlpZWxkIF90aGlzMi5mZXRjaCh1cmwpO1xuICAgICAgdmFyIHhtbCA9IHlpZWxkIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHJldHVybiBfdGhpczIucGFyc2VGcm9tU3RyaW5nKHhtbCk7XG4gICAgfSkoKTtcbiAgfVxuXG59XG5cbmNsYXNzIFRyYW5zbGF0ZSB7XG4gIGNvbnN0cnVjdG9yKF8sIHBvaW50KSB7XG4gICAgdGhpcy50eXBlID0gJ3RyYW5zbGF0ZSc7XG4gICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgdGhpcy5wb2ludCA9IFBvaW50LnBhcnNlKHBvaW50KTtcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzLnBvaW50O1xuICAgIGN0eC50cmFuc2xhdGUoeCB8fCAwLjAsIHkgfHwgMC4wKTtcbiAgfVxuXG4gIHVuYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMucG9pbnQ7XG4gICAgY3R4LnRyYW5zbGF0ZSgtMS4wICogeCB8fCAwLjAsIC0xLjAgKiB5IHx8IDAuMCk7XG4gIH1cblxuICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5wb2ludDtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgeCB8fCAwLjAsIHkgfHwgMC4wXSk7XG4gIH1cblxufVxuXG5jbGFzcyBSb3RhdGUge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgcm90YXRlLCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICB0aGlzLnR5cGUgPSAncm90YXRlJztcbiAgICB0aGlzLmFuZ2xlID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblggPSBudWxsO1xuICAgIHRoaXMub3JpZ2luWSA9IG51bGw7XG4gICAgdGhpcy5jeCA9IDA7XG4gICAgdGhpcy5jeSA9IDA7XG4gICAgdmFyIG51bWJlcnMgPSB0b051bWJlcnMocm90YXRlKTtcbiAgICB0aGlzLmFuZ2xlID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnYW5nbGUnLCBudW1iZXJzWzBdKTtcbiAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICAgIHRoaXMuY3ggPSBudW1iZXJzWzFdIHx8IDA7XG4gICAgdGhpcy5jeSA9IG51bWJlcnNbMl0gfHwgMDtcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBjeCxcbiAgICAgIGN5LFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICBhbmdsZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0eCA9IGN4ICsgb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgdHkgPSBjeSArIG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC5yb3RhdGUoYW5nbGUuZ2V0UmFkaWFucygpKTtcbiAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgfVxuXG4gIHVuYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGN4LFxuICAgICAgY3ksXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIGFuZ2xlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHR4ID0gY3ggKyBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgIHZhciB0eSA9IGN5ICsgb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgY3R4LnJvdGF0ZSgtMS4wICogYW5nbGUuZ2V0UmFkaWFucygpKTtcbiAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgfVxuXG4gIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgIHZhciB7XG4gICAgICBjeCxcbiAgICAgIGN5LFxuICAgICAgYW5nbGVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcmFkID0gYW5nbGUuZ2V0UmFkaWFucygpO1xuICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCBjeCB8fCAwLjAsIGN5IHx8IDAuMCAvLyB0aGlzLnAueVxuICAgIF0pO1xuICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFtNYXRoLmNvcyhyYWQpLCBNYXRoLnNpbihyYWQpLCAtTWF0aC5zaW4ocmFkKSwgTWF0aC5jb3MocmFkKSwgMCwgMF0pO1xuICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCAtY3ggfHwgMC4wLCAtY3kgfHwgMC4wIC8vIC10aGlzLnAueVxuICAgIF0pO1xuICB9XG5cbn1cblxuY2xhc3MgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihfLCBzY2FsZSwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdGhpcy50eXBlID0gJ3NjYWxlJztcbiAgICB0aGlzLnNjYWxlID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblggPSBudWxsO1xuICAgIHRoaXMub3JpZ2luWSA9IG51bGw7XG4gICAgdmFyIHNjYWxlU2l6ZSA9IFBvaW50LnBhcnNlU2NhbGUoc2NhbGUpOyAvLyBXb3JrYXJvdW5kIGZvciBub2RlLWNhbnZhc1xuXG4gICAgaWYgKHNjYWxlU2l6ZS54ID09PSAwIHx8IHNjYWxlU2l6ZS55ID09PSAwKSB7XG4gICAgICBzY2FsZVNpemUueCA9IFBTRVVET19aRVJPO1xuICAgICAgc2NhbGVTaXplLnkgPSBQU0VVRE9fWkVSTztcbiAgICB9XG5cbiAgICB0aGlzLnNjYWxlID0gc2NhbGVTaXplO1xuICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICB0aGlzLm9yaWdpblkgPSB0cmFuc2Zvcm1PcmlnaW5bMV07XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgc2NhbGU6IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSxcbiAgICAgIG9yaWdpblgsXG4gICAgICBvcmlnaW5ZXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBjdHguc2NhbGUoeCwgeSB8fCB4KTtcbiAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgfVxuXG4gIHVuYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0sXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgY3R4LnNjYWxlKDEuMCAvIHgsIDEuMCAvIHkgfHwgeCk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5zY2FsZTtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbeCB8fCAwLjAsIDAsIDAsIHkgfHwgMC4wLCAwLCAwXSk7XG4gIH1cblxufVxuXG5jbGFzcyBNYXRyaXgge1xuICBjb25zdHJ1Y3RvcihfLCBtYXRyaXgsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHRoaXMudHlwZSA9ICdtYXRyaXgnO1xuICAgIHRoaXMubWF0cml4ID0gW107XG4gICAgdGhpcy5vcmlnaW5YID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblkgPSBudWxsO1xuICAgIHRoaXMubWF0cml4ID0gdG9OdW1iZXJzKG1hdHJpeCk7XG4gICAgdGhpcy5vcmlnaW5YID0gdHJhbnNmb3JtT3JpZ2luWzBdO1xuICAgIHRoaXMub3JpZ2luWSA9IHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIG1hdHJpeFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgY3R4LnRyYW5zZm9ybShtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLCBtYXRyaXhbM10sIG1hdHJpeFs0XSwgbWF0cml4WzVdKTtcbiAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgfVxuXG4gIHVuYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIG9yaWdpblgsXG4gICAgICBvcmlnaW5ZLFxuICAgICAgbWF0cml4XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGEgPSBtYXRyaXhbMF07XG4gICAgdmFyIGIgPSBtYXRyaXhbMl07XG4gICAgdmFyIGMgPSBtYXRyaXhbNF07XG4gICAgdmFyIGQgPSBtYXRyaXhbMV07XG4gICAgdmFyIGUgPSBtYXRyaXhbM107XG4gICAgdmFyIGYgPSBtYXRyaXhbNV07XG4gICAgdmFyIGcgPSAwLjA7XG4gICAgdmFyIGggPSAwLjA7XG4gICAgdmFyIGkgPSAxLjA7XG4gICAgdmFyIGRldCA9IDEgLyAoYSAqIChlICogaSAtIGYgKiBoKSAtIGIgKiAoZCAqIGkgLSBmICogZykgKyBjICogKGQgKiBoIC0gZSAqIGcpKTtcbiAgICB2YXIgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgIHZhciB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC50cmFuc2Zvcm0oZGV0ICogKGUgKiBpIC0gZiAqIGgpLCBkZXQgKiAoZiAqIGcgLSBkICogaSksIGRldCAqIChjICogaCAtIGIgKiBpKSwgZGV0ICogKGEgKiBpIC0gYyAqIGcpLCBkZXQgKiAoYiAqIGYgLSBjICogZSksIGRldCAqIChjICogZCAtIGEgKiBmKSk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybSh0aGlzLm1hdHJpeCk7XG4gIH1cblxufVxuXG5jbGFzcyBTa2V3IGV4dGVuZHMgTWF0cml4IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHN1cGVyKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIHRoaXMudHlwZSA9ICdza2V3JztcbiAgICB0aGlzLmFuZ2xlID0gbnVsbDtcbiAgICB0aGlzLmFuZ2xlID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnYW5nbGUnLCBza2V3KTtcbiAgfVxuXG59XG5cbmNsYXNzIFNrZXdYIGV4dGVuZHMgU2tldyB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBzdXBlcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICB0aGlzLnR5cGUgPSAnc2tld1gnO1xuICAgIHRoaXMubWF0cml4ID0gWzEsIDAsIE1hdGgudGFuKHRoaXMuYW5nbGUuZ2V0UmFkaWFucygpKSwgMSwgMCwgMF07XG4gIH1cblxufVxuXG5jbGFzcyBTa2V3WSBleHRlbmRzIFNrZXcge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgdGhpcy50eXBlID0gJ3NrZXdZJztcbiAgICB0aGlzLm1hdHJpeCA9IFsxLCBNYXRoLnRhbih0aGlzLmFuZ2xlLmdldFJhZGlhbnMoKSksIDAsIDEsIDAsIDBdO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1zKHRyYW5zZm9ybSkge1xuICByZXR1cm4gY29tcHJlc3NTcGFjZXModHJhbnNmb3JtKS50cmltKCkucmVwbGFjZSgvXFwpKFthLXpBLVpdKS9nLCAnKSAkMScpLnJlcGxhY2UoL1xcKShcXHM/LFxccz8pL2csICcpICcpLnNwbGl0KC9cXHMoPz1bYS16XSkvKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gIHZhciBbdHlwZSwgdmFsdWVdID0gdHJhbnNmb3JtLnNwbGl0KCcoJyk7XG4gIHJldHVybiBbdHlwZS50cmltKCksIHZhbHVlLnRyaW0oKS5yZXBsYWNlKCcpJywgJycpXTtcbn1cblxuY2xhc3MgVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHRyYW5zZm9ybSwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuICAgIHZhciBkYXRhID0gcGFyc2VUcmFuc2Zvcm1zKHRyYW5zZm9ybSk7XG4gICAgZGF0YS5mb3JFYWNoKHRyYW5zZm9ybSA9PiB7XG4gICAgICBpZiAodHJhbnNmb3JtID09PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgW3R5cGUsIHZhbHVlXSA9IHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICB2YXIgVHJhbnNmb3JtVHlwZSA9IFRyYW5zZm9ybS50cmFuc2Zvcm1UeXBlc1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBUcmFuc2Zvcm1UeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMucHVzaChuZXcgVHJhbnNmb3JtVHlwZSh0aGlzLmRvY3VtZW50LCB2YWx1ZSwgdHJhbnNmb3JtT3JpZ2luKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGVsZW1lbnQpIHtcbiAgICB2YXIgdHJhbnNmb3JtU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0nLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdmFyIFt0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHksIHRyYW5zZm9ybU9yaWdpbllQcm9wZXJ0eSA9IHRyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eV0gPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgZmFsc2UsIHRydWUpLnNwbGl0KCk7XG4gICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IFt0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHksIHRyYW5zZm9ybU9yaWdpbllQcm9wZXJ0eV07XG5cbiAgICBpZiAodHJhbnNmb3JtU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oZG9jdW1lbnQsIHRyYW5zZm9ybVN0eWxlLmdldFN0cmluZygpLCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHRyYW5zZm9ybXNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgbGVuID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0cmFuc2Zvcm1zW2ldLmFwcGx5KGN0eCk7XG4gICAgfVxuICB9XG5cbiAgdW5hcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgdHJhbnNmb3Jtc1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdHJhbnNmb3Jtc1tpXS51bmFwcGx5KGN0eCk7XG4gICAgfVxuICB9IC8vIFRPRE86IGFwcGx5VG9Qb2ludCB1bnVzZWQgLi4uIHJlbW92ZT9cblxuXG4gIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgIHZhciB7XG4gICAgICB0cmFuc2Zvcm1zXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdHJhbnNmb3Jtc1tpXS5hcHBseVRvUG9pbnQocG9pbnQpO1xuICAgIH1cbiAgfVxuXG59XG5UcmFuc2Zvcm0udHJhbnNmb3JtVHlwZXMgPSB7XG4gIHRyYW5zbGF0ZTogVHJhbnNsYXRlLFxuICByb3RhdGU6IFJvdGF0ZSxcbiAgc2NhbGU6IFNjYWxlLFxuICBtYXRyaXg6IE1hdHJpeCxcbiAgc2tld1g6IFNrZXdYLFxuICBza2V3WTogU2tld1lcbn07XG5cbmNsYXNzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSkge1xuICAgIHZhciBjYXB0dXJlVGV4dE5vZGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLmNhcHR1cmVUZXh0Tm9kZXMgPSBjYXB0dXJlVGV4dE5vZGVzO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IHt9O1xuICAgIHRoaXMuYW5pbWF0aW9uRnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5hbmltYXRpb25Gcm96ZW5WYWx1ZSA9ICcnO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgLy8gRUxFTUVOVF9OT0RFXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBhZGQgYXR0cmlidXRlc1xuXG5cbiAgICBBcnJheS5mcm9tKG5vZGUuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyaWJ1dGUgPT4ge1xuICAgICAgdmFyIG5vZGVOYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubm9kZU5hbWUpO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW25vZGVOYW1lXSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbm9kZU5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7IC8vIGFkZCBpbmxpbmUgc3R5bGVzXG5cbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykuaGFzVmFsdWUoKSkge1xuICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpLmdldFN0cmluZygpLnNwbGl0KCc7JykubWFwKF8gPT4gXy50cmltKCkpO1xuICAgICAgc3R5bGVzLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIFtuYW1lLCB2YWx1ZV0gPSBzdHlsZS5zcGxpdCgnOicpLm1hcChfID0+IF8udHJpbSgpKTtcbiAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBkZWZpbml0aW9uc1xuICAgIH0gPSBkb2N1bWVudDtcbiAgICB2YXIgaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTsgLy8gYWRkIGlkXG5cbiAgICBpZiAoaWQuaGFzVmFsdWUoKSkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uc1tpZC5nZXRTdHJpbmcoKV0pIHtcbiAgICAgICAgZGVmaW5pdGlvbnNbaWQuZ2V0U3RyaW5nKCldID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkTm9kZSk7IC8vIEVMRU1FTlRfTk9ERVxuICAgICAgfSBlbHNlIGlmIChjYXB0dXJlVGV4dE5vZGVzICYmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDMgfHwgY2hpbGROb2RlLm5vZGVUeXBlID09PSA0KSkge1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZE5vZGUpO1xuXG4gICAgICAgIGlmICh0ZXh0Tm9kZS5nZXRUZXh0KCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodGV4dE5vZGUpOyAvLyBURVhUX05PREVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICB2YXIgY3JlYXRlSWZOb3RFeGlzdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBhdHRyID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgaWYgKCFhdHRyICYmIGNyZWF0ZUlmTm90RXhpc3RzKSB7XG4gICAgICB2YXIgX2F0dHIgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgbmFtZSwgJycpO1xuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBfYXR0cjtcbiAgICAgIHJldHVybiBfYXR0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0ciB8fCBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgfVxuXG4gIGdldEhyZWZBdHRyaWJ1dGUoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnIHx8IGtleS5lbmRzV2l0aCgnOmhyZWYnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb3BlcnR5LmVtcHR5KHRoaXMuZG9jdW1lbnQpO1xuICB9XG5cbiAgZ2V0U3R5bGUobmFtZSkge1xuICAgIHZhciBjcmVhdGVJZk5vdEV4aXN0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdmFyIHNraXBBbmNlc3RvcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGVzW25hbWVdO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgdmFyIGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgIGlmIChhdHRyICE9PSBudWxsICYmIGF0dHIgIT09IHZvaWQgMCAmJiBhdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gYXR0cjsgLy8gbW92ZSB1cCB0byBtZSB0byBjYWNoZVxuXG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG5cbiAgICBpZiAoIXNraXBBbmNlc3RvcnMpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudFN0eWxlID0gcGFyZW50LmdldFN0eWxlKG5hbWUpO1xuXG4gICAgICAgIGlmIChwYXJlbnRTdHlsZSAhPT0gbnVsbCAmJiBwYXJlbnRTdHlsZSAhPT0gdm9pZCAwICYmIHBhcmVudFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50U3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3JlYXRlSWZOb3RFeGlzdHMpIHtcbiAgICAgIHZhciBfc3R5bGUgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgbmFtZSwgJycpO1xuXG4gICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IF9zdHlsZTtcbiAgICAgIHJldHVybiBfc3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlIHx8IFByb3BlcnR5LmVtcHR5KHRoaXMuZG9jdW1lbnQpO1xuICB9XG5cbiAgcmVuZGVyKGN0eCkge1xuICAgIC8vIGRvbid0IHJlbmRlciBkaXNwbGF5PW5vbmVcbiAgICAvLyBkb24ndCByZW5kZXIgdmlzaWJpbGl0eT1oaWRkZW5cbiAgICBpZiAodGhpcy5nZXRTdHlsZSgnZGlzcGxheScpLmdldFN0cmluZygpID09PSAnbm9uZScgfHwgdGhpcy5nZXRTdHlsZSgndmlzaWJpbGl0eScpLmdldFN0cmluZygpID09PSAnaGlkZGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBpZiAodGhpcy5nZXRTdHlsZSgnbWFzaycpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIC8vIG1hc2tcbiAgICAgIHZhciBtYXNrID0gdGhpcy5nZXRTdHlsZSgnbWFzaycpLmdldERlZmluaXRpb24oKTtcblxuICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoY3R4KTtcbiAgICAgICAgbWFzay5hcHBseShjdHgsIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5nZXRTdHlsZSgnZmlsdGVyJykuZ2V0VmFsdWUoJ25vbmUnKSAhPT0gJ25vbmUnKSB7XG4gICAgICAvLyBmaWx0ZXJcbiAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmdldFN0eWxlKCdmaWx0ZXInKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoY3R4KTtcbiAgICAgICAgZmlsdGVyLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dChjdHgpO1xuICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihjdHgpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgc2V0Q29udGV4dChfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxuICBhcHBseUVmZmVjdHMoY3R4KSB7XG4gICAgLy8gdHJhbnNmb3JtXG4gICAgdmFyIHRyYW5zZm9ybSA9IFRyYW5zZm9ybS5mcm9tRWxlbWVudCh0aGlzLmRvY3VtZW50LCB0aGlzKTtcblxuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHRyYW5zZm9ybS5hcHBseShjdHgpO1xuICAgIH0gLy8gY2xpcFxuXG5cbiAgICB2YXIgY2xpcFBhdGhTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdjbGlwLXBhdGgnLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICBpZiAoY2xpcFBhdGhTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgdmFyIGNsaXAgPSBjbGlwUGF0aFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgIGNsaXAuYXBwbHkoY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbGVhckNvbnRleHQoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGNoaWxkLnJlbmRlcihjdHgpO1xuICAgIH0pO1xuICB9XG5cbiAgYWRkQ2hpbGQoY2hpbGROb2RlKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGROb2RlIGluc3RhbmNlb2YgRWxlbWVudCA/IGNoaWxkTm9kZSA6IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjaGlsZE5vZGUpO1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cbiAgICBpZiAoIUVsZW1lbnQuaWdub3JlQ2hpbGRUeXBlcy5pbmNsdWRlcyhjaGlsZC50eXBlKSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cblxuICBtYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICB2YXIgX25vZGUkZ2V0QXR0cmlidXRlO1xuXG4gICAgdmFyIHtcbiAgICAgIG5vZGVcbiAgICB9ID0gdGhpcztcblxuICAgIGlmICh0eXBlb2Ygbm9kZS5tYXRjaGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVDbGFzc2VzID0gKF9ub2RlJGdldEF0dHJpYnV0ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRnZXRBdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGdldEF0dHJpYnV0ZS5jYWxsKG5vZGUsICdjbGFzcycpO1xuXG4gICAgaWYgKCFzdHlsZUNsYXNzZXMgfHwgc3R5bGVDbGFzc2VzID09PSAnJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZUNsYXNzZXMuc3BsaXQoJyAnKS5zb21lKHN0eWxlQ2xhc3MgPT4gXCIuXCIuY29uY2F0KHN0eWxlQ2xhc3MpID09PSBzZWxlY3Rvcik7XG4gIH1cblxuICBhZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCkge1xuICAgIHZhciB7XG4gICAgICBzdHlsZXMsXG4gICAgICBzdHlsZXNTcGVjaWZpY2l0eVxuICAgIH0gPSB0aGlzLmRvY3VtZW50O1xuXG4gICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0AnKSAmJiB0aGlzLm1hdGNoZXNTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW3NlbGVjdG9yXTtcbiAgICAgICAgdmFyIHNwZWNpZmljaXR5ID0gc3R5bGVzU3BlY2lmaWNpdHlbc2VsZWN0b3JdO1xuXG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1NwZWNpZmljaXR5ID0gdGhpcy5zdHlsZXNTcGVjaWZpY2l0eVtuYW1lXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleGlzdGluZ1NwZWNpZmljaXR5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBleGlzdGluZ1NwZWNpZmljaXR5ID0gJzAwMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzcGVjaWZpY2l0eSA+PSBleGlzdGluZ1NwZWNpZmljaXR5KSB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzU3BlY2lmaWNpdHlbbmFtZV0gPSBzcGVjaWZpY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW1vdmVTdHlsZXMoZWxlbWVudCwgaWdub3JlU3R5bGVzKSB7XG4gICAgdmFyIHRvUmVzdG9yZSA9IGlnbm9yZVN0eWxlcy5yZWR1Y2UoKHRvUmVzdG9yZSwgbmFtZSkgPT4ge1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IGVsZW1lbnQuZ2V0U3R5bGUobmFtZSk7XG5cbiAgICAgIGlmICghc3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRvUmVzdG9yZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gc3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgc3R5bGVQcm9wLnNldFZhbHVlKCcnKTtcbiAgICAgIHJldHVybiBbLi4udG9SZXN0b3JlLCBbbmFtZSwgdmFsdWVdXTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHRvUmVzdG9yZTtcbiAgfVxuXG4gIHJlc3RvcmVTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgc3R5bGVzLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICB2YXIgW25hbWUsIHZhbHVlXSA9IF9yZWY7XG4gICAgICBlbGVtZW50LmdldFN0eWxlKG5hbWUsIHRydWUpLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlzRmlyc3RDaGlsZCgpIHtcbiAgICB2YXIgX3RoaXMkcGFyZW50O1xuXG4gICAgcmV0dXJuICgoX3RoaXMkcGFyZW50ID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF90aGlzJHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcykpID09PSAwO1xuICB9XG5cbn1cbkVsZW1lbnQuaWdub3JlQ2hpbGRUeXBlcyA9IFsndGl0bGUnXTtcblxuY2xhc3MgVW5rbm93bkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiB3cmFwRm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gIHZhciB0cmltbWVkID0gZm9udEZhbWlseS50cmltKCk7XG4gIHJldHVybiAvXignfFwiKS8udGVzdCh0cmltbWVkKSA/IHRyaW1tZWQgOiBcIlxcXCJcIi5jb25jYXQodHJpbW1lZCwgXCJcXFwiXCIpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgPyBmb250RmFtaWx5IDogZm9udEZhbWlseS50cmltKCkuc3BsaXQoJywnKS5tYXAod3JhcEZvbnRGYW1pbHkpLmpvaW4oJywnKTtcbn1cbi8qKlxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC1zdHlsZVxyXG4gKiBAcGFyYW0gZm9udFN0eWxlXHJcbiAqIEByZXR1cm5zIENTUyBmb250IHN0eWxlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlRm9udFN0eWxlKGZvbnRTdHlsZSkge1xuICBpZiAoIWZvbnRTdHlsZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0YXJnZXRGb250U3R5bGUgPSBmb250U3R5bGUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoICh0YXJnZXRGb250U3R5bGUpIHtcbiAgICBjYXNlICdub3JtYWwnOlxuICAgIGNhc2UgJ2l0YWxpYyc6XG4gICAgY2FzZSAnb2JsaXF1ZSc6XG4gICAgY2FzZSAnaW5oZXJpdCc6XG4gICAgY2FzZSAnaW5pdGlhbCc6XG4gICAgY2FzZSAndW5zZXQnOlxuICAgICAgcmV0dXJuIHRhcmdldEZvbnRTdHlsZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoL15vYmxpcXVlXFxzKygtfClcXGQrZGVnJC8udGVzdCh0YXJnZXRGb250U3R5bGUpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRGb250U3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXdlaWdodFxyXG4gKiBAcGFyYW0gZm9udFdlaWdodFxyXG4gKiBAcmV0dXJucyBDU1MgZm9udCB3ZWlnaHQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHByZXBhcmVGb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgaWYgKCFmb250V2VpZ2h0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIHRhcmdldEZvbnRXZWlnaHQgPSBmb250V2VpZ2h0LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAodGFyZ2V0Rm9udFdlaWdodCkge1xuICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgY2FzZSAnYm9sZCc6XG4gICAgY2FzZSAnbGlnaHRlcic6XG4gICAgY2FzZSAnYm9sZGVyJzpcbiAgICBjYXNlICdpbmhlcml0JzpcbiAgICBjYXNlICdpbml0aWFsJzpcbiAgICBjYXNlICd1bnNldCc6XG4gICAgICByZXR1cm4gdGFyZ2V0Rm9udFdlaWdodDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoL15bXFxkLl0rJC8udGVzdCh0YXJnZXRGb250V2VpZ2h0KSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFdlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmNsYXNzIEZvbnQge1xuICBjb25zdHJ1Y3Rvcihmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCkge1xuICAgIHZhciBpbmhlcml0Rm9udCA9IGluaGVyaXQgPyB0eXBlb2YgaW5oZXJpdCA9PT0gJ3N0cmluZycgPyBGb250LnBhcnNlKGluaGVyaXQpIDogaW5oZXJpdCA6IHt9O1xuICAgIHRoaXMuZm9udEZhbWlseSA9IGZvbnRGYW1pbHkgfHwgaW5oZXJpdEZvbnQuZm9udEZhbWlseTtcbiAgICB0aGlzLmZvbnRTaXplID0gZm9udFNpemUgfHwgaW5oZXJpdEZvbnQuZm9udFNpemU7XG4gICAgdGhpcy5mb250U3R5bGUgPSBmb250U3R5bGUgfHwgaW5oZXJpdEZvbnQuZm9udFN0eWxlO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQgfHwgaW5oZXJpdEZvbnQuZm9udFdlaWdodDtcbiAgICB0aGlzLmZvbnRWYXJpYW50ID0gZm9udFZhcmlhbnQgfHwgaW5oZXJpdEZvbnQuZm9udFZhcmlhbnQ7XG4gIH1cblxuICBzdGF0aWMgcGFyc2UoKSB7XG4gICAgdmFyIGZvbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgIHZhciBpbmhlcml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGZvbnRTdHlsZSA9ICcnO1xuICAgIHZhciBmb250VmFyaWFudCA9ICcnO1xuICAgIHZhciBmb250V2VpZ2h0ID0gJyc7XG4gICAgdmFyIGZvbnRTaXplID0gJyc7XG4gICAgdmFyIGZvbnRGYW1pbHkgPSAnJztcbiAgICB2YXIgcGFydHMgPSBjb21wcmVzc1NwYWNlcyhmb250KS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICB2YXIgc2V0ID0ge1xuICAgICAgZm9udFNpemU6IGZhbHNlLFxuICAgICAgZm9udFN0eWxlOiBmYWxzZSxcbiAgICAgIGZvbnRXZWlnaHQ6IGZhbHNlLFxuICAgICAgZm9udFZhcmlhbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgIXNldC5mb250U3R5bGUgJiYgRm9udC5zdHlsZXMuaW5jbHVkZXMocGFydCk6XG4gICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgZm9udFN0eWxlID0gcGFydDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICFzZXQuZm9udFZhcmlhbnQgJiYgRm9udC52YXJpYW50cy5pbmNsdWRlcyhwYXJ0KTpcbiAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBmb250VmFyaWFudCA9IHBhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICFzZXQuZm9udFdlaWdodCAmJiBGb250LndlaWdodHMuaW5jbHVkZXMocGFydCk6XG4gICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgZm9udFdlaWdodCA9IHBhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICBzZXQuZm9udFdlaWdodCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAhc2V0LmZvbnRTaXplOlxuICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIFtmb250U2l6ZV0gPSBwYXJ0LnNwbGl0KCcvJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICBzZXQuZm9udFdlaWdodCA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRTaXplID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgKz0gcGFydDtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEZvbnQoZm9udFN0eWxlLCBmb250VmFyaWFudCwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGluaGVyaXQpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFtwcmVwYXJlRm9udFN0eWxlKHRoaXMuZm9udFN0eWxlKSwgdGhpcy5mb250VmFyaWFudCwgcHJlcGFyZUZvbnRXZWlnaHQodGhpcy5mb250V2VpZ2h0KSwgdGhpcy5mb250U2l6ZSwgLy8gV3JhcCBmb250RmFtaWx5IG9ubHkgb24gbm9kZWpzIGFuZCBvbmx5IGZvciBjYW52YXMuY3R4XG4gICAgcHJlcGFyZUZvbnRGYW1pbHkodGhpcy5mb250RmFtaWx5KV0uam9pbignICcpLnRyaW0oKTtcbiAgfVxuXG59XG5Gb250LnN0eWxlcyA9ICdub3JtYWx8aXRhbGljfG9ibGlxdWV8aW5oZXJpdCc7XG5Gb250LnZhcmlhbnRzID0gJ25vcm1hbHxzbWFsbC1jYXBzfGluaGVyaXQnO1xuRm9udC53ZWlnaHRzID0gJ25vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwfGluaGVyaXQnO1xuXG5jbGFzcyBCb3VuZGluZ0JveCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHZhciB4MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogTnVtYmVyLk5hTjtcbiAgICB2YXIgeTEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE51bWJlci5OYU47XG4gICAgdmFyIHgyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBOdW1iZXIuTmFOO1xuICAgIHZhciB5MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogTnVtYmVyLk5hTjtcbiAgICB0aGlzLngxID0geDE7XG4gICAgdGhpcy55MSA9IHkxO1xuICAgIHRoaXMueDIgPSB4MjtcbiAgICB0aGlzLnkyID0geTI7XG4gICAgdGhpcy5hZGRQb2ludCh4MSwgeTEpO1xuICAgIHRoaXMuYWRkUG9pbnQoeDIsIHkyKTtcbiAgfVxuXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLngxO1xuICB9XG5cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMueTE7XG4gIH1cblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMueDIgLSB0aGlzLngxO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy55MiAtIHRoaXMueTE7XG4gIH1cblxuICBhZGRQb2ludCh4LCB5KSB7XG4gICAgaWYgKHR5cGVvZiB4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGlzTmFOKHRoaXMueDEpIHx8IGlzTmFOKHRoaXMueDIpKSB7XG4gICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICB0aGlzLngyID0geDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPCB0aGlzLngxKSB7XG4gICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA+IHRoaXMueDIpIHtcbiAgICAgICAgdGhpcy54MiA9IHg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGlzTmFOKHRoaXMueTEpIHx8IGlzTmFOKHRoaXMueTIpKSB7XG4gICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgPCB0aGlzLnkxKSB7XG4gICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgfVxuXG4gICAgICBpZiAoeSA+IHRoaXMueTIpIHtcbiAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWRkWCh4KSB7XG4gICAgdGhpcy5hZGRQb2ludCh4LCBudWxsKTtcbiAgfVxuXG4gIGFkZFkoeSkge1xuICAgIHRoaXMuYWRkUG9pbnQobnVsbCwgeSk7XG4gIH1cblxuICBhZGRCb3VuZGluZ0JveChib3VuZGluZ0JveCkge1xuICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTJcbiAgICB9ID0gYm91bmRpbmdCb3g7XG4gICAgdGhpcy5hZGRQb2ludCh4MSwgeTEpO1xuICAgIHRoaXMuYWRkUG9pbnQoeDIsIHkyKTtcbiAgfVxuXG4gIHN1bUN1YmljKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEgLSB0LCAzKSAqIHAwICsgMyAqIE1hdGgucG93KDEgLSB0LCAyKSAqIHQgKiBwMSArIDMgKiAoMSAtIHQpICogTWF0aC5wb3codCwgMikgKiBwMiArIE1hdGgucG93KHQsIDMpICogcDM7XG4gIH1cblxuICBiZXppZXJDdXJ2ZUFkZChmb3JYLCBwMCwgcDEsIHAyLCBwMykge1xuICAgIHZhciBiID0gNiAqIHAwIC0gMTIgKiBwMSArIDYgKiBwMjtcbiAgICB2YXIgYSA9IC0zICogcDAgKyA5ICogcDEgLSA5ICogcDIgKyAzICogcDM7XG4gICAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG5cbiAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgaWYgKGIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdCA9IC1jIC8gYjtcblxuICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZFkodGhpcy5zdW1DdWJpYyh0LCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYjJhYyA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGMgKiBhO1xuXG4gICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG5cbiAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgaWYgKGZvclgpIHtcbiAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModDEsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFkodGhpcy5zdW1DdWJpYyh0MSwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcblxuICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICBpZiAoZm9yWCkge1xuICAgICAgICB0aGlzLmFkZFgodGhpcy5zdW1DdWJpYyh0MiwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKHQyLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBmcm9tIGh0dHA6Ly9ibG9nLmhhY2tlcnMtY2FmZS5uZXQvMjAwOS8wNi9ob3ctdG8tY2FsY3VsYXRlLWJlemllci1jdXJ2ZXMtYm91bmRpbmcuaHRtbFxuXG5cbiAgYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICB0aGlzLmFkZFBvaW50KHAweCwgcDB5KTtcbiAgICB0aGlzLmFkZFBvaW50KHAzeCwgcDN5KTtcbiAgICB0aGlzLmJlemllckN1cnZlQWRkKHRydWUsIHAweCwgcDF4LCBwMngsIHAzeCk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZUFkZChmYWxzZSwgcDB5LCBwMXksIHAyeSwgcDN5KTtcbiAgfVxuXG4gIGFkZFF1YWRyYXRpY0N1cnZlKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICB2YXIgY3AxeCA9IHAweCArIDIgLyAzICogKHAxeCAtIHAweCk7IC8vIENQMSA9IFFQMCArIDIvMyAqKFFQMS1RUDApXG5cbiAgICB2YXIgY3AxeSA9IHAweSArIDIgLyAzICogKHAxeSAtIHAweSk7IC8vIENQMSA9IFFQMCArIDIvMyAqKFFQMS1RUDApXG5cbiAgICB2YXIgY3AyeCA9IGNwMXggKyAxIC8gMyAqIChwMnggLSBwMHgpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuXG4gICAgdmFyIGNwMnkgPSBjcDF5ICsgMSAvIDMgKiAocDJ5IC0gcDB5KTsgLy8gQ1AyID0gQ1AxICsgMS8zICooUVAyLVFQMClcblxuICAgIHRoaXMuYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIGNwMXgsIGNwMngsIGNwMXksIGNwMnksIHAyeCwgcDJ5KTtcbiAgfVxuXG4gIGlzUG9pbnRJbkJveCh4LCB5KSB7XG4gICAgdmFyIHtcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHgxIDw9IHggJiYgeCA8PSB4MiAmJiB5MSA8PSB5ICYmIHkgPD0geTI7XG4gIH1cblxufVxuXG5jbGFzcyBQYXRoUGFyc2VyIGV4dGVuZHMgU1ZHUGF0aERhdGEge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgc3VwZXIocGF0aCAvLyBGaXggc3BhY2VzIGFmdGVyIHNpZ25zLlxuICAgIC5yZXBsYWNlKC8oWytcXC0uXSlcXHMrL2dtLCAnJDEnKSAvLyBSZW1vdmUgaW52YWxpZCBwYXJ0LlxuICAgIC5yZXBsYWNlKC9bXk1tWnpMbEhoVnZDY1NzUXFUdEFhZVxcZFxccy4sKy1dLiovZywgJycpKTtcbiAgICB0aGlzLmNvbnRyb2wgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5jb21tYW5kID0gbnVsbDtcbiAgICB0aGlzLmNvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcbiAgICB0aGlzLmkgPSAtMTtcbiAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9IG51bGw7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICB0aGlzLmFuZ2xlcyA9IFtdO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pID0gLTE7XG4gICAgdGhpcy5jb21tYW5kID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9IG51bGw7XG4gICAgdGhpcy5zdGFydCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICB0aGlzLmNvbnRyb2wgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IFBvaW50KDAsIDApO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5hbmdsZXMgPSBbXTtcbiAgfVxuXG4gIGlzRW5kKCkge1xuICAgIHZhciB7XG4gICAgICBpLFxuICAgICAgY29tbWFuZHNcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gaSA+PSBjb21tYW5kcy5sZW5ndGggLSAxO1xuICB9XG5cbiAgbmV4dCgpIHtcbiAgICB2YXIgY29tbWFuZCA9IHRoaXMuY29tbWFuZHNbKyt0aGlzLmldO1xuICAgIHRoaXMucHJldmlvdXNDb21tYW5kID0gdGhpcy5jb21tYW5kO1xuICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgcmV0dXJuIGNvbW1hbmQ7XG4gIH1cblxuICBnZXRQb2ludCgpIHtcbiAgICB2YXIgeFByb3AgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICd4JztcbiAgICB2YXIgeVByb3AgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd5JztcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQodGhpcy5jb21tYW5kW3hQcm9wXSwgdGhpcy5jb21tYW5kW3lQcm9wXSk7XG4gICAgcmV0dXJuIHRoaXMubWFrZUFic29sdXRlKHBvaW50KTtcbiAgfVxuXG4gIGdldEFzQ29udHJvbFBvaW50KHhQcm9wLCB5UHJvcCkge1xuICAgIHZhciBwb2ludCA9IHRoaXMuZ2V0UG9pbnQoeFByb3AsIHlQcm9wKTtcbiAgICB0aGlzLmNvbnRyb2wgPSBwb2ludDtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICBnZXRBc0N1cnJlbnRQb2ludCh4UHJvcCwgeVByb3ApIHtcbiAgICB2YXIgcG9pbnQgPSB0aGlzLmdldFBvaW50KHhQcm9wLCB5UHJvcCk7XG4gICAgdGhpcy5jdXJyZW50ID0gcG9pbnQ7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCkge1xuICAgIHZhciBwcmV2aW91c0NvbW1hbmQgPSB0aGlzLnByZXZpb3VzQ29tbWFuZC50eXBlO1xuXG4gICAgaWYgKHByZXZpb3VzQ29tbWFuZCAhPT0gU1ZHUGF0aERhdGEuQ1VSVkVfVE8gJiYgcHJldmlvdXNDb21tYW5kICE9PSBTVkdQYXRoRGF0YS5TTU9PVEhfQ1VSVkVfVE8gJiYgcHJldmlvdXNDb21tYW5kICE9PSBTVkdQYXRoRGF0YS5RVUFEX1RPICYmIHByZXZpb3VzQ29tbWFuZCAhPT0gU1ZHUGF0aERhdGEuU01PT1RIX1FVQURfVE8pIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfSAvLyByZWZsZWN0IHBvaW50XG5cblxuICAgIHZhciB7XG4gICAgICBjdXJyZW50OiB7XG4gICAgICAgIHg6IGN4LFxuICAgICAgICB5OiBjeVxuICAgICAgfSxcbiAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgeDogb3gsXG4gICAgICAgIHk6IG95XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KDIgKiBjeCAtIG94LCAyICogY3kgLSBveSk7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgbWFrZUFic29sdXRlKHBvaW50KSB7XG4gICAgaWYgKHRoaXMuY29tbWFuZC5yZWxhdGl2ZSkge1xuICAgICAgdmFyIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgIHBvaW50LnggKz0geDtcbiAgICAgIHBvaW50LnkgKz0geTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICBhZGRNYXJrZXIocG9pbnQsIGZyb20sIHByaW9yVG8pIHtcbiAgICB2YXIge1xuICAgICAgcG9pbnRzLFxuICAgICAgYW5nbGVzXG4gICAgfSA9IHRoaXM7IC8vIGlmIHRoZSBsYXN0IGFuZ2xlIGlzbid0IGZpbGxlZCBpbiBiZWNhdXNlIHdlIGRpZG4ndCBoYXZlIHRoaXMgcG9pbnQgeWV0IC4uLlxuXG4gICAgaWYgKHByaW9yVG8gJiYgYW5nbGVzLmxlbmd0aCA+IDAgJiYgIWFuZ2xlc1thbmdsZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgIGFuZ2xlc1thbmdsZXMubGVuZ3RoIC0gMV0gPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLmFuZ2xlVG8ocHJpb3JUbyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRNYXJrZXJBbmdsZShwb2ludCwgZnJvbSA/IGZyb20uYW5nbGVUbyhwb2ludCkgOiBudWxsKTtcbiAgfVxuXG4gIGFkZE1hcmtlckFuZ2xlKHBvaW50LCBhbmdsZSkge1xuICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIHRoaXMuYW5nbGVzLnB1c2goYW5nbGUpO1xuICB9XG5cbiAgZ2V0TWFya2VyUG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50cztcbiAgfVxuXG4gIGdldE1hcmtlckFuZ2xlcygpIHtcbiAgICB2YXIge1xuICAgICAgYW5nbGVzXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGxlbiA9IGFuZ2xlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWFuZ2xlc1tpXSkge1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGlmIChhbmdsZXNbal0pIHtcbiAgICAgICAgICAgIGFuZ2xlc1tpXSA9IGFuZ2xlc1tqXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbmdsZXM7XG4gIH1cblxufVxuXG5jbGFzcyBSZW5kZXJlZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2sgPSBmYWxzZTtcbiAgfVxuXG4gIGNhbGN1bGF0ZU9wYWNpdHkoKSB7XG4gICAgdmFyIG9wYWNpdHkgPSAxLjA7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcywgY29uc2lzdGVudC10aGlzXG5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXM7XG5cbiAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgdmFyIG9wYWNpdHlTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ29wYWNpdHknLCBmYWxzZSwgdHJ1ZSk7IC8vIG5vIGFuY2VzdG9ycyBvbiBzdHlsZSBjYWxsXG5cbiAgICAgIGlmIChvcGFjaXR5U3R5bGUuaGFzVmFsdWUodHJ1ZSkpIHtcbiAgICAgICAgb3BhY2l0eSAqPSBvcGFjaXR5U3R5bGUuZ2V0TnVtYmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3BhY2l0eTtcbiAgfVxuXG4gIHNldENvbnRleHQoY3R4KSB7XG4gICAgdmFyIGZyb21NZWFzdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIGlmICghZnJvbU1lYXN1cmUpIHtcbiAgICAgIC8vIGNhdXNlcyBzdGFjayBvdmVyZmxvdyB3aGVuIG1lYXN1cmluZyB0ZXh0IHdpdGggZ3JhZGllbnRzXG4gICAgICAvLyBmaWxsXG4gICAgICB2YXIgZmlsbFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZpbGwnKTtcbiAgICAgIHZhciBmaWxsT3BhY2l0eVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZpbGwtb3BhY2l0eScpO1xuICAgICAgdmFyIHN0cm9rZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZScpO1xuICAgICAgdmFyIHN0cm9rZU9wYWNpdHlQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLW9wYWNpdHknKTtcblxuICAgICAgaWYgKGZpbGxTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgdmFyIGZpbGxTdHlsZSA9IGZpbGxTdHlsZVByb3AuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCBmaWxsT3BhY2l0eVN0eWxlUHJvcCk7XG5cbiAgICAgICAgaWYgKGZpbGxTdHlsZSkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlsbFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGlmIChmaWxsU3R5bGVQcm9wLmdldFN0cmluZygpID09PSAnY3VycmVudENvbG9yJykge1xuICAgICAgICAgIGZpbGxTdHlsZVByb3Auc2V0VmFsdWUodGhpcy5nZXRTdHlsZSgnY29sb3InKS5nZXRDb2xvcigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZmlsbFN0eWxlID0gZmlsbFN0eWxlUHJvcC5nZXRDb2xvcigpO1xuXG4gICAgICAgIGlmIChfZmlsbFN0eWxlICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gX2ZpbGxTdHlsZSA9PT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogX2ZpbGxTdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlsbE9wYWNpdHlTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgX2ZpbGxTdHlsZTIgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2ZpbGwnLCBjdHguZmlsbFN0eWxlKS5hZGRPcGFjaXR5KGZpbGxPcGFjaXR5U3R5bGVQcm9wKS5nZXRDb2xvcigpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBfZmlsbFN0eWxlMjtcbiAgICAgIH0gLy8gc3Ryb2tlXG5cblxuICAgICAgaWYgKHN0cm9rZVN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZVByb3AuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCBzdHJva2VPcGFjaXR5UHJvcCk7XG5cbiAgICAgICAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3Ryb2tlU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgaWYgKHN0cm9rZVN0eWxlUHJvcC5nZXRTdHJpbmcoKSA9PT0gJ2N1cnJlbnRDb2xvcicpIHtcbiAgICAgICAgICBzdHJva2VTdHlsZVByb3Auc2V0VmFsdWUodGhpcy5nZXRTdHlsZSgnY29sb3InKS5nZXRDb2xvcigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKF9zdHJva2VTdHlsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gX3N0cm9rZVN0eWxlID09PSAnbm9uZScgPyAncmdiYSgwLDAsMCwwKScgOiBfc3Ryb2tlU3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0cm9rZU9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmFyIF9zdHJva2VTdHlsZTIgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3N0cm9rZScsIGN0eC5zdHJva2VTdHlsZSkuYWRkT3BhY2l0eShzdHJva2VPcGFjaXR5UHJvcCkuZ2V0U3RyaW5nKCk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gX3N0cm9rZVN0eWxlMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0cm9rZVdpZHRoU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLXdpZHRoJyk7XG5cbiAgICAgIGlmIChzdHJva2VXaWR0aFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciBuZXdMaW5lV2lkdGggPSBzdHJva2VXaWR0aFN0eWxlUHJvcC5nZXRQaXhlbHMoKTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9ICFuZXdMaW5lV2lkdGggPyBQU0VVRE9fWkVSTyAvLyBicm93c2VycyBkb24ndCByZXNwZWN0IDAgKG9yIG5vZGUtY2FudmFzPyA6LSlcbiAgICAgICAgOiBuZXdMaW5lV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHJva2VMaW5lY2FwU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLWxpbmVjYXAnKTtcbiAgICAgIHZhciBzdHJva2VMaW5lam9pblN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1saW5lam9pbicpO1xuICAgICAgdmFyIHN0cm9rZU1pdGVybGltaXRQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLW1pdGVybGltaXQnKTsgLy8gTkVFRCBURVNUXG4gICAgICAvLyBjb25zdCBwb2ludE9yZGVyU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgncGFpbnQtb3JkZXInKTtcblxuICAgICAgdmFyIHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcbiAgICAgIHZhciBzdHJva2VEYXNob2Zmc2V0UHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG5cbiAgICAgIGlmIChzdHJva2VMaW5lY2FwU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBzdHJva2VMaW5lY2FwU3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICBjdHgubGluZUpvaW4gPSBzdHJva2VMaW5lam9pblN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cm9rZU1pdGVybGltaXRQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSBzdHJva2VNaXRlcmxpbWl0UHJvcC5nZXROdW1iZXIoKTtcbiAgICAgIH0gLy8gTkVFRCBURVNUXG4gICAgICAvLyBpZiAocG9pbnRPcmRlclN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAvLyBcdC8vID9cbiAgICAgIC8vIFx0Y3R4LnBhaW50T3JkZXIgPSBwb2ludE9yZGVyU3R5bGVQcm9wLmdldFZhbHVlKCk7XG4gICAgICAvLyB9XG5cblxuICAgICAgaWYgKHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5oYXNWYWx1ZSgpICYmIHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5nZXRTdHJpbmcoKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHZhciBnYXBzID0gdG9OdW1iZXJzKHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5nZXRTdHJpbmcoKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdHguc2V0TGluZURhc2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGdhcHMpO1xuICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgaWYgKHR5cGVvZiBjdHgud2Via2l0TGluZURhc2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgIGN0eC53ZWJraXRMaW5lRGFzaCA9IGdhcHM7XG4gICAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgubW96RGFzaCAhPT0gJ3VuZGVmaW5lZCcgJiYgIShnYXBzLmxlbmd0aCA9PT0gMSAmJiBnYXBzWzBdID09PSAwKSkge1xuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgY3R4Lm1vekRhc2ggPSBnYXBzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXQgPSBzdHJva2VEYXNob2Zmc2V0UHJvcC5nZXRQaXhlbHMoKTtcblxuICAgICAgICBpZiAodHlwZW9mIGN0eC5saW5lRGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgY3R4LndlYmtpdExpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4Lm1vekRhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICBjdHgubW96RGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGZvbnRcblxuXG4gICAgdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIGN0eC5mb250ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGZvbnRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250Jyk7XG4gICAgICB2YXIgZm9udFN0eWxlU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1zdHlsZScpO1xuICAgICAgdmFyIGZvbnRWYXJpYW50U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC12YXJpYW50Jyk7XG4gICAgICB2YXIgZm9udFdlaWdodFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtd2VpZ2h0Jyk7XG4gICAgICB2YXIgZm9udFNpemVTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LXNpemUnKTtcbiAgICAgIHZhciBmb250RmFtaWx5U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1mYW1pbHknKTtcbiAgICAgIHZhciBmb250ID0gbmV3IEZvbnQoZm9udFN0eWxlU3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250VmFyaWFudFN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgZm9udFdlaWdodFN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgZm9udFNpemVTdHlsZVByb3AuaGFzVmFsdWUoKSA/IFwiXCIuY29uY2F0KGZvbnRTaXplU3R5bGVQcm9wLmdldFBpeGVscyh0cnVlKSwgXCJweFwiKSA6ICcnLCBmb250RmFtaWx5U3R5bGVQcm9wLmdldFN0cmluZygpLCBGb250LnBhcnNlKGZvbnRTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGN0eC5mb250KSk7XG4gICAgICBmb250U3R5bGVTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250U3R5bGUpO1xuICAgICAgZm9udFZhcmlhbnRTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250VmFyaWFudCk7XG4gICAgICBmb250V2VpZ2h0U3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFdlaWdodCk7XG4gICAgICBmb250U2l6ZVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRTaXplKTtcbiAgICAgIGZvbnRGYW1pbHlTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250RmFtaWx5KTtcbiAgICAgIGN0eC5mb250ID0gZm9udC50b1N0cmluZygpO1xuXG4gICAgICBpZiAoZm9udFNpemVTdHlsZVByb3AuaXNQaXhlbHMoKSkge1xuICAgICAgICB0aGlzLmRvY3VtZW50LmVtU2l6ZSA9IGZvbnRTaXplU3R5bGVQcm9wLmdldFBpeGVscygpO1xuICAgICAgICB0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZnJvbU1lYXN1cmUpIHtcbiAgICAgIC8vIGVmZmVjdHNcbiAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7IC8vIG9wYWNpdHlcblxuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jYWxjdWxhdGVPcGFjaXR5KCk7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJDb250ZXh0KGN0eCkge1xuICAgIHN1cGVyLmNsZWFyQ29udGV4dChjdHgpO1xuXG4gICAgaWYgKHRoaXMubW9kaWZpZWRFbVNpemVTdGFjaykge1xuICAgICAgdGhpcy5kb2N1bWVudC5wb3BFbVNpemUoKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBQYXRoRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdwYXRoJztcbiAgICB0aGlzLnBhdGhQYXJzZXIgPSBudWxsO1xuICAgIHRoaXMucGF0aFBhcnNlciA9IG5ldyBQYXRoUGFyc2VyKHRoaXMuZ2V0QXR0cmlidXRlKCdkJykuZ2V0U3RyaW5nKCkpO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuICAgIHBhdGhQYXJzZXIucmVzZXQoKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoIXBhdGhQYXJzZXIuaXNFbmQoKSkge1xuICAgICAgc3dpdGNoIChwYXRoUGFyc2VyLm5leHQoKS50eXBlKSB7XG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5NT1ZFX1RPOlxuICAgICAgICAgIHRoaXMucGF0aE0oY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoTChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuSE9SSVpfTElORV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhIKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5WRVJUX0xJTkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoVihjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoQyhjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX0NVUlZFX1RPOlxuICAgICAgICAgIHRoaXMucGF0aFMoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgdGhpcy5wYXRoUShjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX1FVQURfVE86XG4gICAgICAgICAgdGhpcy5wYXRoVChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgIHRoaXMucGF0aEEoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNMT1NFX1BBVEg6XG4gICAgICAgICAgdGhpcy5wYXRoWihjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxuICBnZXRCb3VuZGluZ0JveChfKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aCgpO1xuICB9XG5cbiAgZ2V0TWFya2VycygpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBwb2ludHMgPSBwYXRoUGFyc2VyLmdldE1hcmtlclBvaW50cygpO1xuICAgIHZhciBhbmdsZXMgPSBwYXRoUGFyc2VyLmdldE1hcmtlckFuZ2xlcygpO1xuICAgIHZhciBtYXJrZXJzID0gcG9pbnRzLm1hcCgocG9pbnQsIGkpID0+IFtwb2ludCwgYW5nbGVzW2ldXSk7XG4gICAgcmV0dXJuIG1hcmtlcnM7XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICB0aGlzLnBhdGgoY3R4KTtcbiAgICB0aGlzLmRvY3VtZW50LnNjcmVlbi5tb3VzZS5jaGVja1BhdGgodGhpcywgY3R4KTtcbiAgICB2YXIgZmlsbFJ1bGVTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsLXJ1bGUnKTtcblxuICAgIGlmIChjdHguZmlsbFN0eWxlICE9PSAnJykge1xuICAgICAgaWYgKGZpbGxSdWxlU3R5bGVQcm9wLmdldFN0cmluZygnaW5oZXJpdCcpICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgY3R4LmZpbGwoZmlsbFJ1bGVTdHlsZVByb3AuZ2V0U3RyaW5nKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9PSAnJykge1xuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCd2ZWN0b3ItZWZmZWN0JykuZ2V0U3RyaW5nKCkgPT09ICdub24tc2NhbGluZy1zdHJva2UnKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xuXG4gICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgIHZhciBtYXJrZXJzTGFzdEluZGV4ID0gbWFya2Vycy5sZW5ndGggLSAxO1xuICAgICAgdmFyIG1hcmtlclN0YXJ0U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLXN0YXJ0Jyk7XG4gICAgICB2YXIgbWFya2VyTWlkU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLW1pZCcpO1xuICAgICAgdmFyIG1hcmtlckVuZFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ21hcmtlci1lbmQnKTtcblxuICAgICAgaWYgKG1hcmtlclN0YXJ0U3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJTdGFydFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIHZhciBbcG9pbnQsIGFuZ2xlXSA9IG1hcmtlcnNbMF07XG4gICAgICAgIG1hcmtlci5yZW5kZXIoY3R4LCBwb2ludCwgYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFya2VyTWlkU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgIHZhciBfbWFya2VyID0gbWFya2VyTWlkU3R5bGVQcm9wLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG1hcmtlcnNMYXN0SW5kZXg7IGkrKykge1xuICAgICAgICAgIHZhciBbX3BvaW50LCBfYW5nbGVdID0gbWFya2Vyc1tpXTtcblxuICAgICAgICAgIF9tYXJrZXIucmVuZGVyKGN0eCwgX3BvaW50LCBfYW5nbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrZXJFbmRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgdmFyIF9tYXJrZXIyID0gbWFya2VyRW5kU3R5bGVQcm9wLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICB2YXIgW19wb2ludDIsIF9hbmdsZTJdID0gbWFya2Vyc1ttYXJrZXJzTGFzdEluZGV4XTtcblxuICAgICAgICBfbWFya2VyMi5yZW5kZXIoY3R4LCBfcG9pbnQyLCBfYW5nbGUyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aE0ocGF0aFBhcnNlcikge1xuICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICBwYXRoUGFyc2VyLnN0YXJ0ID0gcGF0aFBhcnNlci5jdXJyZW50O1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoTShjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgcG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aE0ocGF0aFBhcnNlcik7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHBvaW50O1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhMKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhMKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEwocGF0aFBhcnNlcik7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHBvaW50O1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhIKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1hbmRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoKGNvbW1hbmQucmVsYXRpdmUgPyBjdXJyZW50LnggOiAwKSArIGNvbW1hbmQueCwgY3VycmVudC55KTtcbiAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwb2ludDtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhIKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEgocGF0aFBhcnNlcik7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHBvaW50O1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhWKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1hbmRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoY3VycmVudC54LCAoY29tbWFuZC5yZWxhdGl2ZSA/IGN1cnJlbnQueSA6IDApICsgY29tbWFuZC55KTtcbiAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwb2ludDtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhWKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFYocGF0aFBhcnNlcik7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHBvaW50O1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhDKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0UG9pbnQoJ3gxJywgJ3kxJyk7XG4gICAgdmFyIGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gyJywgJ3kyJyk7XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhDKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEMocGF0aFBhcnNlcik7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIHBvaW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRCZXppZXJDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgcG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoUyhwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgcG9pbnQgPSBwYXRoUGFyc2VyLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpO1xuICAgIHZhciBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ29udHJvbFBvaW50KCd4MicsICd5MicpO1xuICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoUyhjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhTKHBhdGhQYXJzZXIpO1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBwb2ludCk7XG4gICAgYm91bmRpbmdCb3guYWRkQmV6aWVyQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aFEocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50XG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gxJywgJ3kxJyk7XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoUShjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoUShwYXRoUGFyc2VyKTtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihjdXJyZW50UG9pbnQsIGNvbnRyb2xQb2ludCwgY29udHJvbFBvaW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoVChwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKTtcbiAgICBwYXRoUGFyc2VyLmNvbnRyb2wgPSBjb250cm9sUG9pbnQ7XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoVChjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoVChwYXRoUGFyc2VyKTtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihjdXJyZW50UG9pbnQsIGNvbnRyb2xQb2ludCwgY29udHJvbFBvaW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoQShwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21tYW5kXG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIHtcbiAgICAgIHJYLFxuICAgICAgclksXG4gICAgICB4Um90LFxuICAgICAgbEFyY0ZsYWcsXG4gICAgICBzd2VlcEZsYWdcbiAgICB9ID0gY29tbWFuZDtcbiAgICB2YXIgeEF4aXNSb3RhdGlvbiA9IHhSb3QgKiAoTWF0aC5QSSAvIDE4MC4wKTtcbiAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpOyAvLyBDb252ZXJzaW9uIGZyb20gZW5kcG9pbnQgdG8gY2VudGVyIHBhcmFtZXRlcml6YXRpb25cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgICAvLyB4MScsIHkxJ1xuXG4gICAgdmFyIGN1cnJwID0gbmV3IFBvaW50KE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueCAtIGN1cnJlbnRQb2ludC54KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueSAtIGN1cnJlbnRQb2ludC55KSAvIDIuMCwgLU1hdGguc2luKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueCAtIGN1cnJlbnRQb2ludC54KSAvIDIuMCArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueSAtIGN1cnJlbnRQb2ludC55KSAvIDIuMCk7IC8vIGFkanVzdCByYWRpaVxuXG4gICAgdmFyIGwgPSBNYXRoLnBvdyhjdXJycC54LCAyKSAvIE1hdGgucG93KHJYLCAyKSArIE1hdGgucG93KGN1cnJwLnksIDIpIC8gTWF0aC5wb3coclksIDIpO1xuXG4gICAgaWYgKGwgPiAxKSB7XG4gICAgICByWCAqPSBNYXRoLnNxcnQobCk7XG4gICAgICByWSAqPSBNYXRoLnNxcnQobCk7XG4gICAgfSAvLyBjeCcsIGN5J1xuXG5cbiAgICB2YXIgcyA9IChsQXJjRmxhZyA9PT0gc3dlZXBGbGFnID8gLTEgOiAxKSAqIE1hdGguc3FydCgoTWF0aC5wb3coclgsIDIpICogTWF0aC5wb3coclksIDIpIC0gTWF0aC5wb3coclgsIDIpICogTWF0aC5wb3coY3VycnAueSwgMikgLSBNYXRoLnBvdyhyWSwgMikgKiBNYXRoLnBvdyhjdXJycC54LCAyKSkgLyAoTWF0aC5wb3coclgsIDIpICogTWF0aC5wb3coY3VycnAueSwgMikgKyBNYXRoLnBvdyhyWSwgMikgKiBNYXRoLnBvdyhjdXJycC54LCAyKSkpO1xuXG4gICAgaWYgKGlzTmFOKHMpKSB7XG4gICAgICBzID0gMDtcbiAgICB9XG5cbiAgICB2YXIgY3BwID0gbmV3IFBvaW50KHMgKiByWCAqIGN1cnJwLnkgLyByWSwgcyAqIC1yWSAqIGN1cnJwLnggLyByWCk7IC8vIGN4LCBjeVxuXG4gICAgdmFyIGNlbnRwID0gbmV3IFBvaW50KChjdXJyZW50LnggKyBjdXJyZW50UG9pbnQueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC54IC0gTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiBjcHAueSwgKGN1cnJlbnQueSArIGN1cnJlbnRQb2ludC55KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnggKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC55KTsgLy8gaW5pdGlhbCBhbmdsZVxuXG4gICAgdmFyIGExID0gdmVjdG9yc0FuZ2xlKFsxLCAwXSwgWyhjdXJycC54IC0gY3BwLngpIC8gclgsIChjdXJycC55IC0gY3BwLnkpIC8gclldKTsgLy8gzrgxXG4gICAgLy8gYW5nbGUgZGVsdGFcblxuICAgIHZhciB1ID0gWyhjdXJycC54IC0gY3BwLngpIC8gclgsIChjdXJycC55IC0gY3BwLnkpIC8gclldO1xuICAgIHZhciB2ID0gWygtY3VycnAueCAtIGNwcC54KSAvIHJYLCAoLWN1cnJwLnkgLSBjcHAueSkgLyByWV07XG4gICAgdmFyIGFkID0gdmVjdG9yc0FuZ2xlKHUsIHYpOyAvLyDOlM64XG5cbiAgICBpZiAodmVjdG9yc1JhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICBhZCA9IE1hdGguUEk7XG4gICAgfVxuXG4gICAgaWYgKHZlY3RvcnNSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICBhZCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRQb2ludCxcbiAgICAgIHJYLFxuICAgICAgclksXG4gICAgICBzd2VlcEZsYWcsXG4gICAgICB4QXhpc1JvdGF0aW9uLFxuICAgICAgY2VudHAsXG4gICAgICBhMSxcbiAgICAgIGFkXG4gICAgfTtcbiAgfVxuXG4gIHBhdGhBKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50UG9pbnQsXG4gICAgICByWCxcbiAgICAgIHJZLFxuICAgICAgc3dlZXBGbGFnLFxuICAgICAgeEF4aXNSb3RhdGlvbixcbiAgICAgIGNlbnRwLFxuICAgICAgYTEsXG4gICAgICBhZFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoQShwYXRoUGFyc2VyKTsgLy8gZm9yIG1hcmtlcnNcblxuICAgIHZhciBkaXIgPSAxIC0gc3dlZXBGbGFnID8gMS4wIDogLTEuMDtcbiAgICB2YXIgYWggPSBhMSArIGRpciAqIChhZCAvIDIuMCk7XG4gICAgdmFyIGhhbGZXYXkgPSBuZXcgUG9pbnQoY2VudHAueCArIHJYICogTWF0aC5jb3MoYWgpLCBjZW50cC55ICsgclkgKiBNYXRoLnNpbihhaCkpO1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyQW5nbGUoaGFsZldheSwgYWggLSBkaXIgKiBNYXRoLlBJIC8gMik7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXJBbmdsZShjdXJyZW50UG9pbnQsIGFoIC0gZGlyICogTWF0aC5QSSk7XG4gICAgYm91bmRpbmdCb3guYWRkUG9pbnQoY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTsgLy8gVE9ETzogdGhpcyBpcyB0b28gbmFpdmUsIG1ha2UgaXQgYmV0dGVyXG5cbiAgICBpZiAoY3R4ICYmICFpc05hTihhMSkgJiYgIWlzTmFOKGFkKSkge1xuICAgICAgdmFyIHIgPSByWCA+IHJZID8gclggOiByWTtcbiAgICAgIHZhciBzeCA9IHJYID4gclkgPyAxIDogclggLyByWTtcbiAgICAgIHZhciBzeSA9IHJYID4gclkgPyByWSAvIHJYIDogMTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY2VudHAueCwgY2VudHAueSk7XG4gICAgICBjdHgucm90YXRlKHhBeGlzUm90YXRpb24pO1xuICAgICAgY3R4LnNjYWxlKHN4LCBzeSk7XG4gICAgICBjdHguYXJjKDAsIDAsIHIsIGExLCBhMSArIGFkLCBCb29sZWFuKDEgLSBzd2VlcEZsYWcpKTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gc3gsIDEgLyBzeSk7XG4gICAgICBjdHgucm90YXRlKC14QXhpc1JvdGF0aW9uKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoLWNlbnRwLngsIC1jZW50cC55KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aFoocGF0aFBhcnNlcikge1xuICAgIHBhdGhQYXJzZXIuY3VycmVudCA9IHBhdGhQYXJzZXIuc3RhcnQ7XG4gIH1cblxuICBwYXRoWihjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgUGF0aEVsZW1lbnQucGF0aFoodGhpcy5wYXRoUGFyc2VyKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIC8vIG9ubHkgY2xvc2UgcGF0aCBpZiBpdCBpcyBub3QgYSBzdHJhaWdodCBsaW5lXG4gICAgICBpZiAoYm91bmRpbmdCb3gueDEgIT09IGJvdW5kaW5nQm94LngyICYmIGJvdW5kaW5nQm94LnkxICE9PSBib3VuZGluZ0JveC55Mikge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgR2x5cGhFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnZ2x5cGgnO1xuICAgIHRoaXMuaG9yaXpBZHZYID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hvcml6LWFkdi14JykuZ2V0TnVtYmVyKCk7XG4gICAgdGhpcy51bmljb2RlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3VuaWNvZGUnKS5nZXRTdHJpbmcoKTtcbiAgICB0aGlzLmFyYWJpY0Zvcm0gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXJhYmljLWZvcm0nKS5nZXRTdHJpbmcoKTtcbiAgfVxuXG59XG5cbmNsYXNzIFRleHRFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgbmV3LnRhcmdldCA9PT0gVGV4dEVsZW1lbnQgPyB0cnVlIDogY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3RleHQnO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLm1lYXN1cmVDYWNoZSA9IC0xO1xuICB9XG5cbiAgc2V0Q29udGV4dChjdHgpIHtcbiAgICB2YXIgZnJvbU1lYXN1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHN1cGVyLnNldENvbnRleHQoY3R4LCBmcm9tTWVhc3VyZSk7XG4gICAgdmFyIHRleHRCYXNlbGluZSA9IHRoaXMuZ2V0U3R5bGUoJ2RvbWluYW50LWJhc2VsaW5lJykuZ2V0VGV4dEJhc2VsaW5lKCkgfHwgdGhpcy5nZXRTdHlsZSgnYWxpZ25tZW50LWJhc2VsaW5lJykuZ2V0VGV4dEJhc2VsaW5lKCk7XG5cbiAgICBpZiAodGV4dEJhc2VsaW5lKSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxpemVDb29yZGluYXRlcygpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5sZWFmVGV4dHMgPSBbXTtcbiAgICB0aGlzLnRleHRDaHVua1N0YXJ0ID0gMDtcbiAgICB0aGlzLm1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5tYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICB9XG5cbiAgZ2V0Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRURWxlbWVudEJvdW5kaW5nQm94KGN0eCk7XG4gICAgfSAvLyBmaXJzdCwgY2FsY3VsYXRlIGNoaWxkIHBvc2l0aW9uc1xuXG5cbiAgICB0aGlzLmluaXRpYWxpemVDb29yZGluYXRlcygpO1xuICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShjdHgpO1xuICAgIHZhciBib3VuZGluZ0JveCA9IG51bGw7IC8vIHRoZW4gY2FsY3VsYXRlIGJvdW5kaW5nIGJveFxuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGluZ0JveCA9IHRoaXMuZ2V0Q2hpbGRCb3VuZGluZ0JveChjdHgsIHRoaXMsIHRoaXMsIGkpO1xuXG4gICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgIGJvdW5kaW5nQm94ID0gY2hpbGRCb3VuZGluZ0JveDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkQm91bmRpbmdCb3gpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgfVxuXG4gIGdldEZvbnRTaXplKCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBpbmhlcml0Rm9udFNpemUgPSBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KS5mb250U2l6ZTtcbiAgICB2YXIgZm9udFNpemUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc2l6ZScpLmdldE51bWJlcihpbmhlcml0Rm9udFNpemUpO1xuICAgIHJldHVybiBmb250U2l6ZTtcbiAgfVxuXG4gIGdldFRFbGVtZW50Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnkgLSBmb250U2l6ZSwgdGhpcy54ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB0aGlzLnkpO1xuICB9XG5cbiAgZ2V0R2x5cGgoZm9udCwgdGV4dCwgaSkge1xuICAgIHZhciBjaGFyID0gdGV4dFtpXTtcbiAgICB2YXIgZ2x5cGggPSBudWxsO1xuXG4gICAgaWYgKGZvbnQuaXNBcmFiaWMpIHtcbiAgICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIHZhciBwcmV2Q2hhciA9IHRleHRbaSAtIDFdO1xuICAgICAgdmFyIG5leHRDaGFyID0gdGV4dFtpICsgMV07XG4gICAgICB2YXIgYXJhYmljRm9ybSA9ICdpc29sYXRlZCc7XG5cbiAgICAgIGlmICgoaSA9PT0gMCB8fCBwcmV2Q2hhciA9PT0gJyAnKSAmJiBpIDwgbGVuIC0gMSAmJiBuZXh0Q2hhciAhPT0gJyAnKSB7XG4gICAgICAgIGFyYWJpY0Zvcm0gPSAndGVybWluYWwnO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+IDAgJiYgcHJldkNoYXIgIT09ICcgJyAmJiBpIDwgbGVuIC0gMSAmJiBuZXh0Q2hhciAhPT0gJyAnKSB7XG4gICAgICAgIGFyYWJpY0Zvcm0gPSAnbWVkaWFsJztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiAwICYmIHByZXZDaGFyICE9PSAnICcgJiYgKGkgPT09IGxlbiAtIDEgfHwgbmV4dENoYXIgPT09ICcgJykpIHtcbiAgICAgICAgYXJhYmljRm9ybSA9ICdpbml0aWFsJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmb250LmdseXBoc1tjaGFyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTkVFRCBURVNUXG4gICAgICAgIHZhciBtYXliZUdseXBoID0gZm9udC5nbHlwaHNbY2hhcl07XG4gICAgICAgIGdseXBoID0gbWF5YmVHbHlwaCBpbnN0YW5jZW9mIEdseXBoRWxlbWVudCA/IG1heWJlR2x5cGggOiBtYXliZUdseXBoW2FyYWJpY0Zvcm1dO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2NoYXJdO1xuICAgIH1cblxuICAgIGlmICghZ2x5cGgpIHtcbiAgICAgIGdseXBoID0gZm9udC5taXNzaW5nR2x5cGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBnZXRUZXh0RnJvbU5vZGUobm9kZSkge1xuICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUgfHwgdGhpcy5ub2RlO1xuICAgIHZhciBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbSh0ZXh0Tm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMpO1xuICAgIHZhciBpbmRleCA9IGNoaWxkTm9kZXMuaW5kZXhPZih0ZXh0Tm9kZSk7XG4gICAgdmFyIGxhc3RJbmRleCA9IGNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgdGV4dCA9IGNvbXByZXNzU3BhY2VzKCAvLyB0ZXh0Tm9kZS52YWx1ZVxuICAgIC8vIHx8IHRleHROb2RlLnRleHRcbiAgICB0ZXh0Tm9kZS50ZXh0Q29udGVudCB8fCAnJyk7XG5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHRleHQgPSB0cmltTGVmdCh0ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xuICAgICAgdGV4dCA9IHRyaW1SaWdodCh0ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgdGhpcy5yZW5kZXJURWxlbWVudENoaWxkcmVuKGN0eCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBmaXJzdCwgY2FsY3VsYXRlIGNoaWxkIHBvc2l0aW9uc1xuXG5cbiAgICB0aGlzLmluaXRpYWxpemVDb29yZGluYXRlcygpO1xuICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShjdHgpOyAvLyB0aGVuIHJlbmRlclxuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICB0aGlzLnJlbmRlckNoaWxkKGN0eCwgdGhpcywgdGhpcywgaSk7XG4gICAgfSk7XG4gICAgdmFyIHtcbiAgICAgIG1vdXNlXG4gICAgfSA9IHRoaXMuZG9jdW1lbnQuc2NyZWVuOyAvLyBEbyBub3QgY2FsYyBib3VuZGluZyBib3ggaWYgbW91c2UgaXMgbm90IHdvcmtpbmcuXG5cbiAgICBpZiAobW91c2UuaXNXb3JraW5nKCkpIHtcbiAgICAgIG1vdXNlLmNoZWNrQm91bmRpbmdCb3godGhpcywgdGhpcy5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXJURWxlbWVudENoaWxkcmVuKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciByZW5kZXJUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGN1c3RvbUZvbnQgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5JykuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgaWYgKGN1c3RvbUZvbnQpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHVuaXRzUGVyRW1cbiAgICAgIH0gPSBjdXN0b21Gb250LmZvbnRGYWNlO1xuICAgICAgdmFyIGN0eEZvbnQgPSBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KTtcbiAgICAgIHZhciBmb250U2l6ZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zaXplJykuZ2V0TnVtYmVyKGN0eEZvbnQuZm9udFNpemUpO1xuICAgICAgdmFyIGZvbnRTdHlsZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zdHlsZScpLmdldFN0cmluZyhjdHhGb250LmZvbnRTdHlsZSk7XG4gICAgICB2YXIgc2NhbGUgPSBmb250U2l6ZSAvIHVuaXRzUGVyRW07XG4gICAgICB2YXIgdGV4dCA9IGN1c3RvbUZvbnQuaXNSVEwgPyByZW5kZXJUZXh0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiByZW5kZXJUZXh0O1xuICAgICAgdmFyIGR4ID0gdG9OdW1iZXJzKHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoY3VzdG9tRm9udCwgdGV4dCwgaSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBjdHguc2NhbGUoc2NhbGUsIC1zY2FsZSk7XG4gICAgICAgIHZhciBsdyA9IGN0eC5saW5lV2lkdGg7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBjdHgubGluZVdpZHRoICogdW5pdHNQZXJFbSAvIGZvbnRTaXplO1xuXG4gICAgICAgIGlmIChmb250U3R5bGUgPT09ICdpdGFsaWMnKSB7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAuNCwgMSwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaC5yZW5kZXIoY3R4KTtcblxuICAgICAgICBpZiAoZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgLS40LCAxLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsdztcbiAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZSwgLTEgLyBzY2FsZSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXRoaXMueCwgLXRoaXMueSk7XG4gICAgICAgIHRoaXMueCArPSBmb250U2l6ZSAqIChnbHlwaC5ob3JpekFkdlggfHwgY3VzdG9tRm9udC5ob3JpekFkdlgpIC8gdW5pdHNQZXJFbTtcblxuICAgICAgICBpZiAodHlwZW9mIGR4W2ldICE9PSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XG4gICAgICAgICAgdGhpcy54ICs9IGR4W2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpczsgLy8gTkVFRCBURVNUXG4gICAgLy8gaWYgKGN0eC5wYWludE9yZGVyID09PSAnc3Ryb2tlJykge1xuICAgIC8vIFx0aWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgIC8vIFx0XHRjdHguc3Ryb2tlVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAvLyBcdH1cbiAgICAvLyBcdGlmIChjdHguZmlsbFN0eWxlKSB7XG4gICAgLy8gXHRcdGN0eC5maWxsVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAvLyBcdH1cbiAgICAvLyB9IGVsc2Uge1xuXG4gICAgaWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgIGN0eC5maWxsVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoY3R4LnN0cm9rZVN0eWxlKSB7XG4gICAgICBjdHguc3Ryb2tlVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICB9IC8vIH1cblxuICB9XG5cbiAgYXBwbHlBbmNob3JpbmcoKSB7XG4gICAgaWYgKHRoaXMudGV4dENodW5rU3RhcnQgPj0gdGhpcy5sZWFmVGV4dHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGlzIGlzIGJhc2ljYWxseSB0aGUgXCJBcHBseSBhbmNob3JpbmdcIiBwYXJ0IG9mIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcyL3RleHQuaHRtbCNUZXh0TGF5b3V0QWxnb3JpdGhtLlxuICAgIC8vIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgd2UgYXBwbHkgdGhlIGFuY2hvcmluZyBhcyBzb29uIGFzIGEgY2h1bmsgaXMgZmluaXNoZWQuIFRoaXMgc2F2ZXMgc29tZSBleHRyYSBsb29waW5nLlxuICAgIC8vIFZlcnRpY2FsIHRleHQgaXMgbm90IHN1cHBvcnRlZC5cblxuXG4gICAgdmFyIGZpcnN0RWxlbWVudCA9IHRoaXMubGVhZlRleHRzW3RoaXMudGV4dENodW5rU3RhcnRdO1xuICAgIHZhciB0ZXh0QW5jaG9yID0gZmlyc3RFbGVtZW50LmdldFN0eWxlKCd0ZXh0LWFuY2hvcicpLmdldFN0cmluZygnc3RhcnQnKTtcbiAgICB2YXIgaXNSVEwgPSBmYWxzZTsgLy8gd2UgdHJlYXQgUlRMIGxpa2UgTFRSXG5cbiAgICB2YXIgc2hpZnQgPSAwO1xuXG4gICAgaWYgKHRleHRBbmNob3IgPT09ICdzdGFydCcgJiYgIWlzUlRMIHx8IHRleHRBbmNob3IgPT09ICdlbmQnICYmIGlzUlRMKSB7XG4gICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gdGhpcy5taW5YO1xuICAgIH0gZWxzZSBpZiAodGV4dEFuY2hvciA9PT0gJ2VuZCcgJiYgIWlzUlRMIHx8IHRleHRBbmNob3IgPT09ICdzdGFydCcgJiYgaXNSVEwpIHtcbiAgICAgIHNoaWZ0ID0gZmlyc3RFbGVtZW50LnggLSB0aGlzLm1heFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoaWZ0ID0gZmlyc3RFbGVtZW50LnggLSAodGhpcy5taW5YICsgdGhpcy5tYXhYKSAvIDI7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMudGV4dENodW5rU3RhcnQ7IGkgPCB0aGlzLmxlYWZUZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5sZWFmVGV4dHNbaV0ueCArPSBzaGlmdDtcbiAgICB9IC8vIHN0YXJ0IG5ldyBjaHVua1xuXG5cbiAgICB0aGlzLm1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5tYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIHRoaXMudGV4dENodW5rU3RhcnQgPSB0aGlzLmxlYWZUZXh0cy5sZW5ndGg7XG4gIH1cblxuICBhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlKGN0eCkge1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRoaXMsIHRoaXMsIGkpO1xuICAgIH0pO1xuICAgIHRoaXMuYXBwbHlBbmNob3JpbmcoKTtcbiAgfVxuXG4gIGFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgICAgdGV4dFBhcmVudC5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvbmx5IGxlYWZzIGFyZSByZWxldmFudFxuICAgICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzKGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKTtcbiAgICB9XG4gIH1cblxuICBhZGp1c3RDaGlsZENvb3JkaW5hdGVzKGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBjaGlsZC5tZWFzdXJlVGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY2hpbGQuc2V0Q29udGV4dChjdHgsIHRydWUpO1xuICAgIHZhciB4QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgIHZhciB5QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgneScpO1xuICAgIHZhciBkeEF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2R4Jyk7XG4gICAgdmFyIGR5QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnZHknKTtcbiAgICB2YXIgY3VzdG9tRm9udCA9IGNoaWxkLmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcbiAgICB2YXIgaXNSVEwgPSBCb29sZWFuKGN1c3RvbUZvbnQpICYmIGN1c3RvbUZvbnQuaXNSVEw7XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgLy8gRmlyc3QgY2hpbGRyZW4gaW5oZXJpdCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50KHMpLiBQb3NpdGlvbmFsIGF0dHJpYnV0ZXNcbiAgICAgIC8vIGFyZSBvbmx5IGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IHRvIGl0J3MgZmlyc3QgY2hpbGQuXG4gICAgICBpZiAoIXhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgeEF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCd4JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgeUF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCd5JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGR4QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ2R4JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWR5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGR5QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ2R5JykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGNoaWxkLm1lYXN1cmVUZXh0KGN0eCk7XG5cbiAgICBpZiAoaXNSVEwpIHtcbiAgICAgIHRleHRQYXJlbnQueCAtPSB3aWR0aDtcbiAgICB9XG5cbiAgICBpZiAoeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgLy8gYW4gXCJ4XCIgYXR0cmlidXRlIG1hcmtzIHRoZSBzdGFydCBvZiBhIG5ldyBjaHVua1xuICAgICAgdGV4dFBhcmVudC5hcHBseUFuY2hvcmluZygpO1xuICAgICAgY2hpbGQueCA9IHhBdHRyLmdldFBpeGVscygneCcpO1xuXG4gICAgICBpZiAoZHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY2hpbGQueCArPSBkeEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICB0ZXh0UGFyZW50LnggKz0gZHhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZC54ID0gdGV4dFBhcmVudC54O1xuICAgIH1cblxuICAgIHRleHRQYXJlbnQueCA9IGNoaWxkLng7XG5cbiAgICBpZiAoIWlzUlRMKSB7XG4gICAgICB0ZXh0UGFyZW50LnggKz0gd2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGNoaWxkLnkgPSB5QXR0ci5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgaWYgKGR5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNoaWxkLnkgKz0gZHlBdHRyLmdldFBpeGVscygneScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGV4dFBhcmVudC55ICs9IGR5QXR0ci5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQueSA9IHRleHRQYXJlbnQueTtcbiAgICB9XG5cbiAgICB0ZXh0UGFyZW50LnkgPSBjaGlsZC55OyAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgY2h1bmsgYW5kIGl0J3MgYm91bmRzXG5cbiAgICB0ZXh0UGFyZW50LmxlYWZUZXh0cy5wdXNoKGNoaWxkKTtcbiAgICB0ZXh0UGFyZW50Lm1pblggPSBNYXRoLm1pbih0ZXh0UGFyZW50Lm1pblgsIGNoaWxkLngsIGNoaWxkLnggKyB3aWR0aCk7XG4gICAgdGV4dFBhcmVudC5tYXhYID0gTWF0aC5tYXgodGV4dFBhcmVudC5tYXhYLCBjaGlsZC54LCBjaGlsZC54ICsgd2lkdGgpO1xuICAgIGNoaWxkLmNsZWFyQ29udGV4dChjdHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgZ2V0Q2hpbGRCb3VuZGluZ0JveChjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTsgLy8gbm90IGEgdGV4dCBub2RlP1xuXG4gICAgaWYgKHR5cGVvZiBjaGlsZC5nZXRCb3VuZGluZ0JveCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kaW5nQm94ID0gY2hpbGQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcblxuICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgIHZhciBjaGlsZEJvdW5kaW5nQm94ID0gdGV4dFBhcmVudC5nZXRDaGlsZEJvdW5kaW5nQm94KGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgICAgYm91bmRpbmdCb3guYWRkQm91bmRpbmdCb3goY2hpbGRCb3VuZGluZ0JveCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICB9XG5cbiAgcmVuZGVyQ2hpbGQoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgY2hpbGQucmVuZGVyKGN0eCk7XG4gICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgdGV4dFBhcmVudC5yZW5kZXJDaGlsZChjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1lYXN1cmVUZXh0KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBtZWFzdXJlQ2FjaGVcbiAgICB9ID0gdGhpcztcblxuICAgIGlmICh+bWVhc3VyZUNhY2hlKSB7XG4gICAgICByZXR1cm4gbWVhc3VyZUNhY2hlO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIG1lYXN1cmUgPSB0aGlzLm1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgcmVuZGVyVGV4dCk7XG4gICAgdGhpcy5tZWFzdXJlQ2FjaGUgPSBtZWFzdXJlO1xuICAgIHJldHVybiBtZWFzdXJlO1xuICB9XG5cbiAgbWVhc3VyZVRhcmdldFRleHQoY3R4LCB0YXJnZXRUZXh0KSB7XG4gICAgaWYgKCF0YXJnZXRUZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBjdXN0b21Gb250ID0gcGFyZW50LmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcblxuICAgIGlmIChjdXN0b21Gb250KSB7XG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICB2YXIgdGV4dCA9IGN1c3RvbUZvbnQuaXNSVEwgPyB0YXJnZXRUZXh0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiB0YXJnZXRUZXh0O1xuICAgICAgdmFyIGR4ID0gdG9OdW1iZXJzKHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgdmFyIF9tZWFzdXJlID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xuICAgICAgICBfbWVhc3VyZSArPSAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAqIGZvbnRTaXplIC8gY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZHhbaV0gIT09ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICBfbWVhc3VyZSArPSBkeFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX21lYXN1cmU7XG4gICAgfVxuXG4gICAgaWYgKCFjdHgubWVhc3VyZVRleHQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRUZXh0Lmxlbmd0aCAqIDEwO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG4gICAgdGhpcy5zZXRDb250ZXh0KGN0eCwgdHJ1ZSk7XG4gICAgdmFyIHtcbiAgICAgIHdpZHRoOiBtZWFzdXJlXG4gICAgfSA9IGN0eC5tZWFzdXJlVGV4dCh0YXJnZXRUZXh0KTtcbiAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgcmV0dXJuIG1lYXN1cmU7XG4gIH1cbiAgLyoqXHJcbiAgICogSW5oZXJpdHMgcG9zaXRpb25hbCBhdHRyaWJ1dGVzIGZyb20ge0BsaW5rIFRleHRFbGVtZW50fSBwYXJlbnQocykuIEF0dHJpYnV0ZXNcclxuICAgKiBhcmUgb25seSBpbmhlcml0ZWQgZnJvbSBhIHBhcmVudCB0byBpdHMgZmlyc3QgY2hpbGQuXHJcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgYXR0cmlidXRlIG5hbWUuXHJcbiAgICogQHJldHVybnMgVGhlIGF0dHJpYnV0ZSB2YWx1ZSBvciBudWxsLlxyXG4gICAqL1xuXG5cbiAgZ2V0SW5oZXJpdGVkQXR0cmlidXRlKG5hbWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsY29uc2lzdGVudC10aGlzXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQgaW5zdGFuY2VvZiBUZXh0RWxlbWVudCAmJiBjdXJyZW50LmlzRmlyc3RDaGlsZCgpKSB7XG4gICAgICB2YXIgcGFyZW50QXR0ciA9IGN1cnJlbnQucGFyZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgICAgaWYgKHBhcmVudEF0dHIuaGFzVmFsdWUodHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudEF0dHIuZ2V0VmFsdWUoJzAnKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbn1cblxuY2xhc3MgVFNwYW5FbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBuZXcudGFyZ2V0ID09PSBUU3BhbkVsZW1lbnQgPyB0cnVlIDogY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3RzcGFuJzsgLy8gaWYgdGhpcyBub2RlIGhhcyBjaGlsZHJlbiwgdGhlbiB0aGV5IG93biB0aGUgdGV4dFxuXG4gICAgdGhpcy50ZXh0ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwID8gJycgOiB0aGlzLmdldFRleHRGcm9tTm9kZSgpO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9XG5cbn1cblxuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBUU3BhbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICd0ZXh0Tm9kZSc7XG4gIH1cblxufVxuXG5jbGFzcyBTVkdFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnc3ZnJztcbiAgICB0aGlzLnJvb3QgPSBmYWxzZTtcbiAgfVxuXG4gIHNldENvbnRleHQoY3R4KSB7XG4gICAgdmFyIF90aGlzJG5vZGUkcGFyZW50Tm9kZTtcblxuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBzY3JlZW4sXG4gICAgICB3aW5kb3dcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgdmFyIGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgc2NyZWVuLnNldERlZmF1bHRzKGN0eCk7XG5cbiAgICBpZiAoY2FudmFzLnN0eWxlICYmIHR5cGVvZiBjdHguZm9udCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGN0eC5mb250ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2FudmFzKS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250Jyk7XG4gICAgICB2YXIgZm9udFNpemVQcm9wID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZm9udFNpemUnLCBGb250LnBhcnNlKGN0eC5mb250KS5mb250U2l6ZSk7XG5cbiAgICAgIGlmIChmb250U2l6ZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICBkb2N1bWVudC5yb290RW1TaXplID0gZm9udFNpemVQcm9wLmdldFBpeGVscygneScpO1xuICAgICAgICBkb2N1bWVudC5lbVNpemUgPSBkb2N1bWVudC5yb290RW1TaXplO1xuICAgICAgfVxuICAgIH0gLy8gY3JlYXRlIG5ldyB2aWV3IHBvcnRcblxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd4JywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5JywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHNjcmVlbi52aWV3UG9ydDtcblxuICAgIGlmICghdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldFN0eWxlKCd3aWR0aCcsIHRydWUpLnNldFZhbHVlKCcxMDAlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCB0cnVlKS5zZXRWYWx1ZSgnMTAwJScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRTdHlsZSgnY29sb3InKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldFN0eWxlKCdjb2xvcicsIHRydWUpLnNldFZhbHVlKCdibGFjaycpO1xuICAgIH1cblxuICAgIHZhciByZWZYQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZYJyk7XG4gICAgdmFyIHJlZllBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlknKTtcbiAgICB2YXIgdmlld0JveEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgIHZhciB2aWV3Qm94ID0gdmlld0JveEF0dHIuaGFzVmFsdWUoKSA/IHRvTnVtYmVycyh2aWV3Qm94QXR0ci5nZXRTdHJpbmcoKSkgOiBudWxsO1xuICAgIHZhciBjbGlwID0gIXRoaXMucm9vdCAmJiB0aGlzLmdldFN0eWxlKCdvdmVyZmxvdycpLmdldFZhbHVlKCdoaWRkZW4nKSAhPT0gJ3Zpc2libGUnO1xuICAgIHZhciBtaW5YID0gMDtcbiAgICB2YXIgbWluWSA9IDA7XG4gICAgdmFyIGNsaXBYID0gMDtcbiAgICB2YXIgY2xpcFkgPSAwO1xuXG4gICAgaWYgKHZpZXdCb3gpIHtcbiAgICAgIG1pblggPSB2aWV3Qm94WzBdO1xuICAgICAgbWluWSA9IHZpZXdCb3hbMV07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnbWFya2VyJykge1xuICAgICAgICBjbGlwWCA9IG1pblg7XG4gICAgICAgIGNsaXBZID0gbWluWTtcbiAgICAgICAgbWluWCA9IDA7XG4gICAgICAgIG1pblkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNjcmVlbi52aWV3UG9ydC5zZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpOyAvLyBEZWZhdWx0IHZhbHVlIG9mIHRyYW5zZm9ybS1vcmlnaW4gaXMgY2VudGVyIG9ubHkgZm9yIHJvb3QgU1ZHIGVsZW1lbnRzXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS90cmFuc2Zvcm0tb3JpZ2luXG5cbiAgICBpZiAodGhpcy5ub2RlIC8vIGlzIG5vdCB0ZW1wb3JhcnkgU1ZHRWxlbWVudFxuICAgICYmICghdGhpcy5wYXJlbnQgfHwgKChfdGhpcyRub2RlJHBhcmVudE5vZGUgPSB0aGlzLm5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX3RoaXMkbm9kZSRwYXJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRub2RlJHBhcmVudE5vZGUubm9kZU5hbWUpID09PSAnZm9yZWlnbk9iamVjdCcpICYmIHRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCB0cnVlLCB0cnVlKS5zZXRWYWx1ZSgnNTAlIDUwJScpO1xuICAgIH1cblxuICAgIHN1cGVyLnNldENvbnRleHQoY3R4KTtcbiAgICBjdHgudHJhbnNsYXRlKHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4JyksIHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5JykpO1xuXG4gICAgaWYgKHZpZXdCb3gpIHtcbiAgICAgIHdpZHRoID0gdmlld0JveFsyXTtcbiAgICAgIGhlaWdodCA9IHZpZXdCb3hbM107XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuc2V0Vmlld0JveCh7XG4gICAgICBjdHgsXG4gICAgICBhc3BlY3RSYXRpbzogdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSxcbiAgICAgIHdpZHRoOiBzY3JlZW4udmlld1BvcnQud2lkdGgsXG4gICAgICBkZXNpcmVkV2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBzY3JlZW4udmlld1BvcnQuaGVpZ2h0LFxuICAgICAgZGVzaXJlZEhlaWdodDogaGVpZ2h0LFxuICAgICAgbWluWCxcbiAgICAgIG1pblksXG4gICAgICByZWZYOiByZWZYQXR0ci5nZXRWYWx1ZSgpLFxuICAgICAgcmVmWTogcmVmWUF0dHIuZ2V0VmFsdWUoKSxcbiAgICAgIGNsaXAsXG4gICAgICBjbGlwWCxcbiAgICAgIGNsaXBZXG4gICAgfSk7XG5cbiAgICBpZiAodmlld0JveCkge1xuICAgICAgc2NyZWVuLnZpZXdQb3J0LnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgIHNjcmVlbi52aWV3UG9ydC5zZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyQ29udGV4dChjdHgpIHtcbiAgICBzdXBlci5jbGVhckNvbnRleHQoY3R4KTtcbiAgICB0aGlzLmRvY3VtZW50LnNjcmVlbi52aWV3UG9ydC5yZW1vdmVDdXJyZW50KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzaXplIFNWRyB0byBmaXQgaW4gZ2l2ZW4gc2l6ZS5cclxuICAgKiBAcGFyYW0gd2lkdGhcclxuICAgKiBAcGFyYW0gaGVpZ2h0XHJcbiAgICogQHBhcmFtIHByZXNlcnZlQXNwZWN0UmF0aW9cclxuICAgKi9cblxuXG4gIHJlc2l6ZSh3aWR0aCkge1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHdpZHRoO1xuICAgIHZhciBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB2YXIgd2lkdGhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSk7XG4gICAgdmFyIGhlaWdodEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSk7XG4gICAgdmFyIHZpZXdCb3hBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKTtcbiAgICB2YXIgc3R5bGVBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgdmFyIG9yaWdpbldpZHRoID0gd2lkdGhBdHRyLmdldE51bWJlcigwKTtcbiAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gaGVpZ2h0QXR0ci5nZXROdW1iZXIoMCk7XG5cbiAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgaWYgKHR5cGVvZiBwcmVzZXJ2ZUFzcGVjdFJhdGlvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsIHRydWUpLnNldFZhbHVlKHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKTtcblxuICAgICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpb0F0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLnNldFZhbHVlKHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLmdldFN0cmluZygpLnJlcGxhY2UoL15cXHMqKFxcUy4qXFxTKVxccyokLywgJyQxJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2lkdGhBdHRyLnNldFZhbHVlKHdpZHRoKTtcbiAgICBoZWlnaHRBdHRyLnNldFZhbHVlKGhlaWdodCk7XG5cbiAgICBpZiAoIXZpZXdCb3hBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZpZXdCb3hBdHRyLnNldFZhbHVlKFwiMCAwIFwiLmNvbmNhdChvcmlnaW5XaWR0aCB8fCB3aWR0aCwgXCIgXCIpLmNvbmNhdChvcmlnaW5IZWlnaHQgfHwgaGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICB2YXIgd2lkdGhTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJyk7XG4gICAgICB2YXIgaGVpZ2h0U3R5bGUgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKTtcblxuICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICB3aWR0aFN0eWxlLnNldFZhbHVlKFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgaGVpZ2h0U3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBSZWN0RWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAncmVjdCc7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnLCBmYWxzZSwgdHJ1ZSkuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcsIGZhbHNlLCB0cnVlKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgcnhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J4Jyk7XG4gICAgdmFyIHJ5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeScpO1xuICAgIHZhciByeCA9IHJ4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgcnkgPSByeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICBpZiAocnhBdHRyLmhhc1ZhbHVlKCkgJiYgIXJ5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICByeSA9IHJ4O1xuICAgIH1cblxuICAgIGlmIChyeUF0dHIuaGFzVmFsdWUoKSAmJiAhcnhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJ4ID0gcnk7XG4gICAgfVxuXG4gICAgcnggPSBNYXRoLm1pbihyeCwgd2lkdGggLyAyLjApO1xuICAgIHJ5ID0gTWF0aC5taW4ocnksIGhlaWdodCAvIDIuMCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICB2YXIgS0FQUEEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpOyAvLyBhbHdheXMgc3RhcnQgdGhlIHBhdGggc28gd2UgZG9uJ3QgZmlsbCBwcmlvciBwYXRoc1xuXG4gICAgICBpZiAoaGVpZ2h0ID4gMCAmJiB3aWR0aCA+IDApIHtcbiAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcngsIHkpO1xuICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJ4LCB5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHdpZHRoIC0gcnggKyBLQVBQQSAqIHJ4LCB5LCB4ICsgd2lkdGgsIHkgKyByeSAtIEtBUFBBICogcnksIHggKyB3aWR0aCwgeSArIHJ5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJ5ICsgS0FQUEEgKiByeSwgeCArIHdpZHRoIC0gcnggKyBLQVBQQSAqIHJ4LCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByeCwgeSArIGhlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHJ4IC0gS0FQUEEgKiByeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJ5ICsgS0FQUEEgKiByeSwgeCwgeSArIGhlaWdodCAtIHJ5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcnkpO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5ICsgcnkgLSBLQVBQQSAqIHJ5LCB4ICsgcnggLSBLQVBQQSAqIHJ4LCB5LCB4ICsgcngsIHkpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICB9XG5cbiAgZ2V0TWFya2VycygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG5cbmNsYXNzIENpcmNsZUVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2NpcmNsZSc7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciBjeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBjeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldFBpeGVscygneScpO1xuICAgIHZhciByID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5nZXRQaXhlbHMoKTtcblxuICAgIGlmIChjdHggJiYgciA+IDApIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMoY3gsIGN5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goY3ggLSByLCBjeSAtIHIsIGN4ICsgciwgY3kgKyByKTtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxufVxuXG5jbGFzcyBFbGxpcHNlRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnZWxsaXBzZSc7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciBLQVBQQSA9IDQgKiAoKE1hdGguc3FydCgyKSAtIDEpIC8gMyk7XG4gICAgdmFyIHJ4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHJ5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIGN4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGN5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICBpZiAoY3R4ICYmIHJ4ID4gMCAmJiByeSA+IDApIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oY3ggKyByeCwgY3kpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggKyByeCwgY3kgKyBLQVBQQSAqIHJ5LCBjeCArIEtBUFBBICogcngsIGN5ICsgcnksIGN4LCBjeSArIHJ5KTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gS0FQUEEgKiByeCwgY3kgKyByeSwgY3ggLSByeCwgY3kgKyBLQVBQQSAqIHJ5LCBjeCAtIHJ4LCBjeSk7XG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCAtIHJ4LCBjeSAtIEtBUFBBICogcnksIGN4IC0gS0FQUEEgKiByeCwgY3kgLSByeSwgY3gsIGN5IC0gcnkpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggKyBLQVBQQSAqIHJ4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSAtIEtBUFBBICogcnksIGN4ICsgcngsIGN5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KGN4IC0gcngsIGN5IC0gcnksIGN4ICsgcngsIGN5ICsgcnkpO1xuICB9XG5cbiAgZ2V0TWFya2VycygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG5cbmNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdsaW5lJztcbiAgfVxuXG4gIGdldFBvaW50cygpIHtcbiAgICByZXR1cm4gW25ldyBQb2ludCh0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5nZXRQaXhlbHMoJ3gnKSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0UGl4ZWxzKCd5JykpLCBuZXcgUG9pbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuZ2V0UGl4ZWxzKCd4JyksIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmdldFBpeGVscygneScpKV07XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciBbe1xuICAgICAgeDogeDAsXG4gICAgICB5OiB5MFxuICAgIH0sIHtcbiAgICAgIHg6IHgxLFxuICAgICAgeTogeTFcbiAgICB9XSA9IHRoaXMuZ2V0UG9pbnRzKCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHgwLCB5MCk7XG4gICAgICBjdHgubGluZVRvKHgxLCB5MSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSk7XG4gIH1cblxuICBnZXRNYXJrZXJzKCkge1xuICAgIHZhciBbcDAsIHAxXSA9IHRoaXMuZ2V0UG9pbnRzKCk7XG4gICAgdmFyIGEgPSBwMC5hbmdsZVRvKHAxKTtcbiAgICByZXR1cm4gW1twMCwgYV0sIFtwMSwgYV1dO1xuICB9XG5cbn1cblxuY2xhc3MgUG9seWxpbmVFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAncG9seWxpbmUnO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5wb2ludHMgPSBQb2ludC5wYXJzZVBhdGgodGhpcy5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpLmdldFN0cmluZygpKTtcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50c1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBbe1xuICAgICAgeDogeDAsXG4gICAgICB5OiB5MFxuICAgIH1dID0gcG9pbnRzO1xuICAgIHZhciBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCh4MCwgeTApO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4MCwgeTApO1xuICAgIH1cblxuICAgIHBvaW50cy5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IF9yZWY7XG4gICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50c1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXggPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbWFya2VycyA9IFtdO1xuICAgIHBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xuICAgICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hcmtlcnMucHVzaChbcG9pbnQsIHBvaW50LmFuZ2xlVG8ocG9pbnRzW2kgKyAxXSldKTtcbiAgICB9KTtcblxuICAgIGlmIChtYXJrZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1hcmtlcnMucHVzaChbcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdWzFdXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmtlcnM7XG4gIH1cblxufVxuXG5jbGFzcyBQb2x5Z29uRWxlbWVudCBleHRlbmRzIFBvbHlsaW5lRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3BvbHlnb24nO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBzdXBlci5wYXRoKGN0eCk7XG4gICAgdmFyIFt7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH1dID0gdGhpcy5wb2ludHM7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgfVxuXG59XG5cbmNsYXNzIFBhdHRlcm5FbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3BhdHRlcm4nO1xuICB9XG5cbiAgY3JlYXRlUGF0dGVybihjdHgsIF8sIHBhcmVudE9wYWNpdHlQcm9wKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnLCB0cnVlKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5JywgdHJ1ZSk7IC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuXG4gICAgdmFyIHBhdHRlcm5TdmcgPSBuZXcgU1ZHRWxlbWVudCh0aGlzLmRvY3VtZW50LCBudWxsKTtcbiAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMudmlld0JveCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAndmlld0JveCcsIHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0VmFsdWUoKSk7XG4gICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd3aWR0aCcsIFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpKTtcbiAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdoZWlnaHQnLCBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIikpO1xuICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy50cmFuc2Zvcm0gPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3RyYW5zZm9ybScsIHRoaXMuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJykuZ2V0VmFsdWUoKSk7XG4gICAgcGF0dGVyblN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHBhdHRlcm5DYW52YXMgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgIHZhciB5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5Jyk7XG5cbiAgICBpZiAoeEF0dHIuaGFzVmFsdWUoKSAmJiB5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICBwYXR0ZXJuQ3R4LnRyYW5zbGF0ZSh4QXR0ci5nZXRQaXhlbHMoJ3gnLCB0cnVlKSwgeUF0dHIuZ2V0UGl4ZWxzKCd5JywgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnRPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLnN0eWxlc1snZmlsbC1vcGFjaXR5J10gPSBwYXJlbnRPcGFjaXR5UHJvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0aGlzLnN0eWxlcywgJ2ZpbGwtb3BhY2l0eScpO1xuICAgIH0gLy8gcmVuZGVyIDN4MyBncmlkIHNvIHdoZW4gd2UgdHJhbnNmb3JtIHRoZXJlJ3Mgbm8gd2hpdGUgc3BhY2Ugb24gZWRnZXNcblxuXG4gICAgZm9yICh2YXIgeCA9IC0xOyB4IDw9IDE7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IC0xOyB5IDw9IDE7IHkrKykge1xuICAgICAgICBwYXR0ZXJuQ3R4LnNhdmUoKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3gnLCB4ICogcGF0dGVybkNhbnZhcy53aWR0aCk7XG4gICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd5JywgeSAqIHBhdHRlcm5DYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgcGF0dGVyblN2Zy5yZW5kZXIocGF0dGVybkN0eCk7XG4gICAgICAgIHBhdHRlcm5DdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4ocGF0dGVybkNhbnZhcywgJ3JlcGVhdCcpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG5cbn1cblxuY2xhc3MgTWFya2VyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdtYXJrZXInO1xuICB9XG5cbiAgcmVuZGVyKGN0eCwgcG9pbnQsIGFuZ2xlKSB7XG4gICAgaWYgKCFwb2ludCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICB2YXIgb3JpZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29yaWVudCcpLmdldFN0cmluZygnYXV0bycpO1xuICAgIHZhciBtYXJrZXJVbml0cyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXJrZXJVbml0cycpLmdldFN0cmluZygnc3Ryb2tlV2lkdGgnKTtcbiAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgaWYgKG9yaWVudCA9PT0gJ2F1dG8nKSB7XG4gICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICB9XG5cbiAgICBpZiAobWFya2VyVW5pdHMgPT09ICdzdHJva2VXaWR0aCcpIHtcbiAgICAgIGN0eC5zY2FsZShjdHgubGluZVdpZHRoLCBjdHgubGluZVdpZHRoKTtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpOyAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnRcblxuICAgIHZhciBtYXJrZXJTdmcgPSBuZXcgU1ZHRWxlbWVudCh0aGlzLmRvY3VtZW50LCBudWxsKTtcbiAgICBtYXJrZXJTdmcudHlwZSA9IHRoaXMudHlwZTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy52aWV3Qm94ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd2aWV3Qm94JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5yZWZYID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdyZWZYJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlgnKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5yZWZZID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdyZWZZJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlknKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnd2lkdGgnLCB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VyV2lkdGgnKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2hlaWdodCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdtYXJrZXJIZWlnaHQnKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5vdmVyZmxvdyA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnb3ZlcmZsb3cnLCB0aGlzLmdldEF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5maWxsID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdmaWxsJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKS5nZXRDb2xvcignYmxhY2snKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuc3Ryb2tlID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdzdHJva2UnLCB0aGlzLmdldEF0dHJpYnV0ZSgnc3Ryb2tlJykuZ2V0VmFsdWUoJ25vbmUnKSk7XG4gICAgbWFya2VyU3ZnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBtYXJrZXJTdmcucmVuZGVyKGN0eCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcblxuICAgIGlmIChtYXJrZXJVbml0cyA9PT0gJ3N0cm9rZVdpZHRoJykge1xuICAgICAgY3R4LnNjYWxlKDEgLyBjdHgubGluZVdpZHRoLCAxIC8gY3R4LmxpbmVXaWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKG9yaWVudCA9PT0gJ2F1dG8nKSB7XG4gICAgICBjdHgucm90YXRlKC1hbmdsZSk7XG4gICAgfVxuXG4gICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG5cbn1cblxuY2xhc3MgRGVmc0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnZGVmcyc7XG4gIH1cblxuICByZW5kZXIoKSB7Ly8gTk9PUFxuICB9XG5cbn1cblxuY2xhc3MgR0VsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdnJztcbiAgfVxuXG4gIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgIHZhciBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxufVxuXG5jbGFzcyBHcmFkaWVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0ID0gWydncmFkaWVudFVuaXRzJ107XG4gICAgdGhpcy5zdG9wcyA9IFtdO1xuICAgIHZhciB7XG4gICAgICBzdG9wcyxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IHRoaXM7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3N0b3AnKSB7XG4gICAgICAgIHN0b3BzLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0R3JhZGllbnRVbml0cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnKS5nZXRTdHJpbmcoJ29iamVjdEJvdW5kaW5nQm94Jyk7XG4gIH1cblxuICBjcmVhdGVHcmFkaWVudChjdHgsIGVsZW1lbnQsIHBhcmVudE9wYWNpdHlQcm9wKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLCBjb25zaXN0ZW50LXRoaXNcbiAgICB2YXIgc3RvcHNDb250YWluZXIgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHN0b3BzQ29udGFpbmVyID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgdGhpcy5pbmhlcml0U3RvcENvbnRhaW5lcihzdG9wc0NvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHN0b3BzXG4gICAgfSA9IHN0b3BzQ29udGFpbmVyO1xuICAgIHZhciBncmFkaWVudCA9IHRoaXMuZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KTtcblxuICAgIGlmICghZ3JhZGllbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdLmNvbG9yKTtcbiAgICB9XG5cbiAgICBzdG9wcy5mb3JFYWNoKHN0b3AgPT4ge1xuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3Aub2Zmc2V0LCB0aGlzLmFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIHN0b3AuY29sb3IpKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAvLyByZW5kZXIgYXMgdHJhbnNmb3JtZWQgcGF0dGVybiBvbiB0ZW1wb3JhcnkgY2FudmFzXG4gICAgICB2YXIge1xuICAgICAgICBkb2N1bWVudFxuICAgICAgfSA9IHRoaXM7XG4gICAgICB2YXIge1xuICAgICAgICBNQVhfVklSVFVBTF9QSVhFTFMsXG4gICAgICAgIHZpZXdQb3J0XG4gICAgICB9ID0gZG9jdW1lbnQuc2NyZWVuO1xuICAgICAgdmFyIFtyb290Vmlld10gPSB2aWV3UG9ydC52aWV3UG9ydHM7XG4gICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0RWxlbWVudChkb2N1bWVudCwgbnVsbCk7XG4gICAgICByZWN0LmF0dHJpYnV0ZXMueCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3gnLCAtTUFYX1ZJUlRVQUxfUElYRUxTIC8gMy4wKTtcbiAgICAgIHJlY3QuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneScsIC1NQVhfVklSVFVBTF9QSVhFTFMgLyAzLjApO1xuICAgICAgcmVjdC5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCBNQVhfVklSVFVBTF9QSVhFTFMpO1xuICAgICAgcmVjdC5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIE1BWF9WSVJUVUFMX1BJWEVMUyk7XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgR0VsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgZ3JvdXAuYXR0cmlidXRlcy50cmFuc2Zvcm0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd0cmFuc2Zvcm0nLCB0aGlzLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKS5nZXRWYWx1ZSgpKTtcbiAgICAgIGdyb3VwLmNoaWxkcmVuID0gW3JlY3RdO1xuICAgICAgdmFyIHBhdHRlcm5TdmcgPSBuZXcgU1ZHRWxlbWVudChkb2N1bWVudCwgbnVsbCk7XG4gICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3gnLCAwKTtcbiAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneScsIDApO1xuICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCByb290Vmlldy53aWR0aCk7XG4gICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnaGVpZ2h0Jywgcm9vdFZpZXcuaGVpZ2h0KTtcbiAgICAgIHBhdHRlcm5TdmcuY2hpbGRyZW4gPSBbZ3JvdXBdO1xuICAgICAgdmFyIHBhdHRlcm5DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXMocm9vdFZpZXcud2lkdGgsIHJvb3RWaWV3LmhlaWdodCk7XG4gICAgICB2YXIgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICBwYXR0ZXJuU3ZnLnJlbmRlcihwYXR0ZXJuQ3R4KTtcbiAgICAgIHJldHVybiBwYXR0ZXJuQ3R4LmNyZWF0ZVBhdHRlcm4ocGF0dGVybkNhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBncmFkaWVudDtcbiAgfVxuXG4gIGluaGVyaXRTdG9wQ29udGFpbmVyKHN0b3BzQ29udGFpbmVyKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LmZvckVhY2goYXR0cmlidXRlVG9Jbmhlcml0ID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5oYXNWYWx1ZSgpICYmIHN0b3BzQ29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0LCB0cnVlKS5zZXRWYWx1ZShzdG9wc0NvbnRhaW5lci5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIGNvbG9yKSB7XG4gICAgaWYgKHBhcmVudE9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZhciBjb2xvclByb3AgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2NvbG9yJywgY29sb3IpO1xuICAgICAgcmV0dXJuIGNvbG9yUHJvcC5hZGRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wKS5nZXRDb2xvcigpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG59XG5cbmNsYXNzIExpbmVhckdyYWRpZW50RWxlbWVudCBleHRlbmRzIEdyYWRpZW50RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdsaW5lYXJHcmFkaWVudCc7XG4gICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ3gxJywgJ3kxJywgJ3gyJywgJ3kyJyk7XG4gIH1cblxuICBnZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpIHtcbiAgICB2YXIgaXNCb3VuZGluZ0JveFVuaXRzID0gdGhpcy5nZXRHcmFkaWVudFVuaXRzKCkgPT09ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpIDogbnVsbDtcblxuICAgIGlmIChpc0JvdW5kaW5nQm94VW5pdHMgJiYgIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd4MScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneDInLCB0cnVlKS5zZXRWYWx1ZSgxKTtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicsIHRydWUpLnNldFZhbHVlKDApO1xuICAgIH1cblxuICAgIHZhciB4MSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkxID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHgyID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgeTIgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgIGlmICh4MSA9PT0geDIgJiYgeTEgPT09IHkyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKTtcbiAgfVxuXG59XG5cbmNsYXNzIFJhZGlhbEdyYWRpZW50RWxlbWVudCBleHRlbmRzIEdyYWRpZW50RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdyYWRpYWxHcmFkaWVudCc7XG4gICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ2N4JywgJ2N5JywgJ3InLCAnZngnLCAnZnknLCAnZnInKTtcbiAgfVxuXG4gIGdldEdyYWRpZW50KGN0eCwgZWxlbWVudCkge1xuICAgIHZhciBpc0JvdW5kaW5nQm94VW5pdHMgPSB0aGlzLmdldEdyYWRpZW50VW5pdHMoKSA9PT0gJ29iamVjdEJvdW5kaW5nQm94JztcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCk7XG5cbiAgICBpZiAoaXNCb3VuZGluZ0JveFVuaXRzICYmICFib3VuZGluZ0JveCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnY3knLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgncicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdyJywgdHJ1ZSkuc2V0VmFsdWUoJzUwJScpO1xuICAgIH1cblxuICAgIHZhciBjeCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGN5ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIGZ4ID0gY3g7XG4gICAgdmFyIGZ5ID0gY3k7XG5cbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuaGFzVmFsdWUoKSkge1xuICAgICAgZnggPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgnZngnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdmeCcpLmdldFBpeGVscygneCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICBmeSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdmeScpLmdldFBpeGVscygneScpO1xuICAgIH1cblxuICAgIHZhciByID0gaXNCb3VuZGluZ0JveFVuaXRzID8gKGJvdW5kaW5nQm94LndpZHRoICsgYm91bmRpbmdCb3guaGVpZ2h0KSAvIDIuMCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgncicpLmdldFBpeGVscygpO1xuICAgIHZhciBmciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmcicpLmdldFBpeGVscygpO1xuICAgIHJldHVybiBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoZngsIGZ5LCBmciwgY3gsIGN5LCByKTtcbiAgfVxuXG59XG5cbmNsYXNzIFN0b3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdzdG9wJztcbiAgICB2YXIgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpLmdldE51bWJlcigpKSk7XG4gICAgdmFyIHN0b3BPcGFjaXR5ID0gdGhpcy5nZXRTdHlsZSgnc3RvcC1vcGFjaXR5Jyk7XG4gICAgdmFyIHN0b3BDb2xvciA9IHRoaXMuZ2V0U3R5bGUoJ3N0b3AtY29sb3InLCB0cnVlKTtcblxuICAgIGlmIChzdG9wQ29sb3IuZ2V0U3RyaW5nKCkgPT09ICcnKSB7XG4gICAgICBzdG9wQ29sb3Iuc2V0VmFsdWUoJyMwMDAnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RvcE9wYWNpdHkuaGFzVmFsdWUoKSkge1xuICAgICAgc3RvcENvbG9yID0gc3RvcENvbG9yLmFkZE9wYWNpdHkoc3RvcE9wYWNpdHkpO1xuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMuY29sb3IgPSBzdG9wQ29sb3IuZ2V0Q29sb3IoKTtcbiAgfVxuXG59XG5cbmNsYXNzIEFuaW1hdGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdhbmltYXRlJztcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsVW5pdHMgPSAnJztcbiAgICB0aGlzLnJlbW92ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xuICAgIGRvY3VtZW50LnNjcmVlbi5hbmltYXRpb25zLnB1c2godGhpcyk7XG4gICAgdGhpcy5iZWdpbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdiZWdpbicpLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIHRoaXMubWF4RHVyYXRpb24gPSB0aGlzLmJlZ2luICsgdGhpcy5nZXRBdHRyaWJ1dGUoJ2R1cicpLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIHRoaXMuZnJvbSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmcm9tJyk7XG4gICAgdGhpcy50byA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0bycpO1xuICAgIHRoaXMudmFsdWVzID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndmFsdWVzJywgbnVsbCk7XG4gICAgdmFyIHZhbHVlc0F0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWVzJyk7XG5cbiAgICBpZiAodmFsdWVzQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLnZhbHVlcy5zZXRWYWx1ZSh2YWx1ZXNBdHRyLmdldFN0cmluZygpLnNwbGl0KCc7JykpO1xuICAgIH1cbiAgfVxuXG4gIGdldFByb3BlcnR5KCkge1xuICAgIHZhciBhdHRyaWJ1dGVUeXBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F0dHJpYnV0ZVR5cGUnKS5nZXRTdHJpbmcoKTtcbiAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdHRyaWJ1dGVOYW1lJykuZ2V0U3RyaW5nKCk7XG5cbiAgICBpZiAoYXR0cmlidXRlVHlwZSA9PT0gJ0NTUycpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRTdHlsZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xuICB9XG5cbiAgY2FsY1ZhbHVlKCkge1xuICAgIHZhciB7XG4gICAgICBpbml0aWFsVW5pdHNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgcHJvZ3Jlc3MsXG4gICAgICBmcm9tLFxuICAgICAgdG9cbiAgICB9ID0gdGhpcy5nZXRQcm9ncmVzcygpOyAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuXG4gICAgdmFyIG5ld1ZhbHVlID0gZnJvbS5nZXROdW1iZXIoKSArICh0by5nZXROdW1iZXIoKSAtIGZyb20uZ2V0TnVtYmVyKCkpICogcHJvZ3Jlc3M7XG5cbiAgICBpZiAoaW5pdGlhbFVuaXRzID09PSAnJScpIHtcbiAgICAgIG5ld1ZhbHVlICo9IDEwMC4wOyAvLyBudW1WYWx1ZSgpIHJldHVybnMgMC0xIHdoZXJlYXMgcHJvcGVydGllcyBhcmUgMC0xMDBcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQobmV3VmFsdWUpLmNvbmNhdChpbml0aWFsVW5pdHMpO1xuICB9XG5cbiAgdXBkYXRlKGRlbHRhKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBwcm9wID0gdGhpcy5nZXRQcm9wZXJ0eSgpOyAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuXG4gICAgaWYgKCF0aGlzLmluaXRpYWxWYWx1ZSkge1xuICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBwcm9wLmdldFN0cmluZygpO1xuICAgICAgdGhpcy5pbml0aWFsVW5pdHMgPSBwcm9wLmdldFVuaXRzKCk7XG4gICAgfSAvLyBpZiB3ZSdyZSBwYXN0IHRoZSBlbmQgdGltZVxuXG5cbiAgICBpZiAodGhpcy5kdXJhdGlvbiA+IHRoaXMubWF4RHVyYXRpb24pIHtcbiAgICAgIHZhciBmaWxsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKS5nZXRTdHJpbmcoJ3JlbW92ZScpOyAvLyBsb29wIGZvciBpbmRlZmluaXRlbHkgcmVwZWF0aW5nIGFuaW1hdGlvbnNcblxuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdyZXBlYXRDb3VudCcpLmdldFN0cmluZygpID09PSAnaW5kZWZpbml0ZScgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlcGVhdER1cicpLmdldFN0cmluZygpID09PSAnaW5kZWZpbml0ZScpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGZpbGwgPT09ICdmcmVlemUnICYmICF0aGlzLmZyb3plbikge1xuICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gICAgICAgIHBhcmVudC5hbmltYXRpb25Gcm96ZW4gPSB0cnVlO1xuICAgICAgICBwYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgPSBwcm9wLmdldFN0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChmaWxsID09PSAncmVtb3ZlJyAmJiAhdGhpcy5yZW1vdmVkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIHByb3Auc2V0VmFsdWUocGFyZW50LmFuaW1hdGlvbkZyb3plbiA/IHBhcmVudC5hbmltYXRpb25Gcm96ZW5WYWx1ZSA6IHRoaXMuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmR1cmF0aW9uICs9IGRlbHRhOyAvLyBpZiB3ZSdyZSBwYXN0IHRoZSBiZWdpbiB0aW1lXG5cbiAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuYmVnaW4gPCB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNhbGNWYWx1ZSgpOyAvLyB0d2VlblxuXG4gICAgICB2YXIgdHlwZUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXG4gICAgICBpZiAodHlwZUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAvLyBmb3IgdHJhbnNmb3JtLCBldGMuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZUF0dHIuZ2V0U3RyaW5nKCk7XG4gICAgICAgIG5ld1ZhbHVlID0gXCJcIi5jb25jYXQodHlwZSwgXCIoXCIpLmNvbmNhdChuZXdWYWx1ZSwgXCIpXCIpO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVkO1xuICB9XG5cbiAgZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgdmFsdWVzXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHByb2dyZXNzOiAodGhpcy5kdXJhdGlvbiAtIHRoaXMuYmVnaW4pIC8gKHRoaXMubWF4RHVyYXRpb24gLSB0aGlzLmJlZ2luKVxuICAgIH07XG5cbiAgICBpZiAodmFsdWVzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnByb2dyZXNzICogKHZhbHVlcy5nZXRWYWx1ZSgpLmxlbmd0aCAtIDEpO1xuICAgICAgdmFyIGxiID0gTWF0aC5mbG9vcihwKTtcbiAgICAgIHZhciB1YiA9IE1hdGguY2VpbChwKTtcbiAgICAgIHJlc3VsdC5mcm9tID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZnJvbScsIHBhcnNlRmxvYXQodmFsdWVzLmdldFZhbHVlKClbbGJdKSk7XG4gICAgICByZXN1bHQudG8gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd0bycsIHBhcnNlRmxvYXQodmFsdWVzLmdldFZhbHVlKClbdWJdKSk7XG4gICAgICByZXN1bHQucHJvZ3Jlc3MgPSAocCAtIGxiKSAvICh1YiAtIGxiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LmZyb20gPSB0aGlzLmZyb207XG4gICAgICByZXN1bHQudG8gPSB0aGlzLnRvO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxufVxuXG5jbGFzcyBBbmltYXRlQ29sb3JFbGVtZW50IGV4dGVuZHMgQW5pbWF0ZUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdhbmltYXRlQ29sb3InO1xuICB9XG5cbiAgY2FsY1ZhbHVlKCkge1xuICAgIHZhciB7XG4gICAgICBwcm9ncmVzcyxcbiAgICAgIGZyb20sXG4gICAgICB0b1xuICAgIH0gPSB0aGlzLmdldFByb2dyZXNzKCk7XG4gICAgdmFyIGNvbG9yRnJvbSA9IG5ldyBSR0JDb2xvcihmcm9tLmdldENvbG9yKCkpO1xuICAgIHZhciBjb2xvclRvID0gbmV3IFJHQkNvbG9yKHRvLmdldENvbG9yKCkpO1xuXG4gICAgaWYgKGNvbG9yRnJvbS5vayAmJiBjb2xvclRvLm9rKSB7XG4gICAgICAvLyB0d2VlbiBjb2xvciBsaW5lYXJseVxuICAgICAgdmFyIHIgPSBjb2xvckZyb20uciArIChjb2xvclRvLnIgLSBjb2xvckZyb20ucikgKiBwcm9ncmVzcztcbiAgICAgIHZhciBnID0gY29sb3JGcm9tLmcgKyAoY29sb3JUby5nIC0gY29sb3JGcm9tLmcpICogcHJvZ3Jlc3M7XG4gICAgICB2YXIgYiA9IGNvbG9yRnJvbS5iICsgKGNvbG9yVG8uYiAtIGNvbG9yRnJvbS5iKSAqIHByb2dyZXNzOyAvLyA/IGFscGhhXG5cbiAgICAgIHJldHVybiBcInJnYihcIi5jb25jYXQoTWF0aC5mbG9vcihyKSwgXCIsIFwiKS5jb25jYXQoTWF0aC5mbG9vcihnKSwgXCIsIFwiKS5jb25jYXQoTWF0aC5mbG9vcihiKSwgXCIpXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZnJvbScpLmdldENvbG9yKCk7XG4gIH1cblxufVxuXG5jbGFzcyBBbmltYXRlVHJhbnNmb3JtRWxlbWVudCBleHRlbmRzIEFuaW1hdGVFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnYW5pbWF0ZVRyYW5zZm9ybSc7XG4gIH1cblxuICBjYWxjVmFsdWUoKSB7XG4gICAgdmFyIHtcbiAgICAgIHByb2dyZXNzLFxuICAgICAgZnJvbSxcbiAgICAgIHRvXG4gICAgfSA9IHRoaXMuZ2V0UHJvZ3Jlc3MoKTsgLy8gdHdlZW4gdmFsdWUgbGluZWFybHlcblxuICAgIHZhciB0cmFuc2Zvcm1Gcm9tID0gdG9OdW1iZXJzKGZyb20uZ2V0U3RyaW5nKCkpO1xuICAgIHZhciB0cmFuc2Zvcm1UbyA9IHRvTnVtYmVycyh0by5nZXRTdHJpbmcoKSk7XG4gICAgdmFyIG5ld1ZhbHVlID0gdHJhbnNmb3JtRnJvbS5tYXAoKGZyb20sIGkpID0+IHtcbiAgICAgIHZhciB0byA9IHRyYW5zZm9ybVRvW2ldO1xuICAgICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIHByb2dyZXNzO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgICByZXR1cm4gbmV3VmFsdWU7XG4gIH1cblxufVxuXG5jbGFzcyBGb250RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnZm9udCc7XG4gICAgdGhpcy5nbHlwaHMgPSB7fTtcbiAgICB0aGlzLmhvcml6QWR2WCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdob3Jpei1hZHYteCcpLmdldE51bWJlcigpO1xuICAgIHZhciB7XG4gICAgICBkZWZpbml0aW9uc1xuICAgIH0gPSBkb2N1bWVudDtcbiAgICB2YXIge1xuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gdGhpcztcblxuICAgIGZvciAodmFyIGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBzd2l0Y2ggKGNoaWxkLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZvbnRGYWNlID0gY2hpbGQ7XG4gICAgICAgICAgICB2YXIgZm9udEZhbWlseVN0eWxlID0gY2hpbGQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5Jyk7XG5cbiAgICAgICAgICAgIGlmIChmb250RmFtaWx5U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICBkZWZpbml0aW9uc1tmb250RmFtaWx5U3R5bGUuZ2V0U3RyaW5nKCldID0gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgICAgIHRoaXMubWlzc2luZ0dseXBoID0gY2hpbGQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZ2x5cGgnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGNoaWxkO1xuXG4gICAgICAgICAgICBpZiAoZ2x5cGguYXJhYmljRm9ybSkge1xuICAgICAgICAgICAgICB0aGlzLmlzUlRMID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5pc0FyYWJpYyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdseXBoc1tnbHlwaC51bmljb2RlXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdseXBoc1tnbHlwaC51bmljb2RlXSA9IHt9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV1bZ2x5cGguYXJhYmljRm9ybV0gPSBnbHlwaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2dseXBoLnVuaWNvZGVdID0gZ2x5cGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxufVxuXG5jbGFzcyBGb250RmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ZvbnQtZmFjZSc7XG4gICAgdGhpcy5hc2NlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXNjZW50JykuZ2V0TnVtYmVyKCk7XG4gICAgdGhpcy5kZXNjZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Rlc2NlbnQnKS5nZXROdW1iZXIoKTtcbiAgICB0aGlzLnVuaXRzUGVyRW0gPSB0aGlzLmdldEF0dHJpYnV0ZSgndW5pdHMtcGVyLWVtJykuZ2V0TnVtYmVyKCk7XG4gIH1cblxufVxuXG5jbGFzcyBNaXNzaW5nR2x5cGhFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdtaXNzaW5nLWdseXBoJztcbiAgICB0aGlzLmhvcml6QWR2WCA9IDA7XG4gIH1cblxufVxuXG5jbGFzcyBUUmVmRWxlbWVudCBleHRlbmRzIFRleHRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAndHJlZic7XG4gIH1cblxuICBnZXRUZXh0KCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBmaXJzdENoaWxkID0gZWxlbWVudC5jaGlsZHJlblswXTtcblxuICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQuZ2V0VGV4dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxuXG59XG5cbmNsYXNzIEFFbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnYSc7XG4gICAgdmFyIHtcbiAgICAgIGNoaWxkTm9kZXNcbiAgICB9ID0gbm9kZTtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IGNoaWxkTm9kZXNbMF07XG4gICAgdmFyIGhhc1RleHQgPSBjaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiYgQXJyYXkuZnJvbShjaGlsZE5vZGVzKS5ldmVyeShub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IDMpO1xuICAgIHRoaXMuaGFzVGV4dCA9IGhhc1RleHQ7XG4gICAgdGhpcy50ZXh0ID0gaGFzVGV4dCA/IHRoaXMuZ2V0VGV4dEZyb21Ob2RlKGZpcnN0Q2hpbGQpIDogJyc7XG4gIH1cblxuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICBpZiAodGhpcy5oYXNUZXh0KSB7XG4gICAgICAvLyByZW5kZXIgYXMgdGV4dCBlbGVtZW50XG4gICAgICBzdXBlci5yZW5kZXJDaGlsZHJlbihjdHgpO1xuICAgICAgdmFyIHtcbiAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgdmFyIHtcbiAgICAgICAgbW91c2VcbiAgICAgIH0gPSBkb2N1bWVudC5zY3JlZW47XG4gICAgICB2YXIgZm9udFNpemUgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdmb250U2l6ZScsIEZvbnQucGFyc2UoZG9jdW1lbnQuY3R4LmZvbnQpLmZvbnRTaXplKTsgLy8gRG8gbm90IGNhbGMgYm91bmRpbmcgYm94IGlmIG1vdXNlIGlzIG5vdCB3b3JraW5nLlxuXG4gICAgICBpZiAobW91c2UuaXNXb3JraW5nKCkpIHtcbiAgICAgICAgbW91c2UuY2hlY2tCb3VuZGluZ0JveCh0aGlzLCBuZXcgQm91bmRpbmdCb3goeCwgeSAtIGZvbnRTaXplLmdldFBpeGVscygneScpLCB4ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB5KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHJlbmRlciBhcyB0ZW1wb3JhcnkgZ3JvdXBcbiAgICAgIHZhciBnID0gbmV3IEdFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG51bGwpO1xuICAgICAgZy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICBnLnBhcmVudCA9IHRoaXM7XG4gICAgICBnLnJlbmRlcihjdHgpO1xuICAgIH1cbiAgfVxuXG4gIG9uQ2xpY2soKSB7XG4gICAgdmFyIHtcbiAgICAgIHdpbmRvd1xuICAgIH0gPSB0aGlzLmRvY3VtZW50O1xuXG4gICAgaWYgKHdpbmRvdykge1xuICAgICAgd2luZG93Lm9wZW4odGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0U3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VNb3ZlKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmRvY3VtZW50LmN0eDtcbiAgICBjdHguY2FudmFzLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuY2xhc3MgVGV4dFBhdGhFbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAndGV4dFBhdGgnO1xuICAgIHRoaXMudGV4dFdpZHRoID0gMDtcbiAgICB0aGlzLnRleHRIZWlnaHQgPSAwO1xuICAgIHRoaXMucGF0aExlbmd0aCA9IC0xO1xuICAgIHRoaXMuZ2x5cGhJbmZvID0gbnVsbDtcbiAgICB0aGlzLmxldHRlclNwYWNpbmdDYWNoZSA9IFtdO1xuICAgIHRoaXMubWVhc3VyZXNDYWNoZSA9IG5ldyBNYXAoW1snJywgMF1dKTtcbiAgICB2YXIgcGF0aEVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy5nZXRUZXh0RnJvbU5vZGUoKTtcbiAgICB0aGlzLmRhdGFBcnJheSA9IHRoaXMucGFyc2VQYXRoRGF0YShwYXRoRWxlbWVudCk7XG4gIH1cblxuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBkYXRhQXJyYXlcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBkYXRhQXJyYXkuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSA9IF9yZWY7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTU9WRV9UTzpcbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBbY3gsIGN5LCByeCwgcnksIHRoZXRhLCBkVGhldGEsIHBzaSwgZnNdID0gcG9pbnRzO1xuICAgICAgICAgICAgdmFyIHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICAgIHZhciBzY2FsZVggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICB2YXIgc2NhbGVZID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xuXG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgQm9vbGVhbigxIC0gZnMpKTtcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICBjdHgucm90YXRlKC1wc2kpO1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIHRoaXMuc2V0VGV4dERhdGEoY3R4KTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIHZhciB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMucGFyZW50LmdldFN0eWxlKCd0ZXh0LWRlY29yYXRpb24nKS5nZXRTdHJpbmcoKTtcbiAgICB2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgdmFyIHtcbiAgICAgIGdseXBoSW5mb1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBmaWxsID0gY3R4LmZpbGxTdHlsZTtcblxuICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBnbHlwaEluZm8uZm9yRWFjaCgoZ2x5cGgsIGkpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHAwLFxuICAgICAgICBwMSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHRleHQ6IHBhcnRpYWxUZXh0XG4gICAgICB9ID0gZ2x5cGg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZShwMC54LCBwMC55KTtcbiAgICAgIGN0eC5yb3RhdGUocm90YXRpb24pO1xuXG4gICAgICBpZiAoY3R4LmZpbGxTdHlsZSkge1xuICAgICAgICBjdHguZmlsbFRleHQocGFydGlhbFRleHQsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlKSB7XG4gICAgICAgIGN0eC5zdHJva2VUZXh0KHBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGN0eC5tb3ZlVG8ocDAueCwgcDAueSArIGZvbnRTaXplIC8gOCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkgKyBmb250U2l6ZSAvIDUpO1xuICAgICAgfSAvLyAvLyBUbyBhc3Npc3Qgd2l0aCBkZWJ1Z2dpbmcgdmlzdWFsbHksIHVuY29tbWVudCBmb2xsb3dpbmdcbiAgICAgIC8vXG4gICAgICAvLyBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAvLyBpZiAoaSAlIDIpXG4gICAgICAvLyBcdGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgLy8gZWxzZVxuICAgICAgLy8gXHRjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgLy8gY3R4Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgIC8vIGN0eC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICAvLyBjdHguc3Ryb2tlKCk7XG4gICAgICAvLyBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICB9KTtcblxuICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBmb250U2l6ZSAvIDIwO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZmlsbDtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgZ2V0TGV0dGVyU3BhY2luZ0F0KCkge1xuICAgIHZhciBpZHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgcmV0dXJuIHRoaXMubGV0dGVyU3BhY2luZ0NhY2hlW2lkeF0gfHwgMDtcbiAgfVxuXG4gIGZpbmRTZWdtZW50VG9GaXRDaGFyKGN0eCwgYW5jaG9yLCB0ZXh0RnVsbFdpZHRoLCBmdWxsUGF0aFdpZHRoLCBzcGFjZXNOdW1iZXIsIGlucHV0T2Zmc2V0LCBkeSwgYywgY2hhckkpIHtcbiAgICB2YXIgb2Zmc2V0ID0gaW5wdXRPZmZzZXQ7XG4gICAgdmFyIGdseXBoV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGN0eCwgYyk7XG5cbiAgICBpZiAoYyA9PT0gJyAnICYmIGFuY2hvciA9PT0gJ2p1c3RpZnknICYmIHRleHRGdWxsV2lkdGggPCBmdWxsUGF0aFdpZHRoKSB7XG4gICAgICBnbHlwaFdpZHRoICs9IChmdWxsUGF0aFdpZHRoIC0gdGV4dEZ1bGxXaWR0aCkgLyBzcGFjZXNOdW1iZXI7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJJID4gLTEpIHtcbiAgICAgIG9mZnNldCArPSB0aGlzLmdldExldHRlclNwYWNpbmdBdChjaGFySSk7XG4gICAgfVxuXG4gICAgdmFyIHNwbGluZVN0ZXAgPSB0aGlzLnRleHRIZWlnaHQgLyAyMDtcbiAgICB2YXIgcDAgPSB0aGlzLmdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgob2Zmc2V0LCBzcGxpbmVTdGVwLCAwKTtcbiAgICB2YXIgcDEgPSB0aGlzLmdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgob2Zmc2V0ICsgZ2x5cGhXaWR0aCwgc3BsaW5lU3RlcCwgMCk7XG4gICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICBwMCxcbiAgICAgIHAxXG4gICAgfTtcbiAgICB2YXIgcm90YXRpb24gPSBwMCAmJiBwMSA/IE1hdGguYXRhbjIocDEueSAtIHAwLnksIHAxLnggLSBwMC54KSA6IDA7XG5cbiAgICBpZiAoZHkpIHtcbiAgICAgIHZhciBkeVggPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiArIHJvdGF0aW9uKSAqIGR5O1xuICAgICAgdmFyIGR5WSA9IE1hdGguY29zKC1yb3RhdGlvbikgKiBkeTtcbiAgICAgIHNlZ21lbnQucDAgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBwMCksIHt9LCB7XG4gICAgICAgIHg6IHAwLnggKyBkeVgsXG4gICAgICAgIHk6IHAwLnkgKyBkeVlcbiAgICAgIH0pO1xuICAgICAgc2VnbWVudC5wMSA9IF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIHAxKSwge30sIHtcbiAgICAgICAgeDogcDEueCArIGR5WCxcbiAgICAgICAgeTogcDEueSArIGR5WVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IGdseXBoV2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICByb3RhdGlvblxuICAgIH07XG4gIH1cblxuICBtZWFzdXJlVGV4dChjdHgsIHRleHQpIHtcbiAgICB2YXIge1xuICAgICAgbWVhc3VyZXNDYWNoZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0YXJnZXRUZXh0ID0gdGV4dCB8fCB0aGlzLmdldFRleHQoKTtcblxuICAgIGlmIChtZWFzdXJlc0NhY2hlLmhhcyh0YXJnZXRUZXh0KSkge1xuICAgICAgcmV0dXJuIG1lYXN1cmVzQ2FjaGUuZ2V0KHRhcmdldFRleHQpO1xuICAgIH1cblxuICAgIHZhciBtZWFzdXJlID0gdGhpcy5tZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHRhcmdldFRleHQpO1xuICAgIG1lYXN1cmVzQ2FjaGUuc2V0KHRhcmdldFRleHQsIG1lYXN1cmUpO1xuICAgIHJldHVybiBtZWFzdXJlO1xuICB9IC8vIFRoaXMgbWV0aG9kIHN1cHBvc2VzIHdoYXQgYWxsIGN1c3RvbSBmb250cyBhbHJlYWR5IGxvYWRlZC5cbiAgLy8gSWYgc29tZSBmb250IHdpbGwgYmUgbG9hZGVkIGFmdGVyIHRoaXMgbWV0aG9kIGNhbGwsIDx0ZXh0UGF0aD4gd2lsbCBub3QgYmUgcmVuZGVyZWQgY29ycmVjdGx5LlxuICAvLyBZb3UgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIG1hbnVhbGx5IHRvIHVwZGF0ZSBnbHlwaHMgY2FjaGUuXG5cblxuICBzZXRUZXh0RGF0YShjdHgpIHtcbiAgICBpZiAodGhpcy5nbHlwaEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBjaGFycyA9IHJlbmRlclRleHQuc3BsaXQoJycpO1xuICAgIHZhciBzcGFjZXNOdW1iZXIgPSByZW5kZXJUZXh0LnNwbGl0KCcgJykubGVuZ3RoIC0gMTtcbiAgICB2YXIgZHggPSB0aGlzLnBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4Jykuc3BsaXQoKS5tYXAoXyA9PiBfLmdldFBpeGVscygneCcpKTtcbiAgICB2YXIgZHkgPSB0aGlzLnBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIGFuY2hvciA9IHRoaXMucGFyZW50LmdldFN0eWxlKCd0ZXh0LWFuY2hvcicpLmdldFN0cmluZygnc3RhcnQnKTtcbiAgICB2YXIgdGhpc1NwYWNpbmcgPSB0aGlzLmdldFN0eWxlKCdsZXR0ZXItc3BhY2luZycpO1xuICAgIHZhciBwYXJlbnRTcGFjaW5nID0gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoJ2xldHRlci1zcGFjaW5nJyk7XG4gICAgdmFyIGxldHRlclNwYWNpbmcgPSAwO1xuXG4gICAgaWYgKCF0aGlzU3BhY2luZy5oYXNWYWx1ZSgpIHx8IHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgPT09ICdpbmhlcml0Jykge1xuICAgICAgbGV0dGVyU3BhY2luZyA9IHBhcmVudFNwYWNpbmcuZ2V0UGl4ZWxzKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzU3BhY2luZy5oYXNWYWx1ZSgpKSB7XG4gICAgICBpZiAodGhpc1NwYWNpbmcuZ2V0VmFsdWUoKSAhPT0gJ2luaXRpYWwnICYmIHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgIT09ICd1bnNldCcpIHtcbiAgICAgICAgbGV0dGVyU3BhY2luZyA9IHRoaXNTcGFjaW5nLmdldFBpeGVscygpO1xuICAgICAgfVxuICAgIH0gLy8gZmlsbCBsZXR0ZXItc3BhY2luZyBjYWNoZVxuXG5cbiAgICB2YXIgbGV0dGVyU3BhY2luZ0NhY2hlID0gW107XG4gICAgdmFyIHRleHRMZW4gPSByZW5kZXJUZXh0Lmxlbmd0aDtcbiAgICB0aGlzLmxldHRlclNwYWNpbmdDYWNoZSA9IGxldHRlclNwYWNpbmdDYWNoZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExlbjsgaSsrKSB7XG4gICAgICBsZXR0ZXJTcGFjaW5nQ2FjaGUucHVzaCh0eXBlb2YgZHhbaV0gIT09ICd1bmRlZmluZWQnID8gZHhbaV0gOiBsZXR0ZXJTcGFjaW5nKTtcbiAgICB9XG5cbiAgICB2YXIgZHhTdW0gPSBsZXR0ZXJTcGFjaW5nQ2FjaGUucmVkdWNlKChhY2MsIGN1ciwgaSkgPT4gaSA9PT0gMCA/IDAgOiBhY2MgKyBjdXIgfHwgMCwgMCk7XG4gICAgdmFyIHRleHRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQoY3R4KTtcbiAgICB2YXIgdGV4dEZ1bGxXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCArIGR4U3VtLCAwKTtcbiAgICB0aGlzLnRleHRXaWR0aCA9IHRleHRXaWR0aDtcbiAgICB0aGlzLnRleHRIZWlnaHQgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgdGhpcy5nbHlwaEluZm8gPSBbXTtcbiAgICB2YXIgZnVsbFBhdGhXaWR0aCA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMuZ2V0U3R5bGUoJ3N0YXJ0T2Zmc2V0JykuZ2V0TnVtYmVyKDApICogZnVsbFBhdGhXaWR0aDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGlmIChhbmNob3IgPT09ICdtaWRkbGUnIHx8IGFuY2hvciA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIG9mZnNldCA9IC10ZXh0RnVsbFdpZHRoIC8gMjtcbiAgICB9XG5cbiAgICBpZiAoYW5jaG9yID09PSAnZW5kJyB8fCBhbmNob3IgPT09ICdyaWdodCcpIHtcbiAgICAgIG9mZnNldCA9IC10ZXh0RnVsbFdpZHRoO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBzdGFydE9mZnNldDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyLCBpKSA9PiB7XG4gICAgICAvLyBGaW5kIHN1Y2ggc2VnbWVudCB3aGF0IGRpc3RhbmNlIGJldHdlZW4gcDAgYW5kIHAxIGlzIGFwcHJveC4gd2lkdGggb2YgZ2x5cGhcbiAgICAgIHZhciB7XG4gICAgICAgIG9mZnNldDogbmV4dE9mZnNldCxcbiAgICAgICAgc2VnbWVudCxcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0gPSB0aGlzLmZpbmRTZWdtZW50VG9GaXRDaGFyKGN0eCwgYW5jaG9yLCB0ZXh0RnVsbFdpZHRoLCBmdWxsUGF0aFdpZHRoLCBzcGFjZXNOdW1iZXIsIG9mZnNldCwgZHksIGNoYXIsIGkpO1xuICAgICAgb2Zmc2V0ID0gbmV4dE9mZnNldDtcblxuICAgICAgaWYgKCFzZWdtZW50LnAwIHx8ICFzZWdtZW50LnAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gY29uc3Qgd2lkdGggPSB0aGlzLmdldExpbmVMZW5ndGgoXG4gICAgICAvLyBcdHNlZ21lbnQucDAueCxcbiAgICAgIC8vIFx0c2VnbWVudC5wMC55LFxuICAgICAgLy8gXHRzZWdtZW50LnAxLngsXG4gICAgICAvLyBcdHNlZ21lbnQucDEueVxuICAgICAgLy8gKTtcbiAgICAgIC8vIE5vdGU6IFNpbmNlIGdseXBocyBhcmUgcmVuZGVyZWQgb25lIGF0IGEgdGltZSwgYW55IGtlcm5pbmcgcGFpciBkYXRhIGJ1aWx0IGludG8gdGhlIGZvbnQgd2lsbCBub3QgYmUgdXNlZC5cbiAgICAgIC8vIENhbiBmb3Jlc2VlIGhhdmluZyBhIHJvdWdoIHBhaXIgdGFibGUgYnVpbHQgaW4gdGhhdCB0aGUgZGV2ZWxvcGVyIGNhbiBvdmVycmlkZSBhcyBuZWVkZWQuXG4gICAgICAvLyBPciB1c2UgXCJkeFwiIGF0dHJpYnV0ZSBvZiB0aGUgPHRleHQ+IG5vZGUgYXMgYSBuYWl2ZSByZXBsYWNlbWVudFxuICAgICAgLy8gY29uc3Qga2VybiA9IDA7XG4gICAgICAvLyBwbGFjZWhvbGRlciBmb3IgZnV0dXJlIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyBjb25zdCBtaWRwb2ludCA9IHRoaXMuZ2V0UG9pbnRPbkxpbmUoXG4gICAgICAvLyBcdGtlcm4gKyB3aWR0aCAvIDIuMCxcbiAgICAgIC8vIFx0c2VnbWVudC5wMC54LCBzZWdtZW50LnAwLnksIHNlZ21lbnQucDEueCwgc2VnbWVudC5wMS55XG4gICAgICAvLyApO1xuXG5cbiAgICAgIHRoaXMuZ2x5cGhJbmZvLnB1c2goe1xuICAgICAgICAvLyB0cmFuc3Bvc2VYOiBtaWRwb2ludC54LFxuICAgICAgICAvLyB0cmFuc3Bvc2VZOiBtaWRwb2ludC55LFxuICAgICAgICB0ZXh0OiBjaGFyc1tpXSxcbiAgICAgICAgcDA6IHNlZ21lbnQucDAsXG4gICAgICAgIHAxOiBzZWdtZW50LnAxLFxuICAgICAgICByb3RhdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwYXJzZVBhdGhEYXRhKHBhdGgpIHtcbiAgICB0aGlzLnBhdGhMZW5ndGggPSAtMTsgLy8gcmVzZXQgcGF0aCBsZW5ndGhcblxuICAgIGlmICghcGF0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBwYXRoQ29tbWFuZHMgPSBbXTtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSBwYXRoO1xuICAgIHBhdGhQYXJzZXIucmVzZXQoKTsgLy8gY29udmVydCBsLCBILCBoLCBWLCBhbmQgdiB0byBMXG5cbiAgICB3aGlsZSAoIXBhdGhQYXJzZXIuaXNFbmQoKSkge1xuICAgICAgdmFyIHtcbiAgICAgICAgY3VycmVudFxuICAgICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICB2YXIgc3RhcnRYID0gY3VycmVudCA/IGN1cnJlbnQueCA6IDA7XG4gICAgICB2YXIgc3RhcnRZID0gY3VycmVudCA/IGN1cnJlbnQueSA6IDA7XG4gICAgICB2YXIgY29tbWFuZCA9IHBhdGhQYXJzZXIubmV4dCgpO1xuICAgICAgdmFyIG5leHRDb21tYW5kVHlwZSA9IGNvbW1hbmQudHlwZTtcbiAgICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgICAgc3dpdGNoIChjb21tYW5kLnR5cGUpIHtcbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoTShwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aEwocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuSE9SSVpfTElORV9UTzpcbiAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhIKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlZFUlRfTElORV9UTzpcbiAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhWKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgIHRoaXMucGF0aEMocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX0NVUlZFX1RPOlxuICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aFMocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhRKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9RVUFEX1RPOlxuICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aFQocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgIHBvaW50cyA9IHRoaXMucGF0aEEocGF0aFBhcnNlcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNMT1NFX1BBVEg6XG4gICAgICAgICAgUGF0aEVsZW1lbnQucGF0aFoocGF0aFBhcnNlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21tYW5kLnR5cGUgIT09IFBhdGhQYXJzZXIuQ0xPU0VfUEFUSCkge1xuICAgICAgICBwYXRoQ29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogbmV4dENvbW1hbmRUeXBlLFxuICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgICAgeTogc3RhcnRZXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXRoTGVuZ3RoOiB0aGlzLmNhbGNMZW5ndGgoc3RhcnRYLCBzdGFydFksIG5leHRDb21tYW5kVHlwZSwgcG9pbnRzKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGhDb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBQYXRoUGFyc2VyLkNMT1NFX1BBVEgsXG4gICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICBwYXRoTGVuZ3RoOiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRoQ29tbWFuZHM7XG4gIH1cblxuICBwYXRoTShwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aE0ocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gIH1cblxuICBwYXRoTChwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEwocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgcmV0dXJuIFBhdGhQYXJzZXIuTElORV9UTztcbiAgfVxuXG4gIHBhdGhIKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoSChwYXRoUGFyc2VyKS5wb2ludDtcbiAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICB9XG5cbiAgcGF0aFYocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhWKHBhdGhQYXJzZXIpLnBvaW50O1xuICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gIH1cblxuICBwYXRoQyhwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgcG9pbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEMocGF0aFBhcnNlcik7XG4gICAgcG9pbnRzLnB1c2gocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICB9XG5cbiAgcGF0aFMocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhTKHBhdGhQYXJzZXIpO1xuICAgIHBvaW50cy5wdXNoKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICByZXR1cm4gUGF0aFBhcnNlci5DVVJWRV9UTztcbiAgfVxuXG4gIHBhdGhRKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFEocGF0aFBhcnNlcik7XG4gICAgcG9pbnRzLnB1c2goY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICB9XG5cbiAgcGF0aFQocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoVChwYXRoUGFyc2VyKTtcbiAgICBwb2ludHMucHVzaChjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgcmV0dXJuIFBhdGhQYXJzZXIuUVVBRF9UTztcbiAgfVxuXG4gIHBhdGhBKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgclgsXG4gICAgICByWSxcbiAgICAgIHN3ZWVwRmxhZyxcbiAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICBjZW50cCxcbiAgICAgIGExLFxuICAgICAgYWRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEEocGF0aFBhcnNlcik7XG5cbiAgICBpZiAoc3dlZXBGbGFnID09PSAwICYmIGFkID4gMCkge1xuICAgICAgYWQgLT0gMiAqIE1hdGguUEk7XG4gICAgfVxuXG4gICAgaWYgKHN3ZWVwRmxhZyA9PT0gMSAmJiBhZCA8IDApIHtcbiAgICAgIGFkICs9IDIgKiBNYXRoLlBJO1xuICAgIH1cblxuICAgIHJldHVybiBbY2VudHAueCwgY2VudHAueSwgclgsIHJZLCBhMSwgYWQsIHhBeGlzUm90YXRpb24sIHN3ZWVwRmxhZ107XG4gIH1cblxuICBjYWxjTGVuZ3RoKHgsIHksIGNvbW1hbmRUeXBlLCBwb2ludHMpIHtcbiAgICB2YXIgbGVuID0gMDtcbiAgICB2YXIgcDEgPSBudWxsO1xuICAgIHZhciBwMiA9IG51bGw7XG4gICAgdmFyIHQgPSAwO1xuXG4gICAgc3dpdGNoIChjb21tYW5kVHlwZSkge1xuICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgIHJldHVybiB0aGlzLmdldExpbmVMZW5ndGgoeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIDEwMCBsaW5lIHNlZ21lbnRzXG4gICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25DdWJpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcblxuICAgICAgICBmb3IgKHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uQ3ViaWNCZXppZXIodCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbjtcblxuICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIDEwMCBsaW5lIHNlZ21lbnRzXG4gICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcblxuICAgICAgICBmb3IgKHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKHQsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbjtcblxuICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gcG9pbnRzWzRdOyAvLyA0ID0gdGhldGFcblxuICAgICAgICAgIHZhciBkVGhldGEgPSBwb2ludHNbNV07IC8vIDUgPSBkVGhldGFcblxuICAgICAgICAgIHZhciBlbmQgPSBwb2ludHNbNF0gKyBkVGhldGE7XG4gICAgICAgICAgdmFyIGluYyA9IE1hdGguUEkgLyAxODAuMDsgLy8gMSBkZWdyZWUgcmVzb2x1dGlvblxuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKHN0YXJ0IC0gZW5kKSA8IGluYykge1xuICAgICAgICAgICAgaW5jID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICAgICAgICAgIH0gLy8gTm90ZTogZm9yIHB1cnBvc2Ugb2YgY2FsY3VsYXRpbmcgYXJjIGxlbmd0aCwgbm90IGdvaW5nIHRvIHdvcnJ5IGFib3V0IHJvdGF0aW5nIFgtYXhpcyBieSBhbmdsZSBwc2lcblxuXG4gICAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgc3RhcnQsIDApO1xuXG4gICAgICAgICAgaWYgKGRUaGV0YSA8IDApIHtcbiAgICAgICAgICAgIC8vIGNsb2Nrd2lzZVxuICAgICAgICAgICAgZm9yICh0ID0gc3RhcnQgLSBpbmM7IHQgPiBlbmQ7IHQgLT0gaW5jKSB7XG4gICAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAgICAgICAgZm9yICh0ID0gc3RhcnQgKyBpbmM7IHQgPCBlbmQ7IHQgKz0gaW5jKSB7XG4gICAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIGVuZCwgMCk7XG4gICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXRQb2ludE9uTGluZShkaXN0LCBwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICB2YXIgZnJvbVggPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHAxeDtcbiAgICB2YXIgZnJvbVkgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHAxeTtcbiAgICB2YXIgbSA9IChwMnkgLSBwMXkpIC8gKHAyeCAtIHAxeCArIFBTRVVET19aRVJPKTtcbiAgICB2YXIgcnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC8gKDEgKyBtICogbSkpO1xuXG4gICAgaWYgKHAyeCA8IHAxeCkge1xuICAgICAgcnVuICo9IC0xO1xuICAgIH1cblxuICAgIHZhciByaXNlID0gbSAqIHJ1bjtcbiAgICB2YXIgcHQgPSBudWxsO1xuXG4gICAgaWYgKHAyeCA9PT0gcDF4KSB7XG4gICAgICAvLyB2ZXJ0aWNhbCBsaW5lXG4gICAgICBwdCA9IHtcbiAgICAgICAgeDogZnJvbVgsXG4gICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKChmcm9tWSAtIHAxeSkgLyAoZnJvbVggLSBwMXggKyBQU0VVRE9fWkVSTykgPT09IG0pIHtcbiAgICAgIHB0ID0ge1xuICAgICAgICB4OiBmcm9tWCArIHJ1bixcbiAgICAgICAgeTogZnJvbVkgKyByaXNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXggPSAwO1xuICAgICAgdmFyIGl5ID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmdldExpbmVMZW5ndGgocDF4LCBwMXksIHAyeCwgcDJ5KTtcblxuICAgICAgaWYgKGxlbiA8IFBTRVVET19aRVJPKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdSA9IChmcm9tWCAtIHAxeCkgKiAocDJ4IC0gcDF4KSArIChmcm9tWSAtIHAxeSkgKiAocDJ5IC0gcDF5KTtcbiAgICAgIHUgLz0gbGVuICogbGVuO1xuICAgICAgaXggPSBwMXggKyB1ICogKHAyeCAtIHAxeCk7XG4gICAgICBpeSA9IHAxeSArIHUgKiAocDJ5IC0gcDF5KTtcbiAgICAgIHZhciBwUmlzZSA9IHRoaXMuZ2V0TGluZUxlbmd0aChmcm9tWCwgZnJvbVksIGl4LCBpeSk7XG4gICAgICB2YXIgcFJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAtIHBSaXNlICogcFJpc2UpO1xuICAgICAgcnVuID0gTWF0aC5zcXJ0KHBSdW4gKiBwUnVuIC8gKDEgKyBtICogbSkpO1xuXG4gICAgICBpZiAocDJ4IDwgcDF4KSB7XG4gICAgICAgIHJ1biAqPSAtMTtcbiAgICAgIH1cblxuICAgICAgcmlzZSA9IG0gKiBydW47XG4gICAgICBwdCA9IHtcbiAgICAgICAgeDogaXggKyBydW4sXG4gICAgICAgIHk6IGl5ICsgcmlzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHQ7XG4gIH1cblxuICBnZXRQb2ludE9uUGF0aChkaXN0YW5jZSkge1xuICAgIHZhciBmdWxsTGVuID0gdGhpcy5nZXRQYXRoTGVuZ3RoKCk7XG4gICAgdmFyIGN1bXVsYXRpdmVQYXRoTGVuZ3RoID0gMDtcbiAgICB2YXIgcCA9IG51bGw7XG5cbiAgICBpZiAoZGlzdGFuY2UgPCAtMC4wMDAwNSB8fCBkaXN0YW5jZSAtIDAuMDAwMDUgPiBmdWxsTGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgZGF0YUFycmF5XG4gICAgfSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBjb21tYW5kIG9mIGRhdGFBcnJheSkge1xuICAgICAgaWYgKGNvbW1hbmQgJiYgKGNvbW1hbmQucGF0aExlbmd0aCA8IDAuMDAwMDUgfHwgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKyBjb21tYW5kLnBhdGhMZW5ndGggKyAwLjAwMDA1IDwgZGlzdGFuY2UpKSB7XG4gICAgICAgIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICs9IGNvbW1hbmQucGF0aExlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWx0YSA9IGRpc3RhbmNlIC0gY3VtdWxhdGl2ZVBhdGhMZW5ndGg7XG4gICAgICB2YXIgY3VycmVudFQgPSAwO1xuXG4gICAgICBzd2l0Y2ggKGNvbW1hbmQudHlwZSkge1xuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uTGluZShkZWx0YSwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5BUkM6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY29tbWFuZC5wb2ludHNbNF07IC8vIDQgPSB0aGV0YVxuXG4gICAgICAgICAgICB2YXIgZFRoZXRhID0gY29tbWFuZC5wb2ludHNbNV07IC8vIDUgPSBkVGhldGFcblxuICAgICAgICAgICAgdmFyIGVuZCA9IGNvbW1hbmQucG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICAgICAgY3VycmVudFQgPSBzdGFydCArIGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoICogZFRoZXRhO1xuXG4gICAgICAgICAgICBpZiAoZFRoZXRhIDwgMCAmJiBjdXJyZW50VCA8IGVuZCB8fCBkVGhldGEgPj0gMCAmJiBjdXJyZW50VCA+IGVuZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnBvaW50c1syXSwgY29tbWFuZC5wb2ludHNbM10sIGN1cnJlbnRULCBjb21tYW5kLnBvaW50c1s2XSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgIGN1cnJlbnRUID0gZGVsdGEgLyBjb21tYW5kLnBhdGhMZW5ndGg7XG5cbiAgICAgICAgICBpZiAoY3VycmVudFQgPiAxKSB7XG4gICAgICAgICAgICBjdXJyZW50VCA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKGN1cnJlbnRULCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSwgY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnBvaW50c1syXSwgY29tbWFuZC5wb2ludHNbM10sIGNvbW1hbmQucG9pbnRzWzRdLCBjb21tYW5kLnBvaW50c1s1XSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgY3VycmVudFQgPSBkZWx0YSAvIGNvbW1hbmQucGF0aExlbmd0aDtcblxuICAgICAgICAgIGlmIChjdXJyZW50VCA+IDEpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKGN1cnJlbnRULCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSwgY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnBvaW50c1syXSwgY29tbWFuZC5wb2ludHNbM10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAocCkge1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRMaW5lTGVuZ3RoKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICB9XG5cbiAgZ2V0UGF0aExlbmd0aCgpIHtcbiAgICBpZiAodGhpcy5wYXRoTGVuZ3RoID09PSAtMSkge1xuICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gdGhpcy5kYXRhQXJyYXkucmVkdWNlKChsZW5ndGgsIGNvbW1hbmQpID0+IGNvbW1hbmQucGF0aExlbmd0aCA+IDAgPyBsZW5ndGggKyBjb21tYW5kLnBhdGhMZW5ndGggOiBsZW5ndGgsIDApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhdGhMZW5ndGg7XG4gIH1cblxuICBnZXRQb2ludE9uQ3ViaWNCZXppZXIocGN0LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5LCBwNHgsIHA0eSkge1xuICAgIHZhciB4ID0gcDR4ICogQ0IxKHBjdCkgKyBwM3ggKiBDQjIocGN0KSArIHAyeCAqIENCMyhwY3QpICsgcDF4ICogQ0I0KHBjdCk7XG4gICAgdmFyIHkgPSBwNHkgKiBDQjEocGN0KSArIHAzeSAqIENCMihwY3QpICsgcDJ5ICogQ0IzKHBjdCkgKyBwMXkgKiBDQjQocGN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihwY3QsIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICB2YXIgeCA9IHAzeCAqIFFCMShwY3QpICsgcDJ4ICogUUIyKHBjdCkgKyBwMXggKiBRQjMocGN0KTtcbiAgICB2YXIgeSA9IHAzeSAqIFFCMShwY3QpICsgcDJ5ICogUUIyKHBjdCkgKyBwMXkgKiBRQjMocGN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoY3gsIGN5LCByeCwgcnksIHRoZXRhLCBwc2kpIHtcbiAgICB2YXIgY29zUHNpID0gTWF0aC5jb3MocHNpKTtcbiAgICB2YXIgc2luUHNpID0gTWF0aC5zaW4ocHNpKTtcbiAgICB2YXIgcHQgPSB7XG4gICAgICB4OiByeCAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgIHk6IHJ5ICogTWF0aC5zaW4odGhldGEpXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogY3ggKyAocHQueCAqIGNvc1BzaSAtIHB0LnkgKiBzaW5Qc2kpLFxuICAgICAgeTogY3kgKyAocHQueCAqIHNpblBzaSArIHB0LnkgKiBjb3NQc2kpXG4gICAgfTtcbiAgfSAvLyBUT0RPIG5lZWQgc29tZSBvcHRpbWlzYXRpb25zLiBwb3NzaWJseSBidWlsZCBjYWNoZSBvbmx5IGZvciBjdXJ2ZWQgc2VnbWVudHM/XG5cblxuICBidWlsZEVxdWlkaXN0YW50Q2FjaGUoaW5wdXRTdGVwLCBpbnB1dFByZWNpc2lvbikge1xuICAgIHZhciBmdWxsTGVuID0gdGhpcy5nZXRQYXRoTGVuZ3RoKCk7XG4gICAgdmFyIHByZWNpc2lvbiA9IGlucHV0UHJlY2lzaW9uIHx8IDAuMjU7IC8vIGFjY3VyYWN5IHZzIHBlcmZvcm1hbmNlXG5cbiAgICB2YXIgc3RlcCA9IGlucHV0U3RlcCB8fCBmdWxsTGVuIC8gMTAwO1xuXG4gICAgaWYgKCF0aGlzLmVxdWlkaXN0YW50Q2FjaGUgfHwgdGhpcy5lcXVpZGlzdGFudENhY2hlLnN0ZXAgIT09IHN0ZXAgfHwgdGhpcy5lcXVpZGlzdGFudENhY2hlLnByZWNpc2lvbiAhPT0gcHJlY2lzaW9uKSB7XG4gICAgICAvLyBQcmVwYXJlIGNhY2hlXG4gICAgICB0aGlzLmVxdWlkaXN0YW50Q2FjaGUgPSB7XG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgcG9pbnRzOiBbXVxuICAgICAgfTsgLy8gQ2FsY3VsYXRlIHBvaW50c1xuXG4gICAgICB2YXIgcyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDw9IGZ1bGxMZW47IGwgKz0gcHJlY2lzaW9uKSB7XG4gICAgICAgIHZhciBwMCA9IHRoaXMuZ2V0UG9pbnRPblBhdGgobCk7XG4gICAgICAgIHZhciBwMSA9IHRoaXMuZ2V0UG9pbnRPblBhdGgobCArIHByZWNpc2lvbik7XG5cbiAgICAgICAgaWYgKCFwMCB8fCAhcDEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAwLngsIHAwLnksIHAxLngsIHAxLnkpO1xuXG4gICAgICAgIGlmIChzID49IHN0ZXApIHtcbiAgICAgICAgICB0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgeDogcDAueCxcbiAgICAgICAgICAgIHk6IHAwLnksXG4gICAgICAgICAgICBkaXN0YW5jZTogbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHMgLT0gc3RlcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgodGFyZ2V0RGlzdGFuY2UsIHN0ZXAsIHByZWNpc2lvbikge1xuICAgIHRoaXMuYnVpbGRFcXVpZGlzdGFudENhY2hlKHN0ZXAsIHByZWNpc2lvbik7XG5cbiAgICBpZiAodGFyZ2V0RGlzdGFuY2UgPCAwIHx8IHRhcmdldERpc3RhbmNlIC0gdGhpcy5nZXRQYXRoTGVuZ3RoKCkgPiAwLjAwMDA1KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gTWF0aC5yb3VuZCh0YXJnZXREaXN0YW5jZSAvIHRoaXMuZ2V0UGF0aExlbmd0aCgpICogKHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wb2ludHMubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiB0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzW2lkeF0gfHwgbnVsbDtcbiAgfVxuXG59XG5cbnZhciBkYXRhVXJpUmVnZXggPSAvXlxccypkYXRhOigoW14vLDtdK1xcL1teLyw7XSspKD86OyhbXiw7PV0rPVteLDs9XSspKT8pPyg/OjsoYmFzZTY0KSk/LCguKikkL2k7XG5jbGFzcyBJbWFnZUVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnaW1hZ2UnO1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgdmFyIGhyZWYgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXRTdHJpbmcoKTtcblxuICAgIGlmICghaHJlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc1N2ZyA9IGhyZWYuZW5kc1dpdGgoJy5zdmcnKSB8fCAvXlxccypkYXRhOmltYWdlXFwvc3ZnXFwreG1sL2kudGVzdChocmVmKTtcbiAgICBkb2N1bWVudC5pbWFnZXMucHVzaCh0aGlzKTtcblxuICAgIGlmICghaXNTdmcpIHtcbiAgICAgIHZvaWQgdGhpcy5sb2FkSW1hZ2UoaHJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgdGhpcy5sb2FkU3ZnKGhyZWYpO1xuICAgIH1cblxuICAgIHRoaXMuaXNTdmcgPSBpc1N2ZztcbiAgfVxuXG4gIGxvYWRJbWFnZShocmVmKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGltYWdlID0geWllbGQgX3RoaXMuZG9jdW1lbnQuY3JlYXRlSW1hZ2UoaHJlZik7XG4gICAgICAgIF90aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIGxvYWRpbmcgaW1hZ2UgXFxcIlwiLmNvbmNhdChocmVmLCBcIlxcXCI6XCIpLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH0pKCk7XG4gIH1cblxuICBsb2FkU3ZnKGhyZWYpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIG1hdGNoID0gZGF0YVVyaVJlZ2V4LmV4ZWMoaHJlZik7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoWzVdO1xuXG4gICAgICAgIGlmIChtYXRjaFs0XSA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICBfdGhpczIuaW1hZ2UgPSBhdG9iKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5pbWFnZSA9IGRlY29kZVVSSUNvbXBvbmVudChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB5aWVsZCBfdGhpczIuZG9jdW1lbnQuZmV0Y2goaHJlZik7XG4gICAgICAgICAgdmFyIHN2ZyA9IHlpZWxkIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICBfdGhpczIuaW1hZ2UgPSBzdmc7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGltYWdlIFxcXCJcIi5jb25jYXQoaHJlZiwgXCJcXFwiOlwiKSwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpczIubG9hZGVkID0gdHJ1ZTtcbiAgICB9KSgpO1xuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgaW1hZ2UsXG4gICAgICBsb2FkZWRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuXG4gICAgaWYgKCFsb2FkZWQgfHwgIWltYWdlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgaWYgKHRoaXMuaXNTdmcpIHtcbiAgICAgIHZhciBzdWJEb2N1bWVudCA9IGRvY3VtZW50LmNhbnZnLmZvcmtTdHJpbmcoY3R4LCB0aGlzLmltYWdlLCB7XG4gICAgICAgIGlnbm9yZU1vdXNlOiB0cnVlLFxuICAgICAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgICAgIGlnbm9yZURpbWVuc2lvbnM6IHRydWUsXG4gICAgICAgIGlnbm9yZUNsZWFyOiB0cnVlLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICBzY2FsZVdpZHRoOiB3aWR0aCxcbiAgICAgICAgc2NhbGVIZWlnaHQ6IGhlaWdodFxuICAgICAgfSk7XG4gICAgICBzdWJEb2N1bWVudC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucGFyZW50ID0gdGhpcztcbiAgICAgIHZvaWQgc3ViRG9jdW1lbnQucmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgZG9jdW1lbnQuc2V0Vmlld0JveCh7XG4gICAgICAgIGN0eCxcbiAgICAgICAgYXNwZWN0UmF0aW86IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBkZXNpcmVkV2lkdGg6IF9pbWFnZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBkZXNpcmVkSGVpZ2h0OiBfaW1hZ2UuaGVpZ2h0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMubG9hZGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgX2ltYWdlLmNvbXBsZXRlID09PSAndW5kZWZpbmVkJyB8fCBfaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKF9pbWFnZSwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgZ2V0Qm91bmRpbmdCb3goKSB7XG4gICAgdmFyIHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gIH1cblxufVxuXG5jbGFzcyBTeW1ib2xFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnc3ltYm9sJztcbiAgfVxuXG4gIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxufVxuXG5jbGFzcyBTVkdGb250TG9hZGVyIHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQpIHtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICBkb2N1bWVudC5mb250cy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgbG9hZChmb250RmFtaWx5LCB1cmwpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGRvY3VtZW50XG4gICAgICAgIH0gPSBfdGhpcztcbiAgICAgICAgdmFyIHN2Z0RvY3VtZW50ID0geWllbGQgZG9jdW1lbnQuY2FudmcucGFyc2VyLmxvYWQodXJsKTtcbiAgICAgICAgdmFyIGZvbnRzID0gc3ZnRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZvbnQnKTtcbiAgICAgICAgQXJyYXkuZnJvbShmb250cykuZm9yRWFjaChmb250Tm9kZSA9PiB7XG4gICAgICAgICAgdmFyIGZvbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGZvbnROb2RlKTtcbiAgICAgICAgICBkb2N1bWVudC5kZWZpbml0aW9uc1tmb250RmFtaWx5XSA9IGZvbnQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGZvbnQgXFxcIlwiLmNvbmNhdCh1cmwsIFwiXFxcIjpcIiksIGVycik7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgfSkoKTtcbiAgfVxuXG59XG5cbmNsYXNzIFN0eWxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnc3R5bGUnO1xuICAgIHZhciBjc3MgPSBjb21wcmVzc1NwYWNlcyhBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykgLy8gTkVFRCBURVNUXG4gICAgLm1hcChfID0+IF8udGV4dENvbnRlbnQpLmpvaW4oJycpLnJlcGxhY2UoLyhcXC9cXCooW14qXXxbXFxyXFxuXXwoXFwqKyhbXiovXXxbXFxyXFxuXSkpKSpcXCorXFwvKXwoXltcXHNdKlxcL1xcLy4qKS9nbSwgJycpIC8vIHJlbW92ZSBjb21tZW50c1xuICAgIC5yZXBsYWNlKC9AaW1wb3J0Lio7L2csICcnKSAvLyByZW1vdmUgaW1wb3J0c1xuICAgICk7XG4gICAgdmFyIGNzc0RlZnMgPSBjc3Muc3BsaXQoJ30nKTtcbiAgICBjc3NEZWZzLmZvckVhY2goXyA9PiB7XG4gICAgICB2YXIgZGVmID0gXy50cmltKCk7XG5cbiAgICAgIGlmICghZGVmKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNzc1BhcnRzID0gZGVmLnNwbGl0KCd7Jyk7XG4gICAgICB2YXIgY3NzQ2xhc3NlcyA9IGNzc1BhcnRzWzBdLnNwbGl0KCcsJyk7XG4gICAgICB2YXIgY3NzUHJvcHMgPSBjc3NQYXJ0c1sxXS5zcGxpdCgnOycpO1xuICAgICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKF8gPT4ge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSBfLnRyaW0oKTtcblxuICAgICAgICBpZiAoIWNzc0NsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BzID0gZG9jdW1lbnQuc3R5bGVzW2Nzc0NsYXNzXSB8fCB7fTtcbiAgICAgICAgY3NzUHJvcHMuZm9yRWFjaChjc3NQcm9wID0+IHtcbiAgICAgICAgICB2YXIgcHJvcCA9IGNzc1Byb3AuaW5kZXhPZignOicpO1xuICAgICAgICAgIHZhciBuYW1lID0gY3NzUHJvcC5zdWJzdHIoMCwgcHJvcCkudHJpbSgpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNzc1Byb3Auc3Vic3RyKHByb3AgKyAxLCBjc3NQcm9wLmxlbmd0aCAtIHByb3ApLnRyaW0oKTtcblxuICAgICAgICAgIGlmIChuYW1lICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBwcm9wc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LnN0eWxlc1tjc3NDbGFzc10gPSBwcm9wcztcbiAgICAgICAgZG9jdW1lbnQuc3R5bGVzU3BlY2lmaWNpdHlbY3NzQ2xhc3NdID0gZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eShjc3NDbGFzcyk7XG5cbiAgICAgICAgaWYgKGNzc0NsYXNzID09PSAnQGZvbnQtZmFjZScpIHtcbiAgICAgICAgICAvLyAgJiYgIW5vZGVFbnZcbiAgICAgICAgICB2YXIgZm9udEZhbWlseSA9IHByb3BzWydmb250LWZhbWlseSddLmdldFN0cmluZygpLnJlcGxhY2UoL1wifCcvZywgJycpO1xuICAgICAgICAgIHZhciBzcmNzID0gcHJvcHMuc3JjLmdldFN0cmluZygpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgc3Jjcy5mb3JFYWNoKHNyYyA9PiB7XG4gICAgICAgICAgICBpZiAoc3JjLmluZGV4T2YoJ2Zvcm1hdChcInN2Z1wiKScpID4gMCkge1xuICAgICAgICAgICAgICB2YXIgdXJsID0gcGFyc2VFeHRlcm5hbFVybChzcmMpO1xuXG4gICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICB2b2lkIG5ldyBTVkdGb250TG9hZGVyKGRvY3VtZW50KS5sb2FkKGZvbnRGYW1pbHksIHVybCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufVxuU3R5bGVFbGVtZW50LnBhcnNlRXh0ZXJuYWxVcmwgPSBwYXJzZUV4dGVybmFsVXJsO1xuXG5jbGFzcyBVc2VFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAndXNlJztcbiAgfVxuXG4gIHNldENvbnRleHQoY3R4KSB7XG4gICAgc3VwZXIuc2V0Q29udGV4dChjdHgpO1xuICAgIHZhciB4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgdmFyIHlBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKTtcblxuICAgIGlmICh4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICBjdHgudHJhbnNsYXRlKHhBdHRyLmdldFBpeGVscygneCcpLCAwKTtcbiAgICB9XG5cbiAgICBpZiAoeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB5QXR0ci5nZXRQaXhlbHMoJ3knKSk7XG4gICAgfVxuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQucGF0aChjdHgpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgdGVtcFN2ZyA9IGVsZW1lbnQ7XG5cbiAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudCBpbiBzeW1ib2wgY2FzZXMgKGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNVc2VFbGVtZW50KVxuICAgICAgICB0ZW1wU3ZnID0gbmV3IFNWR0VsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMudmlld0JveCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3ZpZXdCb3gnLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFN0cmluZygpKTtcbiAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLnByZXNlcnZlQXNwZWN0UmF0aW8gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5vdmVyZmxvdyA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ292ZXJmbG93JywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ292ZXJmbG93JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB0ZW1wU3ZnLmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbjsgLy8gZWxlbWVudCBpcyBzdGlsbCB0aGUgcGFyZW50IG9mIHRoZSBjaGlsZHJlblxuXG4gICAgICAgIGVsZW1lbnQuc3R5bGVzLm9wYWNpdHkgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdvcGFjaXR5JywgdGhpcy5jYWxjdWxhdGVPcGFjaXR5KCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGVtcFN2Zy50eXBlID09PSAnc3ZnJykge1xuICAgICAgICB2YXIgd2lkdGhTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgZmFsc2UsIHRydWUpO1xuICAgICAgICB2YXIgaGVpZ2h0U3R5bGUgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCBmYWxzZSwgdHJ1ZSk7IC8vIGlmIHN5bWJvbCBvciBzdmcsIGluaGVyaXQgd2lkdGgvaGVpZ2h0IGZyb20gbWVcblxuICAgICAgICBpZiAod2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCB3aWR0aFN0eWxlLmdldFN0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIGhlaWdodFN0eWxlLmdldFN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb2xkUGFyZW50ID0gdGVtcFN2Zy5wYXJlbnQ7XG4gICAgICB0ZW1wU3ZnLnBhcmVudCA9IHRoaXM7XG4gICAgICB0ZW1wU3ZnLnJlbmRlcihjdHgpO1xuICAgICAgdGVtcFN2Zy5wYXJlbnQgPSBvbGRQYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZWxlbWVudFRyYW5zZm9ybSgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBlbGVtZW50XG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFRyYW5zZm9ybS5mcm9tRWxlbWVudChkb2N1bWVudCwgZWxlbWVudCk7XG4gIH1cblxuICBnZXQgZWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuY2FjaGVkRWxlbWVudCkge1xuICAgICAgdGhpcy5jYWNoZWRFbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNhY2hlZEVsZW1lbnQ7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpbUdldChpbWcsIHgsIHksIHdpZHRoLCBfaGVpZ2h0LCByZ2JhKSB7XG4gIHJldHVybiBpbWdbeSAqIHdpZHRoICogNCArIHggKiA0ICsgcmdiYV07XG59XG5cbmZ1bmN0aW9uIGltU2V0KGltZywgeCwgeSwgd2lkdGgsIF9oZWlnaHQsIHJnYmEsIHZhbCkge1xuICBpbWdbeSAqIHdpZHRoICogNCArIHggKiA0ICsgcmdiYV0gPSB2YWw7XG59XG5cbmZ1bmN0aW9uIG0obWF0cml4LCBpLCB2KSB7XG4gIHZhciBtaSA9IG1hdHJpeFtpXTtcbiAgcmV0dXJuIG1pICogdjtcbn1cblxuZnVuY3Rpb24gYyhhLCBtMSwgbTIsIG0zKSB7XG4gIHJldHVybiBtMSArIE1hdGguY29zKGEpICogbTIgKyBNYXRoLnNpbihhKSAqIG0zO1xufVxuXG5jbGFzcyBGZUNvbG9yTWF0cml4RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnZmVDb2xvck1hdHJpeCc7XG4gICAgdmFyIG1hdHJpeCA9IHRvTnVtYmVycyh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWVzJykuZ2V0U3RyaW5nKCkpO1xuXG4gICAgc3dpdGNoICh0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpLmdldFN0cmluZygnbWF0cml4JykpIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjZmVDb2xvck1hdHJpeEVsZW1lbnRcbiAgICAgIGNhc2UgJ3NhdHVyYXRlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzID0gbWF0cml4WzBdO1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgbWF0cml4ID0gWzAuMjEzICsgMC43ODcgKiBzLCAwLjcxNSAtIDAuNzE1ICogcywgMC4wNzIgLSAwLjA3MiAqIHMsIDAsIDAsIDAuMjEzIC0gMC4yMTMgKiBzLCAwLjcxNSArIDAuMjg1ICogcywgMC4wNzIgLSAwLjA3MiAqIHMsIDAsIDAsIDAuMjEzIC0gMC4yMTMgKiBzLCAwLjcxNSAtIDAuNzE1ICogcywgMC4wNzIgKyAwLjkyOCAqIHMsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDFdO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdodWVSb3RhdGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGEgPSBtYXRyaXhbMF0gKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgICBtYXRyaXggPSBbYyhhLCAwLjIxMywgMC43ODcsIC0wLjIxMyksIGMoYSwgMC43MTUsIC0wLjcxNSwgLTAuNzE1KSwgYyhhLCAwLjA3MiwgLTAuMDcyLCAwLjkyOCksIDAsIDAsIGMoYSwgMC4yMTMsIC0wLjIxMywgMC4xNDMpLCBjKGEsIDAuNzE1LCAwLjI4NSwgMC4xNDApLCBjKGEsIDAuMDcyLCAtMC4wNzIsIC0wLjI4MyksIDAsIDAsIGMoYSwgMC4yMTMsIC0wLjIxMywgLTAuNzg3KSwgYyhhLCAwLjcxNSwgLTAuNzE1LCAwLjcxNSksIGMoYSwgMC4wNzIsIDAuOTI4LCAwLjA3MiksIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDFdO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdsdW1pbmFuY2VUb0FscGhhJzpcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG4gICAgICAgIG1hdHJpeCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLjIxMjUsIDAuNzE1NCwgMC4wNzIxLCAwLCAwLCAwLCAwLCAwLCAwLCAxXTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB0aGlzLmluY2x1ZGVPcGFjaXR5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2luY2x1ZGVPcGFjaXR5JykuaGFzVmFsdWUoKTtcbiAgfVxuXG4gIGFwcGx5KGN0eCwgX3gsIF95LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gYXNzdW1pbmcgeD09MCAmJiB5PT0wIGZvciBub3dcbiAgICB2YXIge1xuICAgICAgaW5jbHVkZU9wYWNpdHksXG4gICAgICBtYXRyaXhcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgc3JjRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgdmFyIHIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDApO1xuICAgICAgICB2YXIgZyA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSk7XG4gICAgICAgIHZhciBiID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyKTtcbiAgICAgICAgdmFyIGEgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMpO1xuICAgICAgICB2YXIgbnIgPSBtKG1hdHJpeCwgMCwgcikgKyBtKG1hdHJpeCwgMSwgZykgKyBtKG1hdHJpeCwgMiwgYikgKyBtKG1hdHJpeCwgMywgYSkgKyBtKG1hdHJpeCwgNCwgMSk7XG4gICAgICAgIHZhciBuZyA9IG0obWF0cml4LCA1LCByKSArIG0obWF0cml4LCA2LCBnKSArIG0obWF0cml4LCA3LCBiKSArIG0obWF0cml4LCA4LCBhKSArIG0obWF0cml4LCA5LCAxKTtcbiAgICAgICAgdmFyIG5iID0gbShtYXRyaXgsIDEwLCByKSArIG0obWF0cml4LCAxMSwgZykgKyBtKG1hdHJpeCwgMTIsIGIpICsgbShtYXRyaXgsIDEzLCBhKSArIG0obWF0cml4LCAxNCwgMSk7XG4gICAgICAgIHZhciBuYSA9IG0obWF0cml4LCAxNSwgcikgKyBtKG1hdHJpeCwgMTYsIGcpICsgbShtYXRyaXgsIDE3LCBiKSArIG0obWF0cml4LCAxOCwgYSkgKyBtKG1hdHJpeCwgMTksIDEpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlT3BhY2l0eSkge1xuICAgICAgICAgIG5yID0gMDtcbiAgICAgICAgICBuZyA9IDA7XG4gICAgICAgICAgbmIgPSAwO1xuICAgICAgICAgIG5hICo9IGEgLyAyNTU7XG4gICAgICAgIH1cblxuICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDAsIG5yKTtcbiAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxLCBuZyk7XG4gICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMiwgbmIpO1xuICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMsIG5hKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoc3JjRGF0YSwgMCwgMCk7XG4gIH1cblxufVxuXG5jbGFzcyBNYXNrRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdtYXNrJztcbiAgfVxuXG4gIGFwcGx5KGN0eCwgZWxlbWVudCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSB0aGlzOyAvLyByZW5kZXIgYXMgdGVtcCBzdmdcblxuICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkQm91bmRpbmdCb3goY2hpbGQuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgICB9KTtcbiAgICAgIHggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LngxKTtcbiAgICAgIHkgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LnkxKTtcbiAgICAgIHdpZHRoID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC53aWR0aCk7XG4gICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIGlnbm9yZWRTdHlsZXMgPSB0aGlzLnJlbW92ZVN0eWxlcyhlbGVtZW50LCBNYXNrRWxlbWVudC5pZ25vcmVTdHlsZXMpO1xuICAgIHZhciBtYXNrQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgdmFyIG1hc2tDdHggPSBtYXNrQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKG1hc2tDdHgpO1xuICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4obWFza0N0eCk7IC8vIGNvbnZlcnQgbWFzayB0byBhbHBoYSB3aXRoIGEgZmFrZSBub2RlXG4gICAgLy8gVE9ETzogcmVmYWN0b3Igb3V0IGFwcGx5IGZyb20gZmVDb2xvck1hdHJpeFxuXG4gICAgbmV3IEZlQ29sb3JNYXRyaXhFbGVtZW50KGRvY3VtZW50LCB7XG4gICAgICBub2RlVHlwZTogMSxcbiAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgYXR0cmlidXRlczogW3tcbiAgICAgICAgbm9kZU5hbWU6ICd0eXBlJyxcbiAgICAgICAgdmFsdWU6ICdsdW1pbmFuY2VUb0FscGhhJ1xuICAgICAgfSwge1xuICAgICAgICBub2RlTmFtZTogJ2luY2x1ZGVPcGFjaXR5JyxcbiAgICAgICAgdmFsdWU6ICd0cnVlJ1xuICAgICAgfV1cbiAgICB9KS5hcHBseShtYXNrQ3R4LCAwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgIHZhciB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXMoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKHRtcEN0eCk7XG4gICAgZWxlbWVudC5yZW5kZXIodG1wQ3R4KTtcbiAgICB0bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICB0bXBDdHguZmlsbFN0eWxlID0gbWFza0N0eC5jcmVhdGVQYXR0ZXJuKG1hc2tDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB0bXBDdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gdG1wQ3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7IC8vIHJlYXNzaWduIG1hc2tcblxuICAgIHRoaXMucmVzdG9yZVN0eWxlcyhlbGVtZW50LCBpZ25vcmVkU3R5bGVzKTtcbiAgfVxuXG4gIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxufVxuTWFza0VsZW1lbnQuaWdub3JlU3R5bGVzID0gWydtYXNrJywgJ3RyYW5zZm9ybScsICdjbGlwLXBhdGgnXTtcblxudmFyIG5vb3AgPSAoKSA9PiB7Ly8gTk9PUFxufTtcblxuY2xhc3MgQ2xpcFBhdGhFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2NsaXBQYXRoJztcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBjb250ZXh0UHJvdG8gPSBSZWZsZWN0LmdldFByb3RvdHlwZU9mKGN0eCk7XG4gICAgdmFyIHtcbiAgICAgIGJlZ2luUGF0aCxcbiAgICAgIGNsb3NlUGF0aFxuICAgIH0gPSBjdHg7XG5cbiAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICBjb250ZXh0UHJvdG8uYmVnaW5QYXRoID0gbm9vcDtcbiAgICAgIGNvbnRleHRQcm90by5jbG9zZVBhdGggPSBub29wO1xuICAgIH1cblxuICAgIFJlZmxlY3QuYXBwbHkoYmVnaW5QYXRoLCBjdHgsIFtdKTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZC5wYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0eXBlb2YgY2hpbGQuZWxlbWVudFRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCcgPyBjaGlsZC5lbGVtZW50VHJhbnNmb3JtKCkgOiBudWxsOyAvLyBoYW5kbGUgPHVzZSAvPlxuXG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm0uZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQucGF0aChjdHgpO1xuXG4gICAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICAgIGNvbnRleHRQcm90by5jbG9zZVBhdGggPSBjbG9zZVBhdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtLnVuYXBwbHkoY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBSZWZsZWN0LmFwcGx5KGNsb3NlUGF0aCwgY3R4LCBbXSk7XG4gICAgY3R4LmNsaXAoKTtcblxuICAgIGlmIChjb250ZXh0UHJvdG8pIHtcbiAgICAgIGNvbnRleHRQcm90by5iZWdpblBhdGggPSBiZWdpblBhdGg7XG4gICAgICBjb250ZXh0UHJvdG8uY2xvc2VQYXRoID0gY2xvc2VQYXRoO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxufVxuXG5jbGFzcyBGaWx0ZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2ZpbHRlcic7XG4gIH1cblxuICBhcHBseShjdHgsIGVsZW1lbnQpIHtcbiAgICAvLyByZW5kZXIgYXMgdGVtcCBzdmdcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBjaGlsZHJlblxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBib3VuZGluZ0JveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcblxuICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHggPSAwO1xuICAgIHZhciBweSA9IDA7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICB2YXIgZWZkID0gY2hpbGQuZXh0cmFGaWx0ZXJEaXN0YW5jZSB8fCAwO1xuICAgICAgcHggPSBNYXRoLm1heChweCwgZWZkKTtcbiAgICAgIHB5ID0gTWF0aC5tYXgocHksIGVmZCk7XG4gICAgfSk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC53aWR0aCk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3guaGVpZ2h0KTtcbiAgICB2YXIgdG1wQ2FudmFzV2lkdGggPSB3aWR0aCArIDIgKiBweDtcbiAgICB2YXIgdG1wQ2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICsgMiAqIHB5O1xuXG4gICAgaWYgKHRtcENhbnZhc1dpZHRoIDwgMSB8fCB0bXBDYW52YXNIZWlnaHQgPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LngpO1xuICAgIHZhciB5ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC55KTtcbiAgICB2YXIgaWdub3JlZFN0eWxlcyA9IHRoaXMucmVtb3ZlU3R5bGVzKGVsZW1lbnQsIEZpbHRlckVsZW1lbnQuaWdub3JlU3R5bGVzKTtcbiAgICB2YXIgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQpO1xuICAgIHZhciB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBkb2N1bWVudC5zY3JlZW4uc2V0RGVmYXVsdHModG1wQ3R4KTtcbiAgICB0bXBDdHgudHJhbnNsYXRlKC14ICsgcHgsIC15ICsgcHkpO1xuICAgIGVsZW1lbnQucmVuZGVyKHRtcEN0eCk7IC8vIGFwcGx5IGZpbHRlcnNcblxuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZC5hcHBseSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjaGlsZC5hcHBseSh0bXBDdHgsIDAsIDAsIHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQpO1xuICAgICAgfVxuICAgIH0pOyAvLyByZW5kZXIgb24gbWVcblxuICAgIGN0eC5kcmF3SW1hZ2UodG1wQ2FudmFzLCAwLCAwLCB0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0LCB4IC0gcHgsIHkgLSBweSwgdG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCk7XG4gICAgdGhpcy5yZXN0b3JlU3R5bGVzKGVsZW1lbnQsIGlnbm9yZWRTdHlsZXMpO1xuICB9XG5cbiAgcmVuZGVyKF8pIHsvLyBOTyBSRU5ERVJcbiAgfVxuXG59XG5GaWx0ZXJFbGVtZW50Lmlnbm9yZVN0eWxlcyA9IFsnZmlsdGVyJywgJ3RyYW5zZm9ybScsICdjbGlwLXBhdGgnXTtcblxuY2xhc3MgRmVEcm9wU2hhZG93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnZmVEcm9wU2hhZG93JztcbiAgICB0aGlzLmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTtcbiAgfVxuXG4gIGFwcGx5KF8sIF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KSB7Ly8gVE9ETzogaW1wbGVtZW50XG4gIH1cblxufVxuXG5jbGFzcyBGZU1vcnBob2xvZ3lFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2ZlTW9ycGhvbG9neSc7XG4gIH1cblxuICBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkgey8vIFRPRE86IGltcGxlbWVudFxuICB9XG5cbn1cblxuY2xhc3MgRmVDb21wb3NpdGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2ZlQ29tcG9zaXRlJztcbiAgfVxuXG4gIGFwcGx5KF8sIF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KSB7Ly8gVE9ETzogaW1wbGVtZW50XG4gIH1cblxufVxuXG5jbGFzcyBGZUdhdXNzaWFuQmx1ckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ZlR2F1c3NpYW5CbHVyJztcbiAgICB0aGlzLmJsdXJSYWRpdXMgPSBNYXRoLmZsb29yKHRoaXMuZ2V0QXR0cmlidXRlKCdzdGREZXZpYXRpb24nKS5nZXROdW1iZXIoKSk7XG4gICAgdGhpcy5leHRyYUZpbHRlckRpc3RhbmNlID0gdGhpcy5ibHVyUmFkaXVzO1xuICB9XG5cbiAgYXBwbHkoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgYmx1clJhZGl1c1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQud2luZG93ID8gZG9jdW1lbnQud2luZG93LmRvY3VtZW50LmJvZHkgOiBudWxsO1xuICAgIHZhciBjYW52YXMgPSBjdHguY2FudmFzOyAvLyBTdGFja0JsdXIgcmVxdWlyZXMgY2FudmFzIGJlIG9uIGRvY3VtZW50XG5cbiAgICBjYW52YXMuaWQgPSBkb2N1bWVudC5nZXRVbmlxdWVJZCgpO1xuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIH1cblxuICAgIGNhbnZhc1JHQkEoY2FudmFzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBibHVyUmFkaXVzKTtcblxuICAgIGlmIChib2R5KSB7XG4gICAgICBib2R5LnJlbW92ZUNoaWxkKGNhbnZhcyk7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3RpdGxlJztcbiAgfVxuXG59XG5cbmNsYXNzIERlc2NFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2Rlc2MnO1xuICB9XG5cbn1cblxudmFyIGVsZW1lbnRzID0ge1xuICAnc3ZnJzogU1ZHRWxlbWVudCxcbiAgJ3JlY3QnOiBSZWN0RWxlbWVudCxcbiAgJ2NpcmNsZSc6IENpcmNsZUVsZW1lbnQsXG4gICdlbGxpcHNlJzogRWxsaXBzZUVsZW1lbnQsXG4gICdsaW5lJzogTGluZUVsZW1lbnQsXG4gICdwb2x5bGluZSc6IFBvbHlsaW5lRWxlbWVudCxcbiAgJ3BvbHlnb24nOiBQb2x5Z29uRWxlbWVudCxcbiAgJ3BhdGgnOiBQYXRoRWxlbWVudCxcbiAgJ3BhdHRlcm4nOiBQYXR0ZXJuRWxlbWVudCxcbiAgJ21hcmtlcic6IE1hcmtlckVsZW1lbnQsXG4gICdkZWZzJzogRGVmc0VsZW1lbnQsXG4gICdsaW5lYXJHcmFkaWVudCc6IExpbmVhckdyYWRpZW50RWxlbWVudCxcbiAgJ3JhZGlhbEdyYWRpZW50JzogUmFkaWFsR3JhZGllbnRFbGVtZW50LFxuICAnc3RvcCc6IFN0b3BFbGVtZW50LFxuICAnYW5pbWF0ZSc6IEFuaW1hdGVFbGVtZW50LFxuICAnYW5pbWF0ZUNvbG9yJzogQW5pbWF0ZUNvbG9yRWxlbWVudCxcbiAgJ2FuaW1hdGVUcmFuc2Zvcm0nOiBBbmltYXRlVHJhbnNmb3JtRWxlbWVudCxcbiAgJ2ZvbnQnOiBGb250RWxlbWVudCxcbiAgJ2ZvbnQtZmFjZSc6IEZvbnRGYWNlRWxlbWVudCxcbiAgJ21pc3NpbmctZ2x5cGgnOiBNaXNzaW5nR2x5cGhFbGVtZW50LFxuICAnZ2x5cGgnOiBHbHlwaEVsZW1lbnQsXG4gICd0ZXh0JzogVGV4dEVsZW1lbnQsXG4gICd0c3Bhbic6IFRTcGFuRWxlbWVudCxcbiAgJ3RyZWYnOiBUUmVmRWxlbWVudCxcbiAgJ2EnOiBBRWxlbWVudCxcbiAgJ3RleHRQYXRoJzogVGV4dFBhdGhFbGVtZW50LFxuICAnaW1hZ2UnOiBJbWFnZUVsZW1lbnQsXG4gICdnJzogR0VsZW1lbnQsXG4gICdzeW1ib2wnOiBTeW1ib2xFbGVtZW50LFxuICAnc3R5bGUnOiBTdHlsZUVsZW1lbnQsXG4gICd1c2UnOiBVc2VFbGVtZW50LFxuICAnbWFzayc6IE1hc2tFbGVtZW50LFxuICAnY2xpcFBhdGgnOiBDbGlwUGF0aEVsZW1lbnQsXG4gICdmaWx0ZXInOiBGaWx0ZXJFbGVtZW50LFxuICAnZmVEcm9wU2hhZG93JzogRmVEcm9wU2hhZG93RWxlbWVudCxcbiAgJ2ZlTW9ycGhvbG9neSc6IEZlTW9ycGhvbG9neUVsZW1lbnQsXG4gICdmZUNvbXBvc2l0ZSc6IEZlQ29tcG9zaXRlRWxlbWVudCxcbiAgJ2ZlQ29sb3JNYXRyaXgnOiBGZUNvbG9yTWF0cml4RWxlbWVudCxcbiAgJ2ZlR2F1c3NpYW5CbHVyJzogRmVHYXVzc2lhbkJsdXJFbGVtZW50LFxuICAndGl0bGUnOiBUaXRsZUVsZW1lbnQsXG4gICdkZXNjJzogRGVzY0VsZW1lbnRcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbWFnZShfeCkge1xuICByZXR1cm4gX2NyZWF0ZUltYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVJbWFnZSgpIHtcbiAgX2NyZWF0ZUltYWdlID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChzcmMpIHtcbiAgICB2YXIgYW5vbnltb3VzQ3Jvc3NPcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXG4gICAgaWYgKGFub255bW91c0Nyb3NzT3JpZ2luKSB7XG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoaW1hZ2UpO1xuICAgICAgfTtcblxuICAgICAgaW1hZ2Uub25lcnJvciA9IChfZXZlbnQsIF9zb3VyY2UsIF9saW5lbm8sIF9jb2xubywgZXJyb3IpID0+IHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH07XG5cbiAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBfY3JlYXRlSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuY2xhc3MgRG9jdW1lbnQge1xuICBjb25zdHJ1Y3RvcihjYW52Zykge1xuICAgIHZhciB7XG4gICAgICByb290RW1TaXplID0gMTIsXG4gICAgICBlbVNpemUgPSAxMixcbiAgICAgIGNyZWF0ZUNhbnZhcyA9IERvY3VtZW50LmNyZWF0ZUNhbnZhcyxcbiAgICAgIGNyZWF0ZUltYWdlID0gRG9jdW1lbnQuY3JlYXRlSW1hZ2UsXG4gICAgICBhbm9ueW1vdXNDcm9zc09yaWdpblxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuY2FudmcgPSBjYW52ZztcbiAgICB0aGlzLmRlZmluaXRpb25zID0ge307XG4gICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5ID0ge307XG4gICAgdGhpcy5pbWFnZXMgPSBbXTtcbiAgICB0aGlzLmZvbnRzID0gW107XG4gICAgdGhpcy5lbVNpemVTdGFjayA9IFtdO1xuICAgIHRoaXMudW5pcXVlSWQgPSAwO1xuICAgIHRoaXMuc2NyZWVuID0gY2Fudmcuc2NyZWVuO1xuICAgIHRoaXMucm9vdEVtU2l6ZSA9IHJvb3RFbVNpemU7XG4gICAgdGhpcy5lbVNpemUgPSBlbVNpemU7XG4gICAgdGhpcy5jcmVhdGVDYW52YXMgPSBjcmVhdGVDYW52YXM7XG4gICAgdGhpcy5jcmVhdGVJbWFnZSA9IHRoaXMuYmluZENyZWF0ZUltYWdlKGNyZWF0ZUltYWdlLCBhbm9ueW1vdXNDcm9zc09yaWdpbik7XG4gICAgdGhpcy5zY3JlZW4ud2FpdCh0aGlzLmlzSW1hZ2VzTG9hZGVkLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2NyZWVuLndhaXQodGhpcy5pc0ZvbnRzTG9hZGVkLmJpbmQodGhpcykpO1xuICB9XG5cbiAgYmluZENyZWF0ZUltYWdlKGNyZWF0ZUltYWdlLCBhbm9ueW1vdXNDcm9zc09yaWdpbikge1xuICAgIGlmICh0eXBlb2YgYW5vbnltb3VzQ3Jvc3NPcmlnaW4gPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIChzb3VyY2UsIGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4pID0+IGNyZWF0ZUltYWdlKHNvdXJjZSwgdHlwZW9mIGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4gPT09ICdib29sZWFuJyA/IGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4gOiBhbm9ueW1vdXNDcm9zc09yaWdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUltYWdlO1xuICB9XG5cbiAgZ2V0IHdpbmRvdygpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4ud2luZG93O1xuICB9XG5cbiAgZ2V0IGZldGNoKCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi5mZXRjaDtcbiAgfVxuXG4gIGdldCBjdHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLmN0eDtcbiAgfVxuXG4gIGdldCBlbVNpemUoKSB7XG4gICAgdmFyIHtcbiAgICAgIGVtU2l6ZVN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGVtU2l6ZVN0YWNrW2VtU2l6ZVN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgc2V0IGVtU2l6ZSh2YWx1ZSkge1xuICAgIHZhciB7XG4gICAgICBlbVNpemVTdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIGVtU2l6ZVN0YWNrLnB1c2godmFsdWUpO1xuICB9XG5cbiAgcG9wRW1TaXplKCkge1xuICAgIHZhciB7XG4gICAgICBlbVNpemVTdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIGVtU2l6ZVN0YWNrLnBvcCgpO1xuICB9XG5cbiAgZ2V0VW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIFwiY2FudmdcIi5jb25jYXQoKyt0aGlzLnVuaXF1ZUlkKTtcbiAgfVxuXG4gIGlzSW1hZ2VzTG9hZGVkKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlcy5ldmVyeShfID0+IF8ubG9hZGVkKTtcbiAgfVxuXG4gIGlzRm9udHNMb2FkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9udHMuZXZlcnkoXyA9PiBfLmxvYWRlZCk7XG4gIH1cblxuICBjcmVhdGVEb2N1bWVudEVsZW1lbnQoZG9jdW1lbnQpIHtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgZG9jdW1lbnRFbGVtZW50LnJvb3QgPSB0cnVlO1xuICAgIGRvY3VtZW50RWxlbWVudC5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIGNyZWF0ZUVsZW1lbnQobm9kZSkge1xuICAgIHZhciBlbGVtZW50VHlwZSA9IG5vZGUubm9kZU5hbWUucmVwbGFjZSgvXlteOl0rOi8sICcnKTtcbiAgICB2YXIgRWxlbWVudFR5cGUgPSBEb2N1bWVudC5lbGVtZW50VHlwZXNbZWxlbWVudFR5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBFbGVtZW50VHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgRWxlbWVudFR5cGUodGhpcywgbm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBVbmtub3duRWxlbWVudCh0aGlzLCBub2RlKTtcbiAgfVxuXG4gIGNyZWF0ZVRleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMsIG5vZGUpO1xuICB9XG5cbiAgc2V0Vmlld0JveChjb25maWcpIHtcbiAgICB0aGlzLnNjcmVlbi5zZXRWaWV3Qm94KF9vYmplY3RTcHJlYWQkMSh7XG4gICAgICBkb2N1bWVudDogdGhpc1xuICAgIH0sIGNvbmZpZykpO1xuICB9XG5cbn1cbkRvY3VtZW50LmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbkRvY3VtZW50LmNyZWF0ZUltYWdlID0gY3JlYXRlSW1hZ2U7XG5Eb2N1bWVudC5lbGVtZW50VHlwZXMgPSBlbGVtZW50cztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuLyoqXHJcbiAqIFNWRyByZW5kZXJlciBvbiBjYW52YXMuXHJcbiAqL1xuXG5jbGFzcyBDYW52ZyB7XG4gIC8qKlxyXG4gICAqIE1haW4gY29uc3RydWN0b3IuXHJcbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgRG9jdW1lbnQuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgKi9cbiAgY29uc3RydWN0b3IoY3R4LCBzdmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdGhpcy5wYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHRoaXMuc2NyZWVuID0gbmV3IFNjcmVlbihjdHgsIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIGRvY3VtZW50ID0gbmV3IERvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEVsZW1lbnQoc3ZnKTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIENhbnZnIGluc3RhbmNlIGZyb20gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxyXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICBzdGF0aWMgZnJvbShjdHgsIHN2Zykge1xuICAgIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBfYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgX2FyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICB2YXIgc3ZnRG9jdW1lbnQgPSB5aWVsZCBwYXJzZXIucGFyc2Uoc3ZnKTtcbiAgICAgIHJldHVybiBuZXcgQ2FudmcoY3R4LCBzdmdEb2N1bWVudCwgb3B0aW9ucyk7XG4gICAgfSkoKTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgQ2FudmcgaW5zdGFuY2UgZnJvbSBTVkcgc291cmNlIHN0cmluZy5cclxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICBzdGF0aWMgZnJvbVN0cmluZyhjdHgsIHN2Zykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICB2YXIgc3ZnRG9jdW1lbnQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2Zyk7XG4gICAgcmV0dXJuIG5ldyBDYW52ZyhjdHgsIHN2Z0RvY3VtZW50LCBvcHRpb25zKTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IENhbnZnIGluc3RhbmNlIHdpdGggaW5oZXJpdGVkIG9wdGlvbnMuXHJcbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZyBvciBVUkwuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIGZvcmsoY3R4LCBzdmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIENhbnZnLmZyb20oY3R4LCBzdmcsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgQ2FudmcgaW5zdGFuY2Ugd2l0aCBpbmhlcml0ZWQgb3B0aW9ucy5cclxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICBmb3JrU3RyaW5nKGN0eCwgc3ZnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBDYW52Zy5mcm9tU3RyaW5nKGN0eCwgc3ZnLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcclxuICAgKiBEb2N1bWVudCBpcyByZWFkeSBwcm9taXNlLlxyXG4gICAqIEByZXR1cm5zIFJlYWR5IHByb21pc2UuXHJcbiAgICovXG5cblxuICByZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4ucmVhZHkoKTtcbiAgfVxuICAvKipcclxuICAgKiBEb2N1bWVudCBpcyByZWFkeSB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyBJcyByZWFkeSBvciBub3QuXHJcbiAgICovXG5cblxuICBpc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi5pc1JlYWR5KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVuZGVyIG9ubHkgZmlyc3QgZnJhbWUsIGlnbm9yaW5nIGFuaW1hdGlvbnMgYW5kIG1vdXNlLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICovXG5cblxuICByZW5kZXIoKSB7XG4gICAgdmFyIF9hcmd1bWVudHMyID0gYXJndW1lbnRzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gX2FyZ3VtZW50czIubGVuZ3RoID4gMCAmJiBfYXJndW1lbnRzMlswXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3VtZW50czJbMF0gOiB7fTtcblxuICAgICAgX3RoaXMuc3RhcnQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGVuYWJsZVJlZHJhdzogdHJ1ZSxcbiAgICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZVxuICAgICAgfSwgb3B0aW9ucykpO1xuXG4gICAgICB5aWVsZCBfdGhpcy5yZWFkeSgpO1xuXG4gICAgICBfdGhpcy5zdG9wKCk7XG4gICAgfSkoKTtcbiAgfVxuICAvKipcclxuICAgKiBTdGFydCByZW5kZXJpbmcuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXIgb3B0aW9ucy5cclxuICAgKi9cblxuXG4gIHN0YXJ0KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2NyZWVuLFxuICAgICAgb3B0aW9uczogYmFzZU9wdGlvbnNcbiAgICB9ID0gdGhpcztcbiAgICBzY3JlZW4uc3RhcnQoZG9jdW1lbnRFbGVtZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgZW5hYmxlUmVkcmF3OiB0cnVlXG4gICAgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RvcCByZW5kZXJpbmcuXHJcbiAgICovXG5cblxuICBzdG9wKCkge1xuICAgIHRoaXMuc2NyZWVuLnN0b3AoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXNpemUgU1ZHIHRvIGZpdCBpbiBnaXZlbiBzaXplLlxyXG4gICAqIEBwYXJhbSB3aWR0aFxyXG4gICAqIEBwYXJhbSBoZWlnaHRcclxuICAgKiBAcGFyYW0gcHJlc2VydmVBc3BlY3RSYXRpb1xyXG4gICAqL1xuXG5cbiAgcmVzaXplKHdpZHRoKSB7XG4gICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogd2lkdGg7XG4gICAgdmFyIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBwcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgfVxuXG59XG5cbmV4cG9ydCB7IEFFbGVtZW50LCBBbmltYXRlQ29sb3JFbGVtZW50LCBBbmltYXRlRWxlbWVudCwgQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQsIEJvdW5kaW5nQm94LCBDQjEsIENCMiwgQ0IzLCBDQjQsIENhbnZnLCBDaXJjbGVFbGVtZW50LCBDbGlwUGF0aEVsZW1lbnQsIERlZnNFbGVtZW50LCBEZXNjRWxlbWVudCwgRG9jdW1lbnQsIEVsZW1lbnQsIEVsbGlwc2VFbGVtZW50LCBGZUNvbG9yTWF0cml4RWxlbWVudCwgRmVDb21wb3NpdGVFbGVtZW50LCBGZURyb3BTaGFkb3dFbGVtZW50LCBGZUdhdXNzaWFuQmx1ckVsZW1lbnQsIEZlTW9ycGhvbG9neUVsZW1lbnQsIEZpbHRlckVsZW1lbnQsIEZvbnQsIEZvbnRFbGVtZW50LCBGb250RmFjZUVsZW1lbnQsIEdFbGVtZW50LCBHbHlwaEVsZW1lbnQsIEdyYWRpZW50RWxlbWVudCwgSW1hZ2VFbGVtZW50LCBMaW5lRWxlbWVudCwgTGluZWFyR3JhZGllbnRFbGVtZW50LCBNYXJrZXJFbGVtZW50LCBNYXNrRWxlbWVudCwgTWF0cml4LCBNaXNzaW5nR2x5cGhFbGVtZW50LCBNb3VzZSwgUFNFVURPX1pFUk8sIFBhcnNlciwgUGF0aEVsZW1lbnQsIFBhdGhQYXJzZXIsIFBhdHRlcm5FbGVtZW50LCBQb2ludCwgUG9seWdvbkVsZW1lbnQsIFBvbHlsaW5lRWxlbWVudCwgUHJvcGVydHksIFFCMSwgUUIyLCBRQjMsIFJhZGlhbEdyYWRpZW50RWxlbWVudCwgUmVjdEVsZW1lbnQsIFJlbmRlcmVkRWxlbWVudCwgUm90YXRlLCBTVkdFbGVtZW50LCBTVkdGb250TG9hZGVyLCBTY2FsZSwgU2NyZWVuLCBTa2V3LCBTa2V3WCwgU2tld1ksIFN0b3BFbGVtZW50LCBTdHlsZUVsZW1lbnQsIFN5bWJvbEVsZW1lbnQsIFRSZWZFbGVtZW50LCBUU3BhbkVsZW1lbnQsIFRleHRFbGVtZW50LCBUZXh0UGF0aEVsZW1lbnQsIFRpdGxlRWxlbWVudCwgVHJhbnNmb3JtLCBUcmFuc2xhdGUsIFVua25vd25FbGVtZW50LCBVc2VFbGVtZW50LCBWaWV3UG9ydCwgY29tcHJlc3NTcGFjZXMsIENhbnZnIGFzIGRlZmF1bHQsIGdldFNlbGVjdG9yU3BlY2lmaWNpdHksIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUsIG5vcm1hbGl6ZUNvbG9yLCBwYXJzZUV4dGVybmFsVXJsLCBpbmRleCBhcyBwcmVzZXRzLCB0b051bWJlcnMsIHRyaW1MZWZ0LCB0cmltUmlnaHQsIHZlY3Rvck1hZ25pdHVkZSwgdmVjdG9yc0FuZ2xlLCB2ZWN0b3JzUmF0aW8gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3VaWE11YW5NaUxDSnpiM1Z5WTJWeklqcGJYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHRkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096c2lmUT09XG4iXSwibmFtZXMiOlsiX2FzeW5jVG9HZW5lcmF0b3IiLCJfZGVmaW5lUHJvcGVydHkiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJSR0JDb2xvciIsIlNWR1BhdGhEYXRhIiwiY2FudmFzUkdCQSIsIm9mZnNjcmVlbiIsIkRPTVBhcnNlciIsIkRPTVBhcnNlckZhbGxiYWNrIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwicHJlc2V0Iiwid2luZG93IiwiaWdub3JlQW5pbWF0aW9uIiwiaWdub3JlTW91c2UiLCJjcmVhdGVDYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsIk9mZnNjcmVlbkNhbnZhcyIsImNyZWF0ZUltYWdlIiwidXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsImJsb2IiLCJpbWciLCJjcmVhdGVJbWFnZUJpdG1hcCIsIlJlZmxlY3QiLCJkZWxldGVQcm9wZXJ0eSIsIm5vZGUiLCJfcmVmIiwiY2FudmFzIiwibG9hZEltYWdlIiwiaW5kZXgiLCJPYmplY3QiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJjb21wcmVzc1NwYWNlcyIsInN0ciIsInJlcGxhY2UiLCJ0cmltTGVmdCIsInRyaW1SaWdodCIsInRvTnVtYmVycyIsIm1hdGNoZXMiLCJtYXRjaCIsIm1hcCIsInBhcnNlRmxvYXQiLCJhbGxVcHBlcmNhc2UiLCJub3JtYWxpemVBdHRyaWJ1dGVOYW1lIiwibmFtZSIsInRlc3QiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlRXh0ZXJuYWxVcmwiLCJ1cmxNYXRjaCIsImV4ZWMiLCJub3JtYWxpemVDb2xvciIsImNvbG9yIiwic3RhcnRzV2l0aCIsInJnYlBhcnRzIiwibm9ybWFsaXplZENvbG9yIiwibnVtIiwiaXNGbG9hdCIsIlN0cmluZyIsIk1hdGgiLCJyb3VuZCIsImF0dHJpYnV0ZVJlZ2V4IiwiaWRSZWdleCIsImNsYXNzUmVnZXgiLCJwc2V1ZG9FbGVtZW50UmVnZXgiLCJwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4IiwicHNldWRvQ2xhc3NSZWdleCIsImVsZW1lbnRSZWdleCIsImZpbmRTZWxlY3Rvck1hdGNoIiwic2VsZWN0b3IiLCJyZWdleCIsImdldFNlbGVjdG9yU3BlY2lmaWNpdHkiLCJzcGVjaWZpY2l0eSIsImN1cnJlbnRTZWxlY3RvciIsImRlbHRhIiwiam9pbiIsIlBTRVVET19aRVJPIiwidmVjdG9yTWFnbml0dWRlIiwidiIsInNxcnQiLCJwb3ciLCJ2ZWN0b3JzUmF0aW8iLCJ1IiwidmVjdG9yc0FuZ2xlIiwiYWNvcyIsIkNCMSIsInQiLCJDQjIiLCJDQjMiLCJDQjQiLCJRQjEiLCJRQjIiLCJRQjMiLCJQcm9wZXJ0eSIsImNvbnN0cnVjdG9yIiwiZG9jdW1lbnQiLCJ2YWx1ZSIsImlzTm9ybWFsaXplZENvbG9yIiwiZW1wdHkiLCJzcGxpdCIsInNlcGFyYXRvciIsImdldFN0cmluZyIsInRyaW0iLCJoYXNWYWx1ZSIsInplcm9Jc1ZhbHVlIiwiaXNTdHJpbmciLCJyZWdleHAiLCJyZXN1bHQiLCJpc1VybERlZmluaXRpb24iLCJpc1BpeGVscyIsImFzU3RyaW5nIiwiZW5kc1dpdGgiLCJzZXRWYWx1ZSIsImdldFZhbHVlIiwiZGVmIiwiZ2V0TnVtYmVyIiwibiIsImdldENvbG9yIiwiZ2V0RHBpIiwiZ2V0UmVtIiwicm9vdEVtU2l6ZSIsImdldEVtIiwiZW1TaXplIiwiZ2V0VW5pdHMiLCJnZXRQaXhlbHMiLCJheGlzT3JJc0ZvbnRTaXplIiwicHJvY2Vzc1BlcmNlbnQiLCJheGlzIiwiaXNGb250U2l6ZSIsInZpZXdQb3J0Iiwic2NyZWVuIiwibWluIiwiY29tcHV0ZVNpemUiLCJtYXgiLCJnZXRNaWxsaXNlY29uZHMiLCJnZXRSYWRpYW5zIiwiUEkiLCJnZXREZWZpbml0aW9uIiwiZGVmaW5pdGlvbnMiLCJnZXRGaWxsU3R5bGVEZWZpbml0aW9uIiwiZWxlbWVudCIsIm9wYWNpdHkiLCJjcmVhdGVHcmFkaWVudCIsImN0eCIsImNyZWF0ZVBhdHRlcm4iLCJnZXRIcmVmQXR0cmlidXRlIiwicGF0dGVyblRyYW5zZm9ybSIsImdldEF0dHJpYnV0ZSIsImdldFRleHRCYXNlbGluZSIsInRleHRCYXNlbGluZU1hcHBpbmciLCJhZGRPcGFjaXR5IiwibGVuIiwiY29tbWFzIiwiaSIsIm9rIiwiYWxwaGEiLCJ0b1JHQkEiLCJWaWV3UG9ydCIsInZpZXdQb3J0cyIsImNsZWFyIiwic2V0Q3VycmVudCIsInB1c2giLCJyZW1vdmVDdXJyZW50IiwicG9wIiwiZ2V0Q3VycmVudCIsImQiLCJQb2ludCIsIngiLCJ5IiwicGFyc2UiLCJwb2ludCIsImRlZmF1bHRWYWx1ZSIsInBhcnNlU2NhbGUiLCJzY2FsZSIsInBhcnNlUGF0aCIsInBhdGgiLCJwb2ludHMiLCJwYXRoUG9pbnRzIiwiYW5nbGVUbyIsImF0YW4yIiwiYXBwbHlUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJ4cCIsInlwIiwiTW91c2UiLCJ3b3JraW5nIiwiZXZlbnRzIiwiZXZlbnRFbGVtZW50cyIsIm9uQ2xpY2siLCJiaW5kIiwib25Nb3VzZU1vdmUiLCJpc1dvcmtpbmciLCJzdGFydCIsIm9uY2xpY2siLCJvbm1vdXNlbW92ZSIsInN0b3AiLCJoYXNFdmVudHMiLCJydW5FdmVudHMiLCJzdHlsZSIsImN1cnNvciIsImZvckVhY2giLCJydW4iLCJwYXJlbnQiLCJjaGVja1BhdGgiLCJfcmVmMiIsImlzUG9pbnRJblBhdGgiLCJjaGVja0JvdW5kaW5nQm94IiwiYm91bmRpbmdCb3giLCJfcmVmMyIsImlzUG9pbnRJbkJveCIsIm1hcFhZIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsIm9mZnNldFBhcmVudCIsInNjcm9sbFgiLCJzY3JvbGxZIiwiZXZlbnQiLCJjbGllbnRYIiwiY2xpZW50WSIsInR5cGUiLCJldmVudFRhcmdldCIsImRlZmF1bHRXaW5kb3ciLCJkZWZhdWx0RmV0Y2gkMSIsIlNjcmVlbiIsIkZSQU1FUkFURSIsIk1BWF9WSVJUVUFMX1BJWEVMUyIsIkNMSUVOVF9XSURUSCIsIkNMSUVOVF9IRUlHSFQiLCJtb3VzZSIsImFuaW1hdGlvbnMiLCJ3YWl0cyIsImZyYW1lRHVyYXRpb24iLCJpc1JlYWR5TG9jayIsImlzRmlyc3RSZW5kZXIiLCJpbnRlcnZhbElkIiwid2FpdCIsImNoZWNrZXIiLCJyZWFkeSIsInJlYWR5UHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaXNSZWFkeSIsImV2ZXJ5IiwiXyIsInJlc29sdmVSZWFkeSIsInNldERlZmF1bHRzIiwic3Ryb2tlU3R5bGUiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJtaXRlckxpbWl0Iiwic2V0Vmlld0JveCIsImFzcGVjdFJhdGlvIiwiZGVzaXJlZFdpZHRoIiwiZGVzaXJlZEhlaWdodCIsIm1pblgiLCJtaW5ZIiwicmVmWCIsInJlZlkiLCJjbGlwIiwiY2xpcFgiLCJjbGlwWSIsImNsZWFuQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpb0FsaWduIiwiYXNwZWN0UmF0aW9NZWV0T3JTbGljZSIsImFsaWduIiwibWVldE9yU2xpY2UiLCJzY2FsZVgiLCJzY2FsZVkiLCJzY2FsZU1pbiIsInNjYWxlTWF4IiwiZmluYWxEZXNpcmVkV2lkdGgiLCJmaW5hbERlc2lyZWRIZWlnaHQiLCJyZWZYUHJvcCIsInJlZllQcm9wIiwiaGFzUmVmcyIsInRyYW5zbGF0ZSIsInNjYWxlZENsaXBYIiwic2NhbGVkQ2xpcFkiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJpc01lZXRNaW5ZIiwiaXNTbGljZU1heFkiLCJpc01lZXRNaW5YIiwiaXNTbGljZU1heFgiLCJlbmFibGVSZWRyYXciLCJpZ25vcmVEaW1lbnNpb25zIiwiaWdub3JlQ2xlYXIiLCJmb3JjZVJlZHJhdyIsInNjYWxlV2lkdGgiLCJzY2FsZUhlaWdodCIsIm9mZnNldFgiLCJvZmZzZXRZIiwicmVuZGVyIiwibm93IiwiRGF0ZSIsInRoZW4iLCJ0aWNrIiwic2hvdWxkVXBkYXRlIiwiY2FuY2VsIiwicmVkdWNlIiwiYW5pbWF0aW9uIiwidXBkYXRlIiwid2lkdGhTdHlsZSIsImdldFN0eWxlIiwiaGVpZ2h0U3R5bGUiLCJjb25jYXQiLCJjV2lkdGgiLCJjbGllbnRXaWR0aCIsImNIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJ2aWV3Qm94IiwieFJhdGlvIiwieVJhdGlvIiwiX3dpZHRoU3R5bGUiLCJpc05hTiIsIl9oZWlnaHRTdHlsZSIsInRyYW5zZm9ybVN0eWxlIiwiY2xlYXJSZWN0IiwiZGVmYXVsdEZldGNoIiwiRGVmYXVsdERPTVBhcnNlciIsIlBhcnNlciIsInJlc291cmNlIiwiX3RoaXMiLCJwYXJzZUZyb21TdHJpbmciLCJsb2FkIiwieG1sIiwicGFyc2VyIiwiY2hlY2tEb2N1bWVudCIsImVyciIsInBhcnNlckVycm9yIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJFcnJvciIsInRleHRDb250ZW50IiwiX3RoaXMyIiwidGV4dCIsIlRyYW5zbGF0ZSIsImFwcGx5IiwidW5hcHBseSIsImFwcGx5VG9Qb2ludCIsIlJvdGF0ZSIsInJvdGF0ZSIsInRyYW5zZm9ybU9yaWdpbiIsImFuZ2xlIiwib3JpZ2luWCIsIm9yaWdpblkiLCJjeCIsImN5IiwibnVtYmVycyIsInR4IiwidHkiLCJyYWQiLCJjb3MiLCJzaW4iLCJTY2FsZSIsInNjYWxlU2l6ZSIsIk1hdHJpeCIsIm1hdHJpeCIsImEiLCJiIiwiYyIsImUiLCJmIiwiZyIsImgiLCJkZXQiLCJTa2V3Iiwic2tldyIsIlNrZXdYIiwidGFuIiwiU2tld1kiLCJwYXJzZVRyYW5zZm9ybXMiLCJwYXJzZVRyYW5zZm9ybSIsIlRyYW5zZm9ybSIsInRyYW5zZm9ybXMiLCJkYXRhIiwiVHJhbnNmb3JtVHlwZSIsInRyYW5zZm9ybVR5cGVzIiwiZnJvbUVsZW1lbnQiLCJ0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHkiLCJ0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHkiLCJza2V3WCIsInNrZXdZIiwiRWxlbWVudCIsImNhcHR1cmVUZXh0Tm9kZXMiLCJhdHRyaWJ1dGVzIiwic3R5bGVzIiwic3R5bGVzU3BlY2lmaWNpdHkiLCJhbmltYXRpb25Gcm96ZW4iLCJhbmltYXRpb25Gcm96ZW5WYWx1ZSIsImNoaWxkcmVuIiwibm9kZVR5cGUiLCJBcnJheSIsImZyb20iLCJhdHRyaWJ1dGUiLCJub2RlTmFtZSIsImFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24iLCJpZCIsImNoaWxkTm9kZXMiLCJjaGlsZE5vZGUiLCJhZGRDaGlsZCIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJnZXRUZXh0IiwiY3JlYXRlSWZOb3RFeGlzdHMiLCJhdHRyIiwiX2F0dHIiLCJrZXkiLCJza2lwQW5jZXN0b3JzIiwicGFyZW50U3R5bGUiLCJfc3R5bGUiLCJzYXZlIiwibWFzayIsImFwcGx5RWZmZWN0cyIsImZpbHRlciIsInNldENvbnRleHQiLCJyZW5kZXJDaGlsZHJlbiIsImNsZWFyQ29udGV4dCIsInJlc3RvcmUiLCJjbGlwUGF0aFN0eWxlUHJvcCIsImNoaWxkIiwiY3JlYXRlRWxlbWVudCIsImlnbm9yZUNoaWxkVHlwZXMiLCJpbmNsdWRlcyIsIm1hdGNoZXNTZWxlY3RvciIsIl9ub2RlJGdldEF0dHJpYnV0ZSIsInN0eWxlQ2xhc3NlcyIsImNhbGwiLCJzb21lIiwic3R5bGVDbGFzcyIsImV4aXN0aW5nU3BlY2lmaWNpdHkiLCJyZW1vdmVTdHlsZXMiLCJpZ25vcmVTdHlsZXMiLCJ0b1Jlc3RvcmUiLCJzdHlsZVByb3AiLCJyZXN0b3JlU3R5bGVzIiwiaXNGaXJzdENoaWxkIiwiX3RoaXMkcGFyZW50IiwiaW5kZXhPZiIsIlVua25vd25FbGVtZW50Iiwid3JhcEZvbnRGYW1pbHkiLCJmb250RmFtaWx5IiwidHJpbW1lZCIsInByZXBhcmVGb250RmFtaWx5IiwicHJvY2VzcyIsInByZXBhcmVGb250U3R5bGUiLCJmb250U3R5bGUiLCJ0YXJnZXRGb250U3R5bGUiLCJwcmVwYXJlRm9udFdlaWdodCIsImZvbnRXZWlnaHQiLCJ0YXJnZXRGb250V2VpZ2h0IiwiRm9udCIsImZvbnRWYXJpYW50IiwiZm9udFNpemUiLCJpbmhlcml0IiwiaW5oZXJpdEZvbnQiLCJmb250IiwicGFydHMiLCJzZXQiLCJwYXJ0IiwidmFyaWFudHMiLCJ3ZWlnaHRzIiwidG9TdHJpbmciLCJCb3VuZGluZ0JveCIsIngxIiwiTnVtYmVyIiwiTmFOIiwieTEiLCJ4MiIsInkyIiwiYWRkUG9pbnQiLCJhZGRYIiwiYWRkWSIsImFkZEJvdW5kaW5nQm94Iiwic3VtQ3ViaWMiLCJwMCIsInAxIiwicDIiLCJwMyIsImJlemllckN1cnZlQWRkIiwiZm9yWCIsImIyYWMiLCJ0MSIsInQyIiwiYWRkQmV6aWVyQ3VydmUiLCJwMHgiLCJwMHkiLCJwMXgiLCJwMXkiLCJwMngiLCJwMnkiLCJwM3giLCJwM3kiLCJhZGRRdWFkcmF0aWNDdXJ2ZSIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJQYXRoUGFyc2VyIiwiY29udHJvbCIsImN1cnJlbnQiLCJjb21tYW5kIiwiY29tbWFuZHMiLCJwcmV2aW91c0NvbW1hbmQiLCJhbmdsZXMiLCJyZXNldCIsImlzRW5kIiwibmV4dCIsImdldFBvaW50IiwieFByb3AiLCJ5UHJvcCIsIm1ha2VBYnNvbHV0ZSIsImdldEFzQ29udHJvbFBvaW50IiwiZ2V0QXNDdXJyZW50UG9pbnQiLCJnZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQiLCJDVVJWRV9UTyIsIlNNT09USF9DVVJWRV9UTyIsIlFVQURfVE8iLCJTTU9PVEhfUVVBRF9UTyIsIm94Iiwib3kiLCJyZWxhdGl2ZSIsImFkZE1hcmtlciIsInByaW9yVG8iLCJhZGRNYXJrZXJBbmdsZSIsImdldE1hcmtlclBvaW50cyIsImdldE1hcmtlckFuZ2xlcyIsImoiLCJSZW5kZXJlZEVsZW1lbnQiLCJtb2RpZmllZEVtU2l6ZVN0YWNrIiwiY2FsY3VsYXRlT3BhY2l0eSIsIm9wYWNpdHlTdHlsZSIsImZyb21NZWFzdXJlIiwiZmlsbFN0eWxlUHJvcCIsImZpbGxPcGFjaXR5U3R5bGVQcm9wIiwic3Ryb2tlU3R5bGVQcm9wIiwic3Ryb2tlT3BhY2l0eVByb3AiLCJmaWxsU3R5bGUiLCJfZmlsbFN0eWxlIiwiX2ZpbGxTdHlsZTIiLCJfc3Ryb2tlU3R5bGUiLCJfc3Ryb2tlU3R5bGUyIiwic3Ryb2tlV2lkdGhTdHlsZVByb3AiLCJuZXdMaW5lV2lkdGgiLCJsaW5lV2lkdGgiLCJzdHJva2VMaW5lY2FwU3R5bGVQcm9wIiwic3Ryb2tlTGluZWpvaW5TdHlsZVByb3AiLCJzdHJva2VNaXRlcmxpbWl0UHJvcCIsInN0cm9rZURhc2hhcnJheVN0eWxlUHJvcCIsInN0cm9rZURhc2hvZmZzZXRQcm9wIiwiZ2FwcyIsInNldExpbmVEYXNoIiwid2Via2l0TGluZURhc2giLCJtb3pEYXNoIiwib2Zmc2V0IiwibGluZURhc2hPZmZzZXQiLCJ3ZWJraXRMaW5lRGFzaE9mZnNldCIsIm1vekRhc2hPZmZzZXQiLCJmb250U3R5bGVQcm9wIiwiZm9udFN0eWxlU3R5bGVQcm9wIiwiZm9udFZhcmlhbnRTdHlsZVByb3AiLCJmb250V2VpZ2h0U3R5bGVQcm9wIiwiZm9udFNpemVTdHlsZVByb3AiLCJmb250RmFtaWx5U3R5bGVQcm9wIiwiZ2xvYmFsQWxwaGEiLCJwb3BFbVNpemUiLCJQYXRoRWxlbWVudCIsInBhdGhQYXJzZXIiLCJNT1ZFX1RPIiwicGF0aE0iLCJMSU5FX1RPIiwicGF0aEwiLCJIT1JJWl9MSU5FX1RPIiwicGF0aEgiLCJWRVJUX0xJTkVfVE8iLCJwYXRoViIsInBhdGhDIiwicGF0aFMiLCJwYXRoUSIsInBhdGhUIiwiQVJDIiwicGF0aEEiLCJDTE9TRV9QQVRIIiwicGF0aFoiLCJnZXRCb3VuZGluZ0JveCIsImdldE1hcmtlcnMiLCJtYXJrZXJzIiwiZmlsbFJ1bGVTdHlsZVByb3AiLCJmaWxsIiwic2V0VHJhbnNmb3JtIiwic3Ryb2tlIiwibWFya2Vyc0xhc3RJbmRleCIsIm1hcmtlclN0YXJ0U3R5bGVQcm9wIiwibWFya2VyTWlkU3R5bGVQcm9wIiwibWFya2VyRW5kU3R5bGVQcm9wIiwibWFya2VyIiwiX21hcmtlciIsIl9wb2ludCIsIl9hbmdsZSIsIl9tYXJrZXIyIiwiX3BvaW50MiIsIl9hbmdsZTIiLCJjb250cm9sUG9pbnQiLCJjdXJyZW50UG9pbnQiLCJiZXppZXJDdXJ2ZVRvIiwicXVhZHJhdGljQ3VydmVUbyIsInJYIiwiclkiLCJ4Um90IiwibEFyY0ZsYWciLCJzd2VlcEZsYWciLCJ4QXhpc1JvdGF0aW9uIiwiY3VycnAiLCJsIiwicyIsImNwcCIsImNlbnRwIiwiYTEiLCJhZCIsImRpciIsImFoIiwiaGFsZldheSIsInIiLCJzeCIsInN5IiwiYXJjIiwiQm9vbGVhbiIsIkdseXBoRWxlbWVudCIsImhvcml6QWR2WCIsInVuaWNvZGUiLCJhcmFiaWNGb3JtIiwiVGV4dEVsZW1lbnQiLCJtZWFzdXJlQ2FjaGUiLCJ0ZXh0QmFzZWxpbmUiLCJpbml0aWFsaXplQ29vcmRpbmF0ZXMiLCJsZWFmVGV4dHMiLCJ0ZXh0Q2h1bmtTdGFydCIsIlBPU0lUSVZFX0lORklOSVRZIiwibWF4WCIsIk5FR0FUSVZFX0lORklOSVRZIiwiZ2V0VEVsZW1lbnRCb3VuZGluZ0JveCIsImFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUiLCJjaGlsZEJvdW5kaW5nQm94IiwiZ2V0Q2hpbGRCb3VuZGluZ0JveCIsImdldEZvbnRTaXplIiwiaW5oZXJpdEZvbnRTaXplIiwibWVhc3VyZVRleHQiLCJnZXRHbHlwaCIsImNoYXIiLCJnbHlwaCIsImlzQXJhYmljIiwicHJldkNoYXIiLCJuZXh0Q2hhciIsImdseXBocyIsIm1heWJlR2x5cGgiLCJtaXNzaW5nR2x5cGgiLCJnZXRUZXh0RnJvbU5vZGUiLCJwYXJlbnROb2RlIiwibGFzdEluZGV4IiwicmVuZGVyVEVsZW1lbnRDaGlsZHJlbiIsInJlbmRlckNoaWxkIiwicmVuZGVyVGV4dCIsImN1c3RvbUZvbnQiLCJ1bml0c1BlckVtIiwiZm9udEZhY2UiLCJjdHhGb250IiwiaXNSVEwiLCJyZXZlcnNlIiwiZHgiLCJsdyIsImZpbGxUZXh0Iiwic3Ryb2tlVGV4dCIsImFwcGx5QW5jaG9yaW5nIiwiZmlyc3RFbGVtZW50IiwidGV4dEFuY2hvciIsInNoaWZ0IiwiYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUiLCJ0ZXh0UGFyZW50IiwiYWRqdXN0Q2hpbGRDb29yZGluYXRlcyIsInhBdHRyIiwieUF0dHIiLCJkeEF0dHIiLCJkeUF0dHIiLCJnZXRJbmhlcml0ZWRBdHRyaWJ1dGUiLCJtZWFzdXJlIiwibWVhc3VyZVRhcmdldFRleHQiLCJ0YXJnZXRUZXh0IiwiX21lYXN1cmUiLCJwYXJlbnRBdHRyIiwiVFNwYW5FbGVtZW50IiwiVGV4dE5vZGUiLCJTVkdFbGVtZW50Iiwicm9vdCIsIl90aGlzJG5vZGUkcGFyZW50Tm9kZSIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZm9udFNpemVQcm9wIiwicmVmWEF0dHIiLCJyZWZZQXR0ciIsInZpZXdCb3hBdHRyIiwicmVzaXplIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsIndpZHRoQXR0ciIsImhlaWdodEF0dHIiLCJzdHlsZUF0dHIiLCJvcmlnaW5XaWR0aCIsIm9yaWdpbkhlaWdodCIsInByZXNlcnZlQXNwZWN0UmF0aW9BdHRyIiwiUmVjdEVsZW1lbnQiLCJyeEF0dHIiLCJyeUF0dHIiLCJyeCIsInJ5IiwiS0FQUEEiLCJDaXJjbGVFbGVtZW50IiwiRWxsaXBzZUVsZW1lbnQiLCJMaW5lRWxlbWVudCIsImdldFBvaW50cyIsIngwIiwieTAiLCJQb2x5bGluZUVsZW1lbnQiLCJQb2x5Z29uRWxlbWVudCIsIlBhdHRlcm5FbGVtZW50IiwicGFyZW50T3BhY2l0eVByb3AiLCJwYXR0ZXJuU3ZnIiwicGF0dGVybkNhbnZhcyIsInBhdHRlcm5DdHgiLCJnZXRDb250ZXh0IiwicGF0dGVybiIsIk1hcmtlckVsZW1lbnQiLCJvcmllbnQiLCJtYXJrZXJVbml0cyIsIm1hcmtlclN2ZyIsIm92ZXJmbG93IiwiRGVmc0VsZW1lbnQiLCJHRWxlbWVudCIsIkdyYWRpZW50RWxlbWVudCIsImF0dHJpYnV0ZXNUb0luaGVyaXQiLCJzdG9wcyIsImdldEdyYWRpZW50VW5pdHMiLCJzdG9wc0NvbnRhaW5lciIsImluaGVyaXRTdG9wQ29udGFpbmVyIiwiZ3JhZGllbnQiLCJnZXRHcmFkaWVudCIsImFkZFBhcmVudE9wYWNpdHkiLCJhZGRDb2xvclN0b3AiLCJyb290VmlldyIsInJlY3QiLCJncm91cCIsImF0dHJpYnV0ZVRvSW5oZXJpdCIsImNvbG9yUHJvcCIsIkxpbmVhckdyYWRpZW50RWxlbWVudCIsImlzQm91bmRpbmdCb3hVbml0cyIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiUmFkaWFsR3JhZGllbnRFbGVtZW50IiwiZngiLCJmeSIsImZyIiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJTdG9wRWxlbWVudCIsInN0b3BPcGFjaXR5Iiwic3RvcENvbG9yIiwiQW5pbWF0ZUVsZW1lbnQiLCJkdXJhdGlvbiIsImluaXRpYWxWYWx1ZSIsImluaXRpYWxVbml0cyIsInJlbW92ZWQiLCJmcm96ZW4iLCJiZWdpbiIsIm1heER1cmF0aW9uIiwidG8iLCJ2YWx1ZXMiLCJ2YWx1ZXNBdHRyIiwiZ2V0UHJvcGVydHkiLCJhdHRyaWJ1dGVUeXBlIiwiYXR0cmlidXRlTmFtZSIsImNhbGNWYWx1ZSIsInByb2dyZXNzIiwiZ2V0UHJvZ3Jlc3MiLCJuZXdWYWx1ZSIsInByb3AiLCJ1cGRhdGVkIiwidHlwZUF0dHIiLCJwIiwibGIiLCJmbG9vciIsInViIiwiY2VpbCIsIkFuaW1hdGVDb2xvckVsZW1lbnQiLCJjb2xvckZyb20iLCJjb2xvclRvIiwiQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQiLCJ0cmFuc2Zvcm1Gcm9tIiwidHJhbnNmb3JtVG8iLCJGb250RWxlbWVudCIsImZvbnRGYW1pbHlTdHlsZSIsIkZvbnRGYWNlRWxlbWVudCIsImFzY2VudCIsImRlc2NlbnQiLCJNaXNzaW5nR2x5cGhFbGVtZW50IiwiVFJlZkVsZW1lbnQiLCJmaXJzdENoaWxkIiwiQUVsZW1lbnQiLCJoYXNUZXh0Iiwib3BlbiIsIm93bktleXMkMiIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiX29iamVjdFNwcmVhZCQyIiwidGFyZ2V0Iiwic291cmNlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIlRleHRQYXRoRWxlbWVudCIsInRleHRXaWR0aCIsInRleHRIZWlnaHQiLCJwYXRoTGVuZ3RoIiwiZ2x5cGhJbmZvIiwibGV0dGVyU3BhY2luZ0NhY2hlIiwibWVhc3VyZXNDYWNoZSIsIk1hcCIsInBhdGhFbGVtZW50IiwiZGF0YUFycmF5IiwicGFyc2VQYXRoRGF0YSIsInRoZXRhIiwiZFRoZXRhIiwicHNpIiwiZnMiLCJzZXRUZXh0RGF0YSIsInRleHREZWNvcmF0aW9uIiwicm90YXRpb24iLCJwYXJ0aWFsVGV4dCIsImdldExldHRlclNwYWNpbmdBdCIsImlkeCIsImZpbmRTZWdtZW50VG9GaXRDaGFyIiwiYW5jaG9yIiwidGV4dEZ1bGxXaWR0aCIsImZ1bGxQYXRoV2lkdGgiLCJzcGFjZXNOdW1iZXIiLCJpbnB1dE9mZnNldCIsImR5IiwiY2hhckkiLCJnbHlwaFdpZHRoIiwic3BsaW5lU3RlcCIsImdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgiLCJzZWdtZW50IiwiZHlYIiwiZHlZIiwiaGFzIiwiZ2V0IiwiY2hhcnMiLCJ0aGlzU3BhY2luZyIsInBhcmVudFNwYWNpbmciLCJsZXR0ZXJTcGFjaW5nIiwidGV4dExlbiIsImR4U3VtIiwiYWNjIiwiY3VyIiwiZ2V0UGF0aExlbmd0aCIsInN0YXJ0T2Zmc2V0IiwibmV4dE9mZnNldCIsInBhdGhDb21tYW5kcyIsInN0YXJ0WCIsInN0YXJ0WSIsIm5leHRDb21tYW5kVHlwZSIsImNhbGNMZW5ndGgiLCJjb21tYW5kVHlwZSIsImdldExpbmVMZW5ndGgiLCJnZXRQb2ludE9uQ3ViaWNCZXppZXIiLCJnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyIiwiZW5kIiwiaW5jIiwiYWJzIiwiZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMiLCJnZXRQb2ludE9uTGluZSIsImRpc3QiLCJmcm9tWCIsImZyb21ZIiwibSIsInJpc2UiLCJwdCIsIml4IiwiaXkiLCJwUmlzZSIsInBSdW4iLCJnZXRQb2ludE9uUGF0aCIsImRpc3RhbmNlIiwiZnVsbExlbiIsImN1bXVsYXRpdmVQYXRoTGVuZ3RoIiwiY3VycmVudFQiLCJwY3QiLCJwNHgiLCJwNHkiLCJjb3NQc2kiLCJzaW5Qc2kiLCJidWlsZEVxdWlkaXN0YW50Q2FjaGUiLCJpbnB1dFN0ZXAiLCJpbnB1dFByZWNpc2lvbiIsInByZWNpc2lvbiIsInN0ZXAiLCJlcXVpZGlzdGFudENhY2hlIiwidGFyZ2V0RGlzdGFuY2UiLCJkYXRhVXJpUmVnZXgiLCJJbWFnZUVsZW1lbnQiLCJsb2FkZWQiLCJocmVmIiwiaXNTdmciLCJpbWFnZXMiLCJsb2FkU3ZnIiwiaW1hZ2UiLCJjb25zb2xlIiwiZXJyb3IiLCJhdG9iIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic3ZnIiwic3ViRG9jdW1lbnQiLCJjYW52ZyIsImZvcmtTdHJpbmciLCJkb2N1bWVudEVsZW1lbnQiLCJfaW1hZ2UiLCJjb21wbGV0ZSIsImRyYXdJbWFnZSIsIlN5bWJvbEVsZW1lbnQiLCJTVkdGb250TG9hZGVyIiwiZm9udHMiLCJzdmdEb2N1bWVudCIsImZvbnROb2RlIiwiU3R5bGVFbGVtZW50IiwiY3NzIiwiY3NzRGVmcyIsImNzc1BhcnRzIiwiY3NzQ2xhc3NlcyIsImNzc1Byb3BzIiwiY3NzQ2xhc3MiLCJwcm9wcyIsImNzc1Byb3AiLCJzdWJzdHIiLCJzcmNzIiwic3JjIiwiVXNlRWxlbWVudCIsInRlbXBTdmciLCJvbGRQYXJlbnQiLCJlbGVtZW50VHJhbnNmb3JtIiwiY2FjaGVkRWxlbWVudCIsImltR2V0IiwiX2hlaWdodCIsInJnYmEiLCJpbVNldCIsInZhbCIsIm1pIiwibTEiLCJtMiIsIm0zIiwiRmVDb2xvck1hdHJpeEVsZW1lbnQiLCJpbmNsdWRlT3BhY2l0eSIsIl94IiwiX3kiLCJzcmNEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwibnIiLCJuZyIsIm5iIiwibmEiLCJwdXRJbWFnZURhdGEiLCJNYXNrRWxlbWVudCIsImlnbm9yZWRTdHlsZXMiLCJtYXNrQ2FudmFzIiwibWFza0N0eCIsInRtcENhbnZhcyIsInRtcEN0eCIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImZpbGxSZWN0Iiwibm9vcCIsIkNsaXBQYXRoRWxlbWVudCIsImNvbnRleHRQcm90byIsImdldFByb3RvdHlwZU9mIiwiRmlsdGVyRWxlbWVudCIsInB4IiwicHkiLCJlZmQiLCJleHRyYUZpbHRlckRpc3RhbmNlIiwidG1wQ2FudmFzV2lkdGgiLCJ0bXBDYW52YXNIZWlnaHQiLCJGZURyb3BTaGFkb3dFbGVtZW50IiwiX3dpZHRoIiwiRmVNb3JwaG9sb2d5RWxlbWVudCIsIkZlQ29tcG9zaXRlRWxlbWVudCIsIkZlR2F1c3NpYW5CbHVyRWxlbWVudCIsImJsdXJSYWRpdXMiLCJib2R5IiwiZ2V0VW5pcXVlSWQiLCJkaXNwbGF5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsIlRpdGxlRWxlbWVudCIsIkRlc2NFbGVtZW50IiwiZWxlbWVudHMiLCJvd25LZXlzJDEiLCJfb2JqZWN0U3ByZWFkJDEiLCJfY3JlYXRlSW1hZ2UiLCJhbm9ueW1vdXNDcm9zc09yaWdpbiIsImNyb3NzT3JpZ2luIiwicmVqZWN0Iiwib25sb2FkIiwib25lcnJvciIsIl9ldmVudCIsIl9zb3VyY2UiLCJfbGluZW5vIiwiX2NvbG5vIiwiRG9jdW1lbnQiLCJlbVNpemVTdGFjayIsInVuaXF1ZUlkIiwiYmluZENyZWF0ZUltYWdlIiwiaXNJbWFnZXNMb2FkZWQiLCJpc0ZvbnRzTG9hZGVkIiwiZm9yY2VBbm9ueW1vdXNDcm9zc09yaWdpbiIsImNyZWF0ZURvY3VtZW50RWxlbWVudCIsImVsZW1lbnRUeXBlIiwiRWxlbWVudFR5cGUiLCJlbGVtZW50VHlwZXMiLCJjb25maWciLCJvd25LZXlzIiwiX29iamVjdFNwcmVhZCIsIkNhbnZnIiwib3B0aW9ucyIsIl9hcmd1bWVudHMiLCJmcm9tU3RyaW5nIiwiZm9yayIsIl9hcmd1bWVudHMyIiwiYmFzZU9wdGlvbnMiLCJkZWZhdWx0IiwicHJlc2V0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvg/lib/index.es.js\n");

/***/ })

};
;